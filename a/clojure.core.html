<head><link href="/Users/russell/src/autochrome/code.css" rel="stylesheet" /><div class="container"><pre><code class="gutter"><span class="punctuation" id="L1">0001
</span><span class="punctuation" id="L2">0002
</span><span class="punctuation" id="L3">0003
</span><span class="punctuation" id="L4">0004
</span><span class="punctuation" id="L5">0005
</span><span class="punctuation" id="L6">0006
</span><span class="punctuation" id="L7">0007
</span><span class="punctuation" id="L8">0008
</span><span class="punctuation" id="L9">0009
</span><span class="punctuation" id="L10">0010
</span><span class="punctuation" id="L11">0011
</span><span class="punctuation" id="L12">0012
</span><span class="punctuation" id="L13">0013
</span><span class="punctuation" id="L14">0014
</span><span class="punctuation" id="L15">0015
</span><span class="punctuation" id="L16">0016
</span><span class="punctuation" id="L17">0017
</span><span class="punctuation" id="L18">0018
</span><span class="punctuation" id="L19">0019
</span><span class="punctuation" id="L20">0020
</span><span class="punctuation" id="L21">0021
</span><span class="punctuation" id="L22">0022
</span><span class="punctuation" id="L23">0023
</span><span class="punctuation" id="L24">0024
</span><span class="punctuation" id="L25">0025
</span><span class="punctuation" id="L26">0026
</span><span class="punctuation" id="L27">0027
</span><span class="punctuation" id="L28">0028
</span><span class="punctuation" id="L29">0029
</span><span class="punctuation" id="L30">0030
</span><span class="punctuation" id="L31">0031
</span><span class="punctuation" id="L32">0032
</span><span class="punctuation" id="L33">0033
</span><span class="punctuation" id="L34">0034
</span><span class="punctuation" id="L35">0035
</span><span class="punctuation" id="L36">0036
</span><span class="punctuation" id="L37">0037
</span><span class="punctuation" id="L38">0038
</span><span class="punctuation" id="L39">0039
</span><span class="punctuation" id="L40">0040
</span><span class="punctuation" id="L41">0041
</span><span class="punctuation" id="L42">0042
</span><span class="punctuation" id="L43">0043
</span><span class="punctuation" id="L44">0044
</span><span class="punctuation" id="L45">0045
</span><span class="punctuation" id="L46">0046
</span><span class="punctuation" id="L47">0047
</span><span class="punctuation" id="L48">0048
</span><span class="punctuation" id="L49">0049
</span><span class="punctuation" id="L50">0050
</span><span class="punctuation" id="L51">0051
</span><span class="punctuation" id="L52">0052
</span><span class="punctuation" id="L53">0053
</span><span class="punctuation" id="L54">0054
</span><span class="punctuation" id="L55">0055
</span><span class="punctuation" id="L56">0056
</span><span class="punctuation" id="L57">0057
</span><span class="punctuation" id="L58">0058
</span><span class="punctuation" id="L59">0059
</span><span class="punctuation" id="L60">0060
</span><span class="punctuation" id="L61">0061
</span><span class="punctuation" id="L62">0062
</span><span class="punctuation" id="L63">0063
</span><span class="punctuation" id="L64">0064
</span><span class="punctuation" id="L65">0065
</span><span class="punctuation" id="L66">0066
</span><span class="punctuation" id="L67">0067
</span><span class="punctuation" id="L68">0068
</span><span class="punctuation" id="L69">0069
</span><span class="punctuation" id="L70">0070
</span><span class="punctuation" id="L71">0071
</span><span class="punctuation" id="L72">0072
</span><span class="punctuation" id="L73">0073
</span><span class="punctuation" id="L74">0074
</span><span class="punctuation" id="L75">0075
</span><span class="punctuation" id="L76">0076
</span><span class="punctuation" id="L77">0077
</span><span class="punctuation" id="L78">0078
</span><span class="punctuation" id="L79">0079
</span><span class="punctuation" id="L80">0080
</span><span class="punctuation" id="L81">0081
</span><span class="punctuation" id="L82">0082
</span><span class="punctuation" id="L83">0083
</span><span class="punctuation" id="L84">0084
</span><span class="punctuation" id="L85">0085
</span><span class="punctuation" id="L86">0086
</span><span class="punctuation" id="L87">0087
</span><span class="punctuation" id="L88">0088
</span><span class="punctuation" id="L89">0089
</span><span class="punctuation" id="L90">0090
</span><span class="punctuation" id="L91">0091
</span><span class="punctuation" id="L92">0092
</span><span class="punctuation" id="L93">0093
</span><span class="punctuation" id="L94">0094
</span><span class="punctuation" id="L95">0095
</span><span class="punctuation" id="L96">0096
</span><span class="punctuation" id="L97">0097
</span><span class="punctuation" id="L98">0098
</span><span class="punctuation" id="L99">0099
</span><span class="punctuation" id="L100">0100
</span><span class="punctuation" id="L101">0101
</span><span class="punctuation" id="L102">0102
</span><span class="punctuation" id="L103">0103
</span><span class="punctuation" id="L104">0104
</span><span class="punctuation" id="L105">0105
</span><span class="punctuation" id="L106">0106
</span><span class="punctuation" id="L107">0107
</span><span class="punctuation" id="L108">0108
</span><span class="punctuation" id="L109">0109
</span><span class="punctuation" id="L110">0110
</span><span class="punctuation" id="L111">0111
</span><span class="punctuation" id="L112">0112
</span><span class="punctuation" id="L113">0113
</span><span class="punctuation" id="L114">0114
</span><span class="punctuation" id="L115">0115
</span><span class="punctuation" id="L116">0116
</span><span class="punctuation" id="L117">0117
</span><span class="punctuation" id="L118">0118
</span><span class="punctuation" id="L119">0119
</span><span class="punctuation" id="L120">0120
</span><span class="punctuation" id="L121">0121
</span><span class="punctuation" id="L122">0122
</span><span class="punctuation" id="L123">0123
</span><span class="punctuation" id="L124">0124
</span><span class="punctuation" id="L125">0125
</span><span class="punctuation" id="L126">0126
</span><span class="punctuation" id="L127">0127
</span><span class="punctuation" id="L128">0128
</span><span class="punctuation" id="L129">0129
</span><span class="punctuation" id="L130">0130
</span><span class="punctuation" id="L131">0131
</span><span class="punctuation" id="L132">0132
</span><span class="punctuation" id="L133">0133
</span><span class="punctuation" id="L134">0134
</span><span class="punctuation" id="L135">0135
</span><span class="punctuation" id="L136">0136
</span><span class="punctuation" id="L137">0137
</span><span class="punctuation" id="L138">0138
</span><span class="punctuation" id="L139">0139
</span><span class="punctuation" id="L140">0140
</span><span class="punctuation" id="L141">0141
</span><span class="punctuation" id="L142">0142
</span><span class="punctuation" id="L143">0143
</span><span class="punctuation" id="L144">0144
</span><span class="punctuation" id="L145">0145
</span><span class="punctuation" id="L146">0146
</span><span class="punctuation" id="L147">0147
</span><span class="punctuation" id="L148">0148
</span><span class="punctuation" id="L149">0149
</span><span class="punctuation" id="L150">0150
</span><span class="punctuation" id="L151">0151
</span><span class="punctuation" id="L152">0152
</span><span class="punctuation" id="L153">0153
</span><span class="punctuation" id="L154">0154
</span><span class="punctuation" id="L155">0155
</span><span class="punctuation" id="L156">0156
</span><span class="punctuation" id="L157">0157
</span><span class="punctuation" id="L158">0158
</span><span class="punctuation" id="L159">0159
</span><span class="punctuation" id="L160">0160
</span><span class="punctuation" id="L161">0161
</span><span class="punctuation" id="L162">0162
</span><span class="punctuation" id="L163">0163
</span><span class="punctuation" id="L164">0164
</span><span class="punctuation" id="L165">0165
</span><span class="punctuation" id="L166">0166
</span><span class="punctuation" id="L167">0167
</span><span class="punctuation" id="L168">0168
</span><span class="punctuation" id="L169">0169
</span><span class="punctuation" id="L170">0170
</span><span class="punctuation" id="L171">0171
</span><span class="punctuation" id="L172">0172
</span><span class="punctuation" id="L173">0173
</span><span class="punctuation" id="L174">0174
</span><span class="punctuation" id="L175">0175
</span><span class="punctuation" id="L176">0176
</span><span class="punctuation" id="L177">0177
</span><span class="punctuation" id="L178">0178
</span><span class="punctuation" id="L179">0179
</span><span class="punctuation" id="L180">0180
</span><span class="punctuation" id="L181">0181
</span><span class="punctuation" id="L182">0182
</span><span class="punctuation" id="L183">0183
</span><span class="punctuation" id="L184">0184
</span><span class="punctuation" id="L185">0185
</span><span class="punctuation" id="L186">0186
</span><span class="punctuation" id="L187">0187
</span><span class="punctuation" id="L188">0188
</span><span class="punctuation" id="L189">0189
</span><span class="punctuation" id="L190">0190
</span><span class="punctuation" id="L191">0191
</span><span class="punctuation" id="L192">0192
</span><span class="punctuation" id="L193">0193
</span><span class="punctuation" id="L194">0194
</span><span class="punctuation" id="L195">0195
</span><span class="punctuation" id="L196">0196
</span><span class="punctuation" id="L197">0197
</span><span class="punctuation" id="L198">0198
</span><span class="punctuation" id="L199">0199
</span><span class="punctuation" id="L200">0200
</span><span class="punctuation" id="L201">0201
</span><span class="punctuation" id="L202">0202
</span><span class="punctuation" id="L203">0203
</span><span class="punctuation" id="L204">0204
</span><span class="punctuation" id="L205">0205
</span><span class="punctuation" id="L206">0206
</span><span class="punctuation" id="L207">0207
</span><span class="punctuation" id="L208">0208
</span><span class="punctuation" id="L209">0209
</span><span class="punctuation" id="L210">0210
</span><span class="punctuation" id="L211">0211
</span><span class="punctuation" id="L212">0212
</span><span class="punctuation" id="L213">0213
</span><span class="punctuation" id="L214">0214
</span><span class="punctuation" id="L215">0215
</span><span class="punctuation" id="L216">0216
</span><span class="punctuation" id="L217">0217
</span><span class="punctuation" id="L218">0218
</span><span class="punctuation" id="L219">0219
</span><span class="punctuation" id="L220">0220
</span><span class="punctuation" id="L221">0221
</span><span class="punctuation" id="L222">0222
</span><span class="punctuation" id="L223">0223
</span><span class="punctuation" id="L224">0224
</span><span class="punctuation" id="L225">0225
</span><span class="punctuation" id="L226">0226
</span><span class="punctuation" id="L227">0227
</span><span class="punctuation" id="L228">0228
</span><span class="punctuation" id="L229">0229
</span><span class="punctuation" id="L230">0230
</span><span class="punctuation" id="L231">0231
</span><span class="punctuation" id="L232">0232
</span><span class="punctuation" id="L233">0233
</span><span class="punctuation" id="L234">0234
</span><span class="punctuation" id="L235">0235
</span><span class="punctuation" id="L236">0236
</span><span class="punctuation" id="L237">0237
</span><span class="punctuation" id="L238">0238
</span><span class="punctuation" id="L239">0239
</span><span class="punctuation" id="L240">0240
</span><span class="punctuation" id="L241">0241
</span><span class="punctuation" id="L242">0242
</span><span class="punctuation" id="L243">0243
</span><span class="punctuation" id="L244">0244
</span><span class="punctuation" id="L245">0245
</span><span class="punctuation" id="L246">0246
</span><span class="punctuation" id="L247">0247
</span><span class="punctuation" id="L248">0248
</span><span class="punctuation" id="L249">0249
</span><span class="punctuation" id="L250">0250
</span><span class="punctuation" id="L251">0251
</span><span class="punctuation" id="L252">0252
</span><span class="punctuation" id="L253">0253
</span><span class="punctuation" id="L254">0254
</span><span class="punctuation" id="L255">0255
</span><span class="punctuation" id="L256">0256
</span><span class="punctuation" id="L257">0257
</span><span class="punctuation" id="L258">0258
</span><span class="punctuation" id="L259">0259
</span><span class="punctuation" id="L260">0260
</span><span class="punctuation" id="L261">0261
</span><span class="punctuation" id="L262">0262
</span><span class="punctuation" id="L263">0263
</span><span class="punctuation" id="L264">0264
</span><span class="punctuation" id="L265">0265
</span><span class="punctuation" id="L266">0266
</span><span class="punctuation" id="L267">0267
</span><span class="punctuation" id="L268">0268
</span><span class="punctuation" id="L269">0269
</span><span class="punctuation" id="L270">0270
</span><span class="punctuation" id="L271">0271
</span><span class="punctuation" id="L272">0272
</span><span class="punctuation" id="L273">0273
</span><span class="punctuation" id="L274">0274
</span><span class="punctuation" id="L275">0275
</span><span class="punctuation" id="L276">0276
</span><span class="punctuation" id="L277">0277
</span><span class="punctuation" id="L278">0278
</span><span class="punctuation" id="L279">0279
</span><span class="punctuation" id="L280">0280
</span><span class="punctuation" id="L281">0281
</span><span class="punctuation" id="L282">0282
</span><span class="punctuation" id="L283">0283
</span><span class="punctuation" id="L284">0284
</span><span class="punctuation" id="L285">0285
</span><span class="punctuation" id="L286">0286
</span><span class="punctuation" id="L287">0287
</span><span class="punctuation" id="L288">0288
</span><span class="punctuation" id="L289">0289
</span><span class="punctuation" id="L290">0290
</span><span class="punctuation" id="L291">0291
</span><span class="punctuation" id="L292">0292
</span><span class="punctuation" id="L293">0293
</span><span class="punctuation" id="L294">0294
</span><span class="punctuation" id="L295">0295
</span><span class="punctuation" id="L296">0296
</span><span class="punctuation" id="L297">0297
</span><span class="punctuation" id="L298">0298
</span><span class="punctuation" id="L299">0299
</span><span class="punctuation" id="L300">0300
</span><span class="punctuation" id="L301">0301
</span><span class="punctuation" id="L302">0302
</span><span class="punctuation" id="L303">0303
</span><span class="punctuation" id="L304">0304
</span><span class="punctuation" id="L305">0305
</span><span class="punctuation" id="L306">0306
</span><span class="punctuation" id="L307">0307
</span><span class="punctuation" id="L308">0308
</span><span class="punctuation" id="L309">0309
</span><span class="punctuation" id="L310">0310
</span><span class="punctuation" id="L311">0311
</span><span class="punctuation" id="L312">0312
</span><span class="punctuation" id="L313">0313
</span><span class="punctuation" id="L314">0314
</span><span class="punctuation" id="L315">0315
</span><span class="punctuation" id="L316">0316
</span><span class="punctuation" id="L317">0317
</span><span class="punctuation" id="L318">0318
</span><span class="punctuation" id="L319">0319
</span><span class="punctuation" id="L320">0320
</span><span class="punctuation" id="L321">0321
</span><span class="punctuation" id="L322">0322
</span><span class="punctuation" id="L323">0323
</span><span class="punctuation" id="L324">0324
</span><span class="punctuation" id="L325">0325
</span><span class="punctuation" id="L326">0326
</span><span class="punctuation" id="L327">0327
</span><span class="punctuation" id="L328">0328
</span><span class="punctuation" id="L329">0329
</span><span class="punctuation" id="L330">0330
</span><span class="punctuation" id="L331">0331
</span><span class="punctuation" id="L332">0332
</span><span class="punctuation" id="L333">0333
</span><span class="punctuation" id="L334">0334
</span><span class="punctuation" id="L335">0335
</span><span class="punctuation" id="L336">0336
</span><span class="punctuation" id="L337">0337
</span><span class="punctuation" id="L338">0338
</span><span class="punctuation" id="L339">0339
</span><span class="punctuation" id="L340">0340
</span><span class="punctuation" id="L341">0341
</span><span class="punctuation" id="L342">0342
</span><span class="punctuation" id="L343">0343
</span><span class="punctuation" id="L344">0344
</span><span class="punctuation" id="L345">0345
</span><span class="punctuation" id="L346">0346
</span><span class="punctuation" id="L347">0347
</span><span class="punctuation" id="L348">0348
</span><span class="punctuation" id="L349">0349
</span><span class="punctuation" id="L350">0350
</span><span class="punctuation" id="L351">0351
</span><span class="punctuation" id="L352">0352
</span><span class="punctuation" id="L353">0353
</span><span class="punctuation" id="L354">0354
</span><span class="punctuation" id="L355">0355
</span><span class="punctuation" id="L356">0356
</span><span class="punctuation" id="L357">0357
</span><span class="punctuation" id="L358">0358
</span><span class="punctuation" id="L359">0359
</span><span class="punctuation" id="L360">0360
</span><span class="punctuation" id="L361">0361
</span><span class="punctuation" id="L362">0362
</span><span class="punctuation" id="L363">0363
</span><span class="punctuation" id="L364">0364
</span><span class="punctuation" id="L365">0365
</span><span class="punctuation" id="L366">0366
</span><span class="punctuation" id="L367">0367
</span><span class="punctuation" id="L368">0368
</span><span class="punctuation" id="L369">0369
</span><span class="punctuation" id="L370">0370
</span><span class="punctuation" id="L371">0371
</span><span class="punctuation" id="L372">0372
</span><span class="punctuation" id="L373">0373
</span><span class="punctuation" id="L374">0374
</span><span class="punctuation" id="L375">0375
</span><span class="punctuation" id="L376">0376
</span><span class="punctuation" id="L377">0377
</span><span class="punctuation" id="L378">0378
</span><span class="punctuation" id="L379">0379
</span><span class="punctuation" id="L380">0380
</span><span class="punctuation" id="L381">0381
</span><span class="punctuation" id="L382">0382
</span><span class="punctuation" id="L383">0383
</span><span class="punctuation" id="L384">0384
</span><span class="punctuation" id="L385">0385
</span><span class="punctuation" id="L386">0386
</span><span class="punctuation" id="L387">0387
</span><span class="punctuation" id="L388">0388
</span><span class="punctuation" id="L389">0389
</span><span class="punctuation" id="L390">0390
</span><span class="punctuation" id="L391">0391
</span><span class="punctuation" id="L392">0392
</span><span class="punctuation" id="L393">0393
</span><span class="punctuation" id="L394">0394
</span><span class="punctuation" id="L395">0395
</span><span class="punctuation" id="L396">0396
</span><span class="punctuation" id="L397">0397
</span><span class="punctuation" id="L398">0398
</span><span class="punctuation" id="L399">0399
</span><span class="punctuation" id="L400">0400
</span><span class="punctuation" id="L401">0401
</span><span class="punctuation" id="L402">0402
</span><span class="punctuation" id="L403">0403
</span><span class="punctuation" id="L404">0404
</span><span class="punctuation" id="L405">0405
</span><span class="punctuation" id="L406">0406
</span><span class="punctuation" id="L407">0407
</span><span class="punctuation" id="L408">0408
</span><span class="punctuation" id="L409">0409
</span><span class="punctuation" id="L410">0410
</span><span class="punctuation" id="L411">0411
</span><span class="punctuation" id="L412">0412
</span><span class="punctuation" id="L413">0413
</span><span class="punctuation" id="L414">0414
</span><span class="punctuation" id="L415">0415
</span><span class="punctuation" id="L416">0416
</span><span class="punctuation" id="L417">0417
</span><span class="punctuation" id="L418">0418
</span><span class="punctuation" id="L419">0419
</span><span class="punctuation" id="L420">0420
</span><span class="punctuation" id="L421">0421
</span><span class="punctuation" id="L422">0422
</span><span class="punctuation" id="L423">0423
</span><span class="punctuation" id="L424">0424
</span><span class="punctuation" id="L425">0425
</span><span class="punctuation" id="L426">0426
</span><span class="punctuation" id="L427">0427
</span><span class="punctuation" id="L428">0428
</span><span class="punctuation" id="L429">0429
</span><span class="punctuation" id="L430">0430
</span><span class="punctuation" id="L431">0431
</span><span class="punctuation" id="L432">0432
</span><span class="punctuation" id="L433">0433
</span><span class="punctuation" id="L434">0434
</span><span class="punctuation" id="L435">0435
</span><span class="punctuation" id="L436">0436
</span><span class="punctuation" id="L437">0437
</span><span class="punctuation" id="L438">0438
</span><span class="punctuation" id="L439">0439
</span><span class="punctuation" id="L440">0440
</span><span class="punctuation" id="L441">0441
</span><span class="punctuation" id="L442">0442
</span><span class="punctuation" id="L443">0443
</span><span class="punctuation" id="L444">0444
</span><span class="punctuation" id="L445">0445
</span><span class="punctuation" id="L446">0446
</span><span class="punctuation" id="L447">0447
</span><span class="punctuation" id="L448">0448
</span><span class="punctuation" id="L449">0449
</span><span class="punctuation" id="L450">0450
</span><span class="punctuation" id="L451">0451
</span><span class="punctuation" id="L452">0452
</span><span class="punctuation" id="L453">0453
</span><span class="punctuation" id="L454">0454
</span><span class="punctuation" id="L455">0455
</span><span class="punctuation" id="L456">0456
</span><span class="punctuation" id="L457">0457
</span><span class="punctuation" id="L458">0458
</span><span class="punctuation" id="L459">0459
</span><span class="punctuation" id="L460">0460
</span><span class="punctuation" id="L461">0461
</span><span class="punctuation" id="L462">0462
</span><span class="punctuation" id="L463">0463
</span><span class="punctuation" id="L464">0464
</span><span class="punctuation" id="L465">0465
</span><span class="punctuation" id="L466">0466
</span><span class="punctuation" id="L467">0467
</span><span class="punctuation" id="L468">0468
</span><span class="punctuation" id="L469">0469
</span><span class="punctuation" id="L470">0470
</span><span class="punctuation" id="L471">0471
</span><span class="punctuation" id="L472">0472
</span><span class="punctuation" id="L473">0473
</span><span class="punctuation" id="L474">0474
</span><span class="punctuation" id="L475">0475
</span><span class="punctuation" id="L476">0476
</span><span class="punctuation" id="L477">0477
</span><span class="punctuation" id="L478">0478
</span><span class="punctuation" id="L479">0479
</span><span class="punctuation" id="L480">0480
</span><span class="punctuation" id="L481">0481
</span><span class="punctuation" id="L482">0482
</span><span class="punctuation" id="L483">0483
</span><span class="punctuation" id="L484">0484
</span><span class="punctuation" id="L485">0485
</span><span class="punctuation" id="L486">0486
</span><span class="punctuation" id="L487">0487
</span><span class="punctuation" id="L488">0488
</span><span class="punctuation" id="L489">0489
</span><span class="punctuation" id="L490">0490
</span><span class="punctuation" id="L491">0491
</span><span class="punctuation" id="L492">0492
</span><span class="punctuation" id="L493">0493
</span><span class="punctuation" id="L494">0494
</span><span class="punctuation" id="L495">0495
</span><span class="punctuation" id="L496">0496
</span><span class="punctuation" id="L497">0497
</span><span class="punctuation" id="L498">0498
</span><span class="punctuation" id="L499">0499
</span><span class="punctuation" id="L500">0500
</span><span class="punctuation" id="L501">0501
</span><span class="punctuation" id="L502">0502
</span><span class="punctuation" id="L503">0503
</span><span class="punctuation" id="L504">0504
</span><span class="punctuation" id="L505">0505
</span><span class="punctuation" id="L506">0506
</span><span class="punctuation" id="L507">0507
</span><span class="punctuation" id="L508">0508
</span><span class="punctuation" id="L509">0509
</span><span class="punctuation" id="L510">0510
</span><span class="punctuation" id="L511">0511
</span><span class="punctuation" id="L512">0512
</span><span class="punctuation" id="L513">0513
</span><span class="punctuation" id="L514">0514
</span><span class="punctuation" id="L515">0515
</span><span class="punctuation" id="L516">0516
</span><span class="punctuation" id="L517">0517
</span><span class="punctuation" id="L518">0518
</span><span class="punctuation" id="L519">0519
</span><span class="punctuation" id="L520">0520
</span><span class="punctuation" id="L521">0521
</span><span class="punctuation" id="L522">0522
</span><span class="punctuation" id="L523">0523
</span><span class="punctuation" id="L524">0524
</span><span class="punctuation" id="L525">0525
</span><span class="punctuation" id="L526">0526
</span><span class="punctuation" id="L527">0527
</span><span class="punctuation" id="L528">0528
</span><span class="punctuation" id="L529">0529
</span><span class="punctuation" id="L530">0530
</span><span class="punctuation" id="L531">0531
</span><span class="punctuation" id="L532">0532
</span><span class="punctuation" id="L533">0533
</span><span class="punctuation" id="L534">0534
</span><span class="punctuation" id="L535">0535
</span><span class="punctuation" id="L536">0536
</span><span class="punctuation" id="L537">0537
</span><span class="punctuation" id="L538">0538
</span><span class="punctuation" id="L539">0539
</span><span class="punctuation" id="L540">0540
</span><span class="punctuation" id="L541">0541
</span><span class="punctuation" id="L542">0542
</span><span class="punctuation" id="L543">0543
</span><span class="punctuation" id="L544">0544
</span><span class="punctuation" id="L545">0545
</span><span class="punctuation" id="L546">0546
</span><span class="punctuation" id="L547">0547
</span><span class="punctuation" id="L548">0548
</span><span class="punctuation" id="L549">0549
</span><span class="punctuation" id="L550">0550
</span><span class="punctuation" id="L551">0551
</span><span class="punctuation" id="L552">0552
</span><span class="punctuation" id="L553">0553
</span><span class="punctuation" id="L554">0554
</span><span class="punctuation" id="L555">0555
</span><span class="punctuation" id="L556">0556
</span><span class="punctuation" id="L557">0557
</span><span class="punctuation" id="L558">0558
</span><span class="punctuation" id="L559">0559
</span><span class="punctuation" id="L560">0560
</span><span class="punctuation" id="L561">0561
</span><span class="punctuation" id="L562">0562
</span><span class="punctuation" id="L563">0563
</span><span class="punctuation" id="L564">0564
</span><span class="punctuation" id="L565">0565
</span><span class="punctuation" id="L566">0566
</span><span class="punctuation" id="L567">0567
</span><span class="punctuation" id="L568">0568
</span><span class="punctuation" id="L569">0569
</span><span class="punctuation" id="L570">0570
</span><span class="punctuation" id="L571">0571
</span><span class="punctuation" id="L572">0572
</span><span class="punctuation" id="L573">0573
</span><span class="punctuation" id="L574">0574
</span><span class="punctuation" id="L575">0575
</span><span class="punctuation" id="L576">0576
</span><span class="punctuation" id="L577">0577
</span><span class="punctuation" id="L578">0578
</span><span class="punctuation" id="L579">0579
</span><span class="punctuation" id="L580">0580
</span><span class="punctuation" id="L581">0581
</span><span class="punctuation" id="L582">0582
</span><span class="punctuation" id="L583">0583
</span><span class="punctuation" id="L584">0584
</span><span class="punctuation" id="L585">0585
</span><span class="punctuation" id="L586">0586
</span><span class="punctuation" id="L587">0587
</span><span class="punctuation" id="L588">0588
</span><span class="punctuation" id="L589">0589
</span><span class="punctuation" id="L590">0590
</span><span class="punctuation" id="L591">0591
</span><span class="punctuation" id="L592">0592
</span><span class="punctuation" id="L593">0593
</span><span class="punctuation" id="L594">0594
</span><span class="punctuation" id="L595">0595
</span><span class="punctuation" id="L596">0596
</span><span class="punctuation" id="L597">0597
</span><span class="punctuation" id="L598">0598
</span><span class="punctuation" id="L599">0599
</span><span class="punctuation" id="L600">0600
</span><span class="punctuation" id="L601">0601
</span><span class="punctuation" id="L602">0602
</span><span class="punctuation" id="L603">0603
</span><span class="punctuation" id="L604">0604
</span><span class="punctuation" id="L605">0605
</span><span class="punctuation" id="L606">0606
</span><span class="punctuation" id="L607">0607
</span><span class="punctuation" id="L608">0608
</span><span class="punctuation" id="L609">0609
</span><span class="punctuation" id="L610">0610
</span><span class="punctuation" id="L611">0611
</span><span class="punctuation" id="L612">0612
</span><span class="punctuation" id="L613">0613
</span><span class="punctuation" id="L614">0614
</span><span class="punctuation" id="L615">0615
</span><span class="punctuation" id="L616">0616
</span><span class="punctuation" id="L617">0617
</span><span class="punctuation" id="L618">0618
</span><span class="punctuation" id="L619">0619
</span><span class="punctuation" id="L620">0620
</span><span class="punctuation" id="L621">0621
</span><span class="punctuation" id="L622">0622
</span><span class="punctuation" id="L623">0623
</span><span class="punctuation" id="L624">0624
</span><span class="punctuation" id="L625">0625
</span><span class="punctuation" id="L626">0626
</span><span class="punctuation" id="L627">0627
</span><span class="punctuation" id="L628">0628
</span><span class="punctuation" id="L629">0629
</span><span class="punctuation" id="L630">0630
</span><span class="punctuation" id="L631">0631
</span><span class="punctuation" id="L632">0632
</span><span class="punctuation" id="L633">0633
</span><span class="punctuation" id="L634">0634
</span><span class="punctuation" id="L635">0635
</span><span class="punctuation" id="L636">0636
</span><span class="punctuation" id="L637">0637
</span><span class="punctuation" id="L638">0638
</span><span class="punctuation" id="L639">0639
</span><span class="punctuation" id="L640">0640
</span><span class="punctuation" id="L641">0641
</span><span class="punctuation" id="L642">0642
</span><span class="punctuation" id="L643">0643
</span><span class="punctuation" id="L644">0644
</span><span class="punctuation" id="L645">0645
</span><span class="punctuation" id="L646">0646
</span><span class="punctuation" id="L647">0647
</span><span class="punctuation" id="L648">0648
</span><span class="punctuation" id="L649">0649
</span><span class="punctuation" id="L650">0650
</span><span class="punctuation" id="L651">0651
</span><span class="punctuation" id="L652">0652
</span><span class="punctuation" id="L653">0653
</span><span class="punctuation" id="L654">0654
</span><span class="punctuation" id="L655">0655
</span><span class="punctuation" id="L656">0656
</span><span class="punctuation" id="L657">0657
</span><span class="punctuation" id="L658">0658
</span><span class="punctuation" id="L659">0659
</span><span class="punctuation" id="L660">0660
</span><span class="punctuation" id="L661">0661
</span><span class="punctuation" id="L662">0662
</span><span class="punctuation" id="L663">0663
</span><span class="punctuation" id="L664">0664
</span><span class="punctuation" id="L665">0665
</span><span class="punctuation" id="L666">0666
</span><span class="punctuation" id="L667">0667
</span><span class="punctuation" id="L668">0668
</span><span class="punctuation" id="L669">0669
</span><span class="punctuation" id="L670">0670
</span><span class="punctuation" id="L671">0671
</span><span class="punctuation" id="L672">0672
</span><span class="punctuation" id="L673">0673
</span><span class="punctuation" id="L674">0674
</span><span class="punctuation" id="L675">0675
</span><span class="punctuation" id="L676">0676
</span><span class="punctuation" id="L677">0677
</span><span class="punctuation" id="L678">0678
</span><span class="punctuation" id="L679">0679
</span><span class="punctuation" id="L680">0680
</span><span class="punctuation" id="L681">0681
</span><span class="punctuation" id="L682">0682
</span><span class="punctuation" id="L683">0683
</span><span class="punctuation" id="L684">0684
</span><span class="punctuation" id="L685">0685
</span><span class="punctuation" id="L686">0686
</span><span class="punctuation" id="L687">0687
</span><span class="punctuation" id="L688">0688
</span><span class="punctuation" id="L689">0689
</span><span class="punctuation" id="L690">0690
</span><span class="punctuation" id="L691">0691
</span><span class="punctuation" id="L692">0692
</span><span class="punctuation" id="L693">0693
</span><span class="punctuation" id="L694">0694
</span><span class="punctuation" id="L695">0695
</span><span class="punctuation" id="L696">0696
</span><span class="punctuation" id="L697">0697
</span><span class="punctuation" id="L698">0698
</span><span class="punctuation" id="L699">0699
</span><span class="punctuation" id="L700">0700
</span><span class="punctuation" id="L701">0701
</span><span class="punctuation" id="L702">0702
</span><span class="punctuation" id="L703">0703
</span><span class="punctuation" id="L704">0704
</span><span class="punctuation" id="L705">0705
</span><span class="punctuation" id="L706">0706
</span><span class="punctuation" id="L707">0707
</span><span class="punctuation" id="L708">0708
</span><span class="punctuation" id="L709">0709
</span><span class="punctuation" id="L710">0710
</span><span class="punctuation" id="L711">0711
</span><span class="punctuation" id="L712">0712
</span><span class="punctuation" id="L713">0713
</span><span class="punctuation" id="L714">0714
</span><span class="punctuation" id="L715">0715
</span><span class="punctuation" id="L716">0716
</span><span class="punctuation" id="L717">0717
</span><span class="punctuation" id="L718">0718
</span><span class="punctuation" id="L719">0719
</span><span class="punctuation" id="L720">0720
</span><span class="punctuation" id="L721">0721
</span><span class="punctuation" id="L722">0722
</span><span class="punctuation" id="L723">0723
</span><span class="punctuation" id="L724">0724
</span><span class="punctuation" id="L725">0725
</span><span class="punctuation" id="L726">0726
</span><span class="punctuation" id="L727">0727
</span><span class="punctuation" id="L728">0728
</span><span class="punctuation" id="L729">0729
</span><span class="punctuation" id="L730">0730
</span><span class="punctuation" id="L731">0731
</span><span class="punctuation" id="L732">0732
</span><span class="punctuation" id="L733">0733
</span><span class="punctuation" id="L734">0734
</span><span class="punctuation" id="L735">0735
</span><span class="punctuation" id="L736">0736
</span><span class="punctuation" id="L737">0737
</span><span class="punctuation" id="L738">0738
</span><span class="punctuation" id="L739">0739
</span><span class="punctuation" id="L740">0740
</span><span class="punctuation" id="L741">0741
</span><span class="punctuation" id="L742">0742
</span><span class="punctuation" id="L743">0743
</span><span class="punctuation" id="L744">0744
</span><span class="punctuation" id="L745">0745
</span><span class="punctuation" id="L746">0746
</span><span class="punctuation" id="L747">0747
</span><span class="punctuation" id="L748">0748
</span><span class="punctuation" id="L749">0749
</span><span class="punctuation" id="L750">0750
</span><span class="punctuation" id="L751">0751
</span><span class="punctuation" id="L752">0752
</span><span class="punctuation" id="L753">0753
</span><span class="punctuation" id="L754">0754
</span><span class="punctuation" id="L755">0755
</span><span class="punctuation" id="L756">0756
</span><span class="punctuation" id="L757">0757
</span><span class="punctuation" id="L758">0758
</span><span class="punctuation" id="L759">0759
</span><span class="punctuation" id="L760">0760
</span><span class="punctuation" id="L761">0761
</span><span class="punctuation" id="L762">0762
</span><span class="punctuation" id="L763">0763
</span><span class="punctuation" id="L764">0764
</span><span class="punctuation" id="L765">0765
</span><span class="punctuation" id="L766">0766
</span><span class="punctuation" id="L767">0767
</span><span class="punctuation" id="L768">0768
</span><span class="punctuation" id="L769">0769
</span><span class="punctuation" id="L770">0770
</span><span class="punctuation" id="L771">0771
</span><span class="punctuation" id="L772">0772
</span><span class="punctuation" id="L773">0773
</span><span class="punctuation" id="L774">0774
</span><span class="punctuation" id="L775">0775
</span><span class="punctuation" id="L776">0776
</span><span class="punctuation" id="L777">0777
</span><span class="punctuation" id="L778">0778
</span><span class="punctuation" id="L779">0779
</span><span class="punctuation" id="L780">0780
</span><span class="punctuation" id="L781">0781
</span><span class="punctuation" id="L782">0782
</span><span class="punctuation" id="L783">0783
</span><span class="punctuation" id="L784">0784
</span><span class="punctuation" id="L785">0785
</span><span class="punctuation" id="L786">0786
</span><span class="punctuation" id="L787">0787
</span><span class="punctuation" id="L788">0788
</span><span class="punctuation" id="L789">0789
</span><span class="punctuation" id="L790">0790
</span><span class="punctuation" id="L791">0791
</span><span class="punctuation" id="L792">0792
</span><span class="punctuation" id="L793">0793
</span><span class="punctuation" id="L794">0794
</span><span class="punctuation" id="L795">0795
</span><span class="punctuation" id="L796">0796
</span><span class="punctuation" id="L797">0797
</span><span class="punctuation" id="L798">0798
</span><span class="punctuation" id="L799">0799
</span><span class="punctuation" id="L800">0800
</span><span class="punctuation" id="L801">0801
</span><span class="punctuation" id="L802">0802
</span><span class="punctuation" id="L803">0803
</span><span class="punctuation" id="L804">0804
</span><span class="punctuation" id="L805">0805
</span><span class="punctuation" id="L806">0806
</span><span class="punctuation" id="L807">0807
</span><span class="punctuation" id="L808">0808
</span><span class="punctuation" id="L809">0809
</span><span class="punctuation" id="L810">0810
</span><span class="punctuation" id="L811">0811
</span><span class="punctuation" id="L812">0812
</span><span class="punctuation" id="L813">0813
</span><span class="punctuation" id="L814">0814
</span><span class="punctuation" id="L815">0815
</span><span class="punctuation" id="L816">0816
</span><span class="punctuation" id="L817">0817
</span><span class="punctuation" id="L818">0818
</span><span class="punctuation" id="L819">0819
</span><span class="punctuation" id="L820">0820
</span><span class="punctuation" id="L821">0821
</span><span class="punctuation" id="L822">0822
</span><span class="punctuation" id="L823">0823
</span><span class="punctuation" id="L824">0824
</span><span class="punctuation" id="L825">0825
</span><span class="punctuation" id="L826">0826
</span><span class="punctuation" id="L827">0827
</span><span class="punctuation" id="L828">0828
</span><span class="punctuation" id="L829">0829
</span><span class="punctuation" id="L830">0830
</span><span class="punctuation" id="L831">0831
</span><span class="punctuation" id="L832">0832
</span><span class="punctuation" id="L833">0833
</span><span class="punctuation" id="L834">0834
</span><span class="punctuation" id="L835">0835
</span><span class="punctuation" id="L836">0836
</span><span class="punctuation" id="L837">0837
</span><span class="punctuation" id="L838">0838
</span><span class="punctuation" id="L839">0839
</span><span class="punctuation" id="L840">0840
</span><span class="punctuation" id="L841">0841
</span><span class="punctuation" id="L842">0842
</span><span class="punctuation" id="L843">0843
</span><span class="punctuation" id="L844">0844
</span><span class="punctuation" id="L845">0845
</span><span class="punctuation" id="L846">0846
</span><span class="punctuation" id="L847">0847
</span><span class="punctuation" id="L848">0848
</span><span class="punctuation" id="L849">0849
</span><span class="punctuation" id="L850">0850
</span><span class="punctuation" id="L851">0851
</span><span class="punctuation" id="L852">0852
</span><span class="punctuation" id="L853">0853
</span><span class="punctuation" id="L854">0854
</span><span class="punctuation" id="L855">0855
</span><span class="punctuation" id="L856">0856
</span><span class="punctuation" id="L857">0857
</span><span class="punctuation" id="L858">0858
</span><span class="punctuation" id="L859">0859
</span><span class="punctuation" id="L860">0860
</span><span class="punctuation" id="L861">0861
</span><span class="punctuation" id="L862">0862
</span><span class="punctuation" id="L863">0863
</span><span class="punctuation" id="L864">0864
</span><span class="punctuation" id="L865">0865
</span><span class="punctuation" id="L866">0866
</span><span class="punctuation" id="L867">0867
</span><span class="punctuation" id="L868">0868
</span><span class="punctuation" id="L869">0869
</span><span class="punctuation" id="L870">0870
</span><span class="punctuation" id="L871">0871
</span><span class="punctuation" id="L872">0872
</span><span class="punctuation" id="L873">0873
</span><span class="punctuation" id="L874">0874
</span><span class="punctuation" id="L875">0875
</span><span class="punctuation" id="L876">0876
</span><span class="punctuation" id="L877">0877
</span><span class="punctuation" id="L878">0878
</span><span class="punctuation" id="L879">0879
</span><span class="punctuation" id="L880">0880
</span><span class="punctuation" id="L881">0881
</span><span class="punctuation" id="L882">0882
</span><span class="punctuation" id="L883">0883
</span><span class="punctuation" id="L884">0884
</span><span class="punctuation" id="L885">0885
</span><span class="punctuation" id="L886">0886
</span><span class="punctuation" id="L887">0887
</span><span class="punctuation" id="L888">0888
</span><span class="punctuation" id="L889">0889
</span><span class="punctuation" id="L890">0890
</span><span class="punctuation" id="L891">0891
</span><span class="punctuation" id="L892">0892
</span><span class="punctuation" id="L893">0893
</span><span class="punctuation" id="L894">0894
</span><span class="punctuation" id="L895">0895
</span><span class="punctuation" id="L896">0896
</span><span class="punctuation" id="L897">0897
</span><span class="punctuation" id="L898">0898
</span><span class="punctuation" id="L899">0899
</span><span class="punctuation" id="L900">0900
</span><span class="punctuation" id="L901">0901
</span><span class="punctuation" id="L902">0902
</span><span class="punctuation" id="L903">0903
</span><span class="punctuation" id="L904">0904
</span><span class="punctuation" id="L905">0905
</span><span class="punctuation" id="L906">0906
</span><span class="punctuation" id="L907">0907
</span><span class="punctuation" id="L908">0908
</span><span class="punctuation" id="L909">0909
</span><span class="punctuation" id="L910">0910
</span><span class="punctuation" id="L911">0911
</span><span class="punctuation" id="L912">0912
</span><span class="punctuation" id="L913">0913
</span><span class="punctuation" id="L914">0914
</span><span class="punctuation" id="L915">0915
</span><span class="punctuation" id="L916">0916
</span><span class="punctuation" id="L917">0917
</span><span class="punctuation" id="L918">0918
</span><span class="punctuation" id="L919">0919
</span><span class="punctuation" id="L920">0920
</span><span class="punctuation" id="L921">0921
</span><span class="punctuation" id="L922">0922
</span><span class="punctuation" id="L923">0923
</span><span class="punctuation" id="L924">0924
</span><span class="punctuation" id="L925">0925
</span><span class="punctuation" id="L926">0926
</span><span class="punctuation" id="L927">0927
</span><span class="punctuation" id="L928">0928
</span><span class="punctuation" id="L929">0929
</span><span class="punctuation" id="L930">0930
</span><span class="punctuation" id="L931">0931
</span><span class="punctuation" id="L932">0932
</span><span class="punctuation" id="L933">0933
</span><span class="punctuation" id="L934">0934
</span><span class="punctuation" id="L935">0935
</span><span class="punctuation" id="L936">0936
</span><span class="punctuation" id="L937">0937
</span><span class="punctuation" id="L938">0938
</span><span class="punctuation" id="L939">0939
</span><span class="punctuation" id="L940">0940
</span><span class="punctuation" id="L941">0941
</span><span class="punctuation" id="L942">0942
</span><span class="punctuation" id="L943">0943
</span><span class="punctuation" id="L944">0944
</span><span class="punctuation" id="L945">0945
</span><span class="punctuation" id="L946">0946
</span><span class="punctuation" id="L947">0947
</span><span class="punctuation" id="L948">0948
</span><span class="punctuation" id="L949">0949
</span><span class="punctuation" id="L950">0950
</span><span class="punctuation" id="L951">0951
</span><span class="punctuation" id="L952">0952
</span><span class="punctuation" id="L953">0953
</span><span class="punctuation" id="L954">0954
</span><span class="punctuation" id="L955">0955
</span><span class="punctuation" id="L956">0956
</span><span class="punctuation" id="L957">0957
</span><span class="punctuation" id="L958">0958
</span><span class="punctuation" id="L959">0959
</span><span class="punctuation" id="L960">0960
</span><span class="punctuation" id="L961">0961
</span><span class="punctuation" id="L962">0962
</span><span class="punctuation" id="L963">0963
</span><span class="punctuation" id="L964">0964
</span><span class="punctuation" id="L965">0965
</span><span class="punctuation" id="L966">0966
</span><span class="punctuation" id="L967">0967
</span><span class="punctuation" id="L968">0968
</span><span class="punctuation" id="L969">0969
</span><span class="punctuation" id="L970">0970
</span><span class="punctuation" id="L971">0971
</span><span class="punctuation" id="L972">0972
</span><span class="punctuation" id="L973">0973
</span><span class="punctuation" id="L974">0974
</span><span class="punctuation" id="L975">0975
</span><span class="punctuation" id="L976">0976
</span><span class="punctuation" id="L977">0977
</span><span class="punctuation" id="L978">0978
</span><span class="punctuation" id="L979">0979
</span><span class="punctuation" id="L980">0980
</span><span class="punctuation" id="L981">0981
</span><span class="punctuation" id="L982">0982
</span><span class="punctuation" id="L983">0983
</span><span class="punctuation" id="L984">0984
</span><span class="punctuation" id="L985">0985
</span><span class="punctuation" id="L986">0986
</span><span class="punctuation" id="L987">0987
</span><span class="punctuation" id="L988">0988
</span><span class="punctuation" id="L989">0989
</span><span class="punctuation" id="L990">0990
</span><span class="punctuation" id="L991">0991
</span><span class="punctuation" id="L992">0992
</span><span class="punctuation" id="L993">0993
</span><span class="punctuation" id="L994">0994
</span><span class="punctuation" id="L995">0995
</span><span class="punctuation" id="L996">0996
</span><span class="punctuation" id="L997">0997
</span><span class="punctuation" id="L998">0998
</span><span class="punctuation" id="L999">0999
</span><span class="punctuation" id="L1000">1000
</span><span class="punctuation" id="L1001">1001
</span><span class="punctuation" id="L1002">1002
</span><span class="punctuation" id="L1003">1003
</span><span class="punctuation" id="L1004">1004
</span><span class="punctuation" id="L1005">1005
</span><span class="punctuation" id="L1006">1006
</span><span class="punctuation" id="L1007">1007
</span><span class="punctuation" id="L1008">1008
</span><span class="punctuation" id="L1009">1009
</span><span class="punctuation" id="L1010">1010
</span><span class="punctuation" id="L1011">1011
</span><span class="punctuation" id="L1012">1012
</span><span class="punctuation" id="L1013">1013
</span><span class="punctuation" id="L1014">1014
</span><span class="punctuation" id="L1015">1015
</span><span class="punctuation" id="L1016">1016
</span><span class="punctuation" id="L1017">1017
</span><span class="punctuation" id="L1018">1018
</span><span class="punctuation" id="L1019">1019
</span><span class="punctuation" id="L1020">1020
</span><span class="punctuation" id="L1021">1021
</span><span class="punctuation" id="L1022">1022
</span><span class="punctuation" id="L1023">1023
</span><span class="punctuation" id="L1024">1024
</span><span class="punctuation" id="L1025">1025
</span><span class="punctuation" id="L1026">1026
</span><span class="punctuation" id="L1027">1027
</span><span class="punctuation" id="L1028">1028
</span><span class="punctuation" id="L1029">1029
</span><span class="punctuation" id="L1030">1030
</span><span class="punctuation" id="L1031">1031
</span><span class="punctuation" id="L1032">1032
</span><span class="punctuation" id="L1033">1033
</span><span class="punctuation" id="L1034">1034
</span><span class="punctuation" id="L1035">1035
</span><span class="punctuation" id="L1036">1036
</span><span class="punctuation" id="L1037">1037
</span><span class="punctuation" id="L1038">1038
</span><span class="punctuation" id="L1039">1039
</span><span class="punctuation" id="L1040">1040
</span><span class="punctuation" id="L1041">1041
</span><span class="punctuation" id="L1042">1042
</span><span class="punctuation" id="L1043">1043
</span><span class="punctuation" id="L1044">1044
</span><span class="punctuation" id="L1045">1045
</span><span class="punctuation" id="L1046">1046
</span><span class="punctuation" id="L1047">1047
</span><span class="punctuation" id="L1048">1048
</span><span class="punctuation" id="L1049">1049
</span><span class="punctuation" id="L1050">1050
</span><span class="punctuation" id="L1051">1051
</span><span class="punctuation" id="L1052">1052
</span><span class="punctuation" id="L1053">1053
</span><span class="punctuation" id="L1054">1054
</span><span class="punctuation" id="L1055">1055
</span><span class="punctuation" id="L1056">1056
</span><span class="punctuation" id="L1057">1057
</span><span class="punctuation" id="L1058">1058
</span><span class="punctuation" id="L1059">1059
</span><span class="punctuation" id="L1060">1060
</span><span class="punctuation" id="L1061">1061
</span><span class="punctuation" id="L1062">1062
</span><span class="punctuation" id="L1063">1063
</span><span class="punctuation" id="L1064">1064
</span><span class="punctuation" id="L1065">1065
</span><span class="punctuation" id="L1066">1066
</span><span class="punctuation" id="L1067">1067
</span><span class="punctuation" id="L1068">1068
</span><span class="punctuation" id="L1069">1069
</span><span class="punctuation" id="L1070">1070
</span><span class="punctuation" id="L1071">1071
</span><span class="punctuation" id="L1072">1072
</span><span class="punctuation" id="L1073">1073
</span><span class="punctuation" id="L1074">1074
</span><span class="punctuation" id="L1075">1075
</span><span class="punctuation" id="L1076">1076
</span><span class="punctuation" id="L1077">1077
</span><span class="punctuation" id="L1078">1078
</span><span class="punctuation" id="L1079">1079
</span><span class="punctuation" id="L1080">1080
</span><span class="punctuation" id="L1081">1081
</span><span class="punctuation" id="L1082">1082
</span><span class="punctuation" id="L1083">1083
</span><span class="punctuation" id="L1084">1084
</span><span class="punctuation" id="L1085">1085
</span><span class="punctuation" id="L1086">1086
</span><span class="punctuation" id="L1087">1087
</span><span class="punctuation" id="L1088">1088
</span><span class="punctuation" id="L1089">1089
</span><span class="punctuation" id="L1090">1090
</span><span class="punctuation" id="L1091">1091
</span><span class="punctuation" id="L1092">1092
</span><span class="punctuation" id="L1093">1093
</span><span class="punctuation" id="L1094">1094
</span><span class="punctuation" id="L1095">1095
</span><span class="punctuation" id="L1096">1096
</span><span class="punctuation" id="L1097">1097
</span><span class="punctuation" id="L1098">1098
</span><span class="punctuation" id="L1099">1099
</span><span class="punctuation" id="L1100">1100
</span><span class="punctuation" id="L1101">1101
</span><span class="punctuation" id="L1102">1102
</span><span class="punctuation" id="L1103">1103
</span><span class="punctuation" id="L1104">1104
</span><span class="punctuation" id="L1105">1105
</span><span class="punctuation" id="L1106">1106
</span><span class="punctuation" id="L1107">1107
</span><span class="punctuation" id="L1108">1108
</span><span class="punctuation" id="L1109">1109
</span><span class="punctuation" id="L1110">1110
</span><span class="punctuation" id="L1111">1111
</span><span class="punctuation" id="L1112">1112
</span><span class="punctuation" id="L1113">1113
</span><span class="punctuation" id="L1114">1114
</span><span class="punctuation" id="L1115">1115
</span><span class="punctuation" id="L1116">1116
</span><span class="punctuation" id="L1117">1117
</span><span class="punctuation" id="L1118">1118
</span><span class="punctuation" id="L1119">1119
</span><span class="punctuation" id="L1120">1120
</span><span class="punctuation" id="L1121">1121
</span><span class="punctuation" id="L1122">1122
</span><span class="punctuation" id="L1123">1123
</span><span class="punctuation" id="L1124">1124
</span><span class="punctuation" id="L1125">1125
</span><span class="punctuation" id="L1126">1126
</span><span class="punctuation" id="L1127">1127
</span><span class="punctuation" id="L1128">1128
</span><span class="punctuation" id="L1129">1129
</span><span class="punctuation" id="L1130">1130
</span><span class="punctuation" id="L1131">1131
</span><span class="punctuation" id="L1132">1132
</span><span class="punctuation" id="L1133">1133
</span><span class="punctuation" id="L1134">1134
</span><span class="punctuation" id="L1135">1135
</span><span class="punctuation" id="L1136">1136
</span><span class="punctuation" id="L1137">1137
</span><span class="punctuation" id="L1138">1138
</span><span class="punctuation" id="L1139">1139
</span><span class="punctuation" id="L1140">1140
</span><span class="punctuation" id="L1141">1141
</span><span class="punctuation" id="L1142">1142
</span><span class="punctuation" id="L1143">1143
</span><span class="punctuation" id="L1144">1144
</span><span class="punctuation" id="L1145">1145
</span><span class="punctuation" id="L1146">1146
</span><span class="punctuation" id="L1147">1147
</span><span class="punctuation" id="L1148">1148
</span><span class="punctuation" id="L1149">1149
</span><span class="punctuation" id="L1150">1150
</span><span class="punctuation" id="L1151">1151
</span><span class="punctuation" id="L1152">1152
</span><span class="punctuation" id="L1153">1153
</span><span class="punctuation" id="L1154">1154
</span><span class="punctuation" id="L1155">1155
</span><span class="punctuation" id="L1156">1156
</span><span class="punctuation" id="L1157">1157
</span><span class="punctuation" id="L1158">1158
</span><span class="punctuation" id="L1159">1159
</span><span class="punctuation" id="L1160">1160
</span><span class="punctuation" id="L1161">1161
</span><span class="punctuation" id="L1162">1162
</span><span class="punctuation" id="L1163">1163
</span><span class="punctuation" id="L1164">1164
</span><span class="punctuation" id="L1165">1165
</span><span class="punctuation" id="L1166">1166
</span><span class="punctuation" id="L1167">1167
</span><span class="punctuation" id="L1168">1168
</span><span class="punctuation" id="L1169">1169
</span><span class="punctuation" id="L1170">1170
</span><span class="punctuation" id="L1171">1171
</span><span class="punctuation" id="L1172">1172
</span><span class="punctuation" id="L1173">1173
</span><span class="punctuation" id="L1174">1174
</span><span class="punctuation" id="L1175">1175
</span><span class="punctuation" id="L1176">1176
</span><span class="punctuation" id="L1177">1177
</span><span class="punctuation" id="L1178">1178
</span><span class="punctuation" id="L1179">1179
</span><span class="punctuation" id="L1180">1180
</span><span class="punctuation" id="L1181">1181
</span><span class="punctuation" id="L1182">1182
</span><span class="punctuation" id="L1183">1183
</span><span class="punctuation" id="L1184">1184
</span><span class="punctuation" id="L1185">1185
</span><span class="punctuation" id="L1186">1186
</span><span class="punctuation" id="L1187">1187
</span><span class="punctuation" id="L1188">1188
</span><span class="punctuation" id="L1189">1189
</span><span class="punctuation" id="L1190">1190
</span><span class="punctuation" id="L1191">1191
</span><span class="punctuation" id="L1192">1192
</span><span class="punctuation" id="L1193">1193
</span><span class="punctuation" id="L1194">1194
</span><span class="punctuation" id="L1195">1195
</span><span class="punctuation" id="L1196">1196
</span><span class="punctuation" id="L1197">1197
</span><span class="punctuation" id="L1198">1198
</span><span class="punctuation" id="L1199">1199
</span><span class="punctuation" id="L1200">1200
</span><span class="punctuation" id="L1201">1201
</span><span class="punctuation" id="L1202">1202
</span><span class="punctuation" id="L1203">1203
</span><span class="punctuation" id="L1204">1204
</span><span class="punctuation" id="L1205">1205
</span><span class="punctuation" id="L1206">1206
</span><span class="punctuation" id="L1207">1207
</span><span class="punctuation" id="L1208">1208
</span><span class="punctuation" id="L1209">1209
</span><span class="punctuation" id="L1210">1210
</span><span class="punctuation" id="L1211">1211
</span><span class="punctuation" id="L1212">1212
</span><span class="punctuation" id="L1213">1213
</span><span class="punctuation" id="L1214">1214
</span><span class="punctuation" id="L1215">1215
</span><span class="punctuation" id="L1216">1216
</span><span class="punctuation" id="L1217">1217
</span><span class="punctuation" id="L1218">1218
</span><span class="punctuation" id="L1219">1219
</span><span class="punctuation" id="L1220">1220
</span><span class="punctuation" id="L1221">1221
</span><span class="punctuation" id="L1222">1222
</span><span class="punctuation" id="L1223">1223
</span><span class="punctuation" id="L1224">1224
</span><span class="punctuation" id="L1225">1225
</span><span class="punctuation" id="L1226">1226
</span><span class="punctuation" id="L1227">1227
</span><span class="punctuation" id="L1228">1228
</span><span class="punctuation" id="L1229">1229
</span><span class="punctuation" id="L1230">1230
</span><span class="punctuation" id="L1231">1231
</span><span class="punctuation" id="L1232">1232
</span><span class="punctuation" id="L1233">1233
</span><span class="punctuation" id="L1234">1234
</span><span class="punctuation" id="L1235">1235
</span><span class="punctuation" id="L1236">1236
</span><span class="punctuation" id="L1237">1237
</span><span class="punctuation" id="L1238">1238
</span><span class="punctuation" id="L1239">1239
</span><span class="punctuation" id="L1240">1240
</span><span class="punctuation" id="L1241">1241
</span><span class="punctuation" id="L1242">1242
</span><span class="punctuation" id="L1243">1243
</span><span class="punctuation" id="L1244">1244
</span><span class="punctuation" id="L1245">1245
</span><span class="punctuation" id="L1246">1246
</span><span class="punctuation" id="L1247">1247
</span><span class="punctuation" id="L1248">1248
</span><span class="punctuation" id="L1249">1249
</span><span class="punctuation" id="L1250">1250
</span><span class="punctuation" id="L1251">1251
</span><span class="punctuation" id="L1252">1252
</span><span class="punctuation" id="L1253">1253
</span><span class="punctuation" id="L1254">1254
</span><span class="punctuation" id="L1255">1255
</span><span class="punctuation" id="L1256">1256
</span><span class="punctuation" id="L1257">1257
</span><span class="punctuation" id="L1258">1258
</span><span class="punctuation" id="L1259">1259
</span><span class="punctuation" id="L1260">1260
</span><span class="punctuation" id="L1261">1261
</span><span class="punctuation" id="L1262">1262
</span><span class="punctuation" id="L1263">1263
</span><span class="punctuation" id="L1264">1264
</span><span class="punctuation" id="L1265">1265
</span><span class="punctuation" id="L1266">1266
</span><span class="punctuation" id="L1267">1267
</span><span class="punctuation" id="L1268">1268
</span><span class="punctuation" id="L1269">1269
</span><span class="punctuation" id="L1270">1270
</span><span class="punctuation" id="L1271">1271
</span><span class="punctuation" id="L1272">1272
</span><span class="punctuation" id="L1273">1273
</span><span class="punctuation" id="L1274">1274
</span><span class="punctuation" id="L1275">1275
</span><span class="punctuation" id="L1276">1276
</span><span class="punctuation" id="L1277">1277
</span><span class="punctuation" id="L1278">1278
</span><span class="punctuation" id="L1279">1279
</span><span class="punctuation" id="L1280">1280
</span><span class="punctuation" id="L1281">1281
</span><span class="punctuation" id="L1282">1282
</span><span class="punctuation" id="L1283">1283
</span><span class="punctuation" id="L1284">1284
</span><span class="punctuation" id="L1285">1285
</span><span class="punctuation" id="L1286">1286
</span><span class="punctuation" id="L1287">1287
</span><span class="punctuation" id="L1288">1288
</span><span class="punctuation" id="L1289">1289
</span><span class="punctuation" id="L1290">1290
</span><span class="punctuation" id="L1291">1291
</span><span class="punctuation" id="L1292">1292
</span><span class="punctuation" id="L1293">1293
</span><span class="punctuation" id="L1294">1294
</span><span class="punctuation" id="L1295">1295
</span><span class="punctuation" id="L1296">1296
</span><span class="punctuation" id="L1297">1297
</span><span class="punctuation" id="L1298">1298
</span><span class="punctuation" id="L1299">1299
</span><span class="punctuation" id="L1300">1300
</span><span class="punctuation" id="L1301">1301
</span><span class="punctuation" id="L1302">1302
</span><span class="punctuation" id="L1303">1303
</span><span class="punctuation" id="L1304">1304
</span><span class="punctuation" id="L1305">1305
</span><span class="punctuation" id="L1306">1306
</span><span class="punctuation" id="L1307">1307
</span><span class="punctuation" id="L1308">1308
</span><span class="punctuation" id="L1309">1309
</span><span class="punctuation" id="L1310">1310
</span><span class="punctuation" id="L1311">1311
</span><span class="punctuation" id="L1312">1312
</span><span class="punctuation" id="L1313">1313
</span><span class="punctuation" id="L1314">1314
</span><span class="punctuation" id="L1315">1315
</span><span class="punctuation" id="L1316">1316
</span><span class="punctuation" id="L1317">1317
</span><span class="punctuation" id="L1318">1318
</span><span class="punctuation" id="L1319">1319
</span><span class="punctuation" id="L1320">1320
</span><span class="punctuation" id="L1321">1321
</span><span class="punctuation" id="L1322">1322
</span><span class="punctuation" id="L1323">1323
</span><span class="punctuation" id="L1324">1324
</span><span class="punctuation" id="L1325">1325
</span><span class="punctuation" id="L1326">1326
</span><span class="punctuation" id="L1327">1327
</span><span class="punctuation" id="L1328">1328
</span><span class="punctuation" id="L1329">1329
</span><span class="punctuation" id="L1330">1330
</span><span class="punctuation" id="L1331">1331
</span><span class="punctuation" id="L1332">1332
</span><span class="punctuation" id="L1333">1333
</span><span class="punctuation" id="L1334">1334
</span><span class="punctuation" id="L1335">1335
</span><span class="punctuation" id="L1336">1336
</span><span class="punctuation" id="L1337">1337
</span><span class="punctuation" id="L1338">1338
</span><span class="punctuation" id="L1339">1339
</span><span class="punctuation" id="L1340">1340
</span><span class="punctuation" id="L1341">1341
</span><span class="punctuation" id="L1342">1342
</span><span class="punctuation" id="L1343">1343
</span><span class="punctuation" id="L1344">1344
</span><span class="punctuation" id="L1345">1345
</span><span class="punctuation" id="L1346">1346
</span><span class="punctuation" id="L1347">1347
</span><span class="punctuation" id="L1348">1348
</span><span class="punctuation" id="L1349">1349
</span><span class="punctuation" id="L1350">1350
</span><span class="punctuation" id="L1351">1351
</span><span class="punctuation" id="L1352">1352
</span><span class="punctuation" id="L1353">1353
</span><span class="punctuation" id="L1354">1354
</span><span class="punctuation" id="L1355">1355
</span><span class="punctuation" id="L1356">1356
</span><span class="punctuation" id="L1357">1357
</span><span class="punctuation" id="L1358">1358
</span><span class="punctuation" id="L1359">1359
</span><span class="punctuation" id="L1360">1360
</span><span class="punctuation" id="L1361">1361
</span><span class="punctuation" id="L1362">1362
</span><span class="punctuation" id="L1363">1363
</span><span class="punctuation" id="L1364">1364
</span><span class="punctuation" id="L1365">1365
</span><span class="punctuation" id="L1366">1366
</span><span class="punctuation" id="L1367">1367
</span><span class="punctuation" id="L1368">1368
</span><span class="punctuation" id="L1369">1369
</span><span class="punctuation" id="L1370">1370
</span><span class="punctuation" id="L1371">1371
</span><span class="punctuation" id="L1372">1372
</span><span class="punctuation" id="L1373">1373
</span><span class="punctuation" id="L1374">1374
</span><span class="punctuation" id="L1375">1375
</span><span class="punctuation" id="L1376">1376
</span><span class="punctuation" id="L1377">1377
</span><span class="punctuation" id="L1378">1378
</span><span class="punctuation" id="L1379">1379
</span><span class="punctuation" id="L1380">1380
</span><span class="punctuation" id="L1381">1381
</span><span class="punctuation" id="L1382">1382
</span><span class="punctuation" id="L1383">1383
</span><span class="punctuation" id="L1384">1384
</span><span class="punctuation" id="L1385">1385
</span><span class="punctuation" id="L1386">1386
</span><span class="punctuation" id="L1387">1387
</span><span class="punctuation" id="L1388">1388
</span><span class="punctuation" id="L1389">1389
</span><span class="punctuation" id="L1390">1390
</span><span class="punctuation" id="L1391">1391
</span><span class="punctuation" id="L1392">1392
</span><span class="punctuation" id="L1393">1393
</span><span class="punctuation" id="L1394">1394
</span><span class="punctuation" id="L1395">1395
</span><span class="punctuation" id="L1396">1396
</span><span class="punctuation" id="L1397">1397
</span><span class="punctuation" id="L1398">1398
</span><span class="punctuation" id="L1399">1399
</span><span class="punctuation" id="L1400">1400
</span><span class="punctuation" id="L1401">1401
</span><span class="punctuation" id="L1402">1402
</span><span class="punctuation" id="L1403">1403
</span><span class="punctuation" id="L1404">1404
</span><span class="punctuation" id="L1405">1405
</span><span class="punctuation" id="L1406">1406
</span><span class="punctuation" id="L1407">1407
</span><span class="punctuation" id="L1408">1408
</span><span class="punctuation" id="L1409">1409
</span><span class="punctuation" id="L1410">1410
</span><span class="punctuation" id="L1411">1411
</span><span class="punctuation" id="L1412">1412
</span><span class="punctuation" id="L1413">1413
</span><span class="punctuation" id="L1414">1414
</span><span class="punctuation" id="L1415">1415
</span><span class="punctuation" id="L1416">1416
</span><span class="punctuation" id="L1417">1417
</span><span class="punctuation" id="L1418">1418
</span><span class="punctuation" id="L1419">1419
</span><span class="punctuation" id="L1420">1420
</span><span class="punctuation" id="L1421">1421
</span><span class="punctuation" id="L1422">1422
</span><span class="punctuation" id="L1423">1423
</span><span class="punctuation" id="L1424">1424
</span><span class="punctuation" id="L1425">1425
</span><span class="punctuation" id="L1426">1426
</span><span class="punctuation" id="L1427">1427
</span><span class="punctuation" id="L1428">1428
</span><span class="punctuation" id="L1429">1429
</span><span class="punctuation" id="L1430">1430
</span><span class="punctuation" id="L1431">1431
</span><span class="punctuation" id="L1432">1432
</span><span class="punctuation" id="L1433">1433
</span><span class="punctuation" id="L1434">1434
</span><span class="punctuation" id="L1435">1435
</span><span class="punctuation" id="L1436">1436
</span><span class="punctuation" id="L1437">1437
</span><span class="punctuation" id="L1438">1438
</span><span class="punctuation" id="L1439">1439
</span><span class="punctuation" id="L1440">1440
</span><span class="punctuation" id="L1441">1441
</span><span class="punctuation" id="L1442">1442
</span><span class="punctuation" id="L1443">1443
</span><span class="punctuation" id="L1444">1444
</span><span class="punctuation" id="L1445">1445
</span><span class="punctuation" id="L1446">1446
</span><span class="punctuation" id="L1447">1447
</span><span class="punctuation" id="L1448">1448
</span><span class="punctuation" id="L1449">1449
</span><span class="punctuation" id="L1450">1450
</span><span class="punctuation" id="L1451">1451
</span><span class="punctuation" id="L1452">1452
</span><span class="punctuation" id="L1453">1453
</span><span class="punctuation" id="L1454">1454
</span><span class="punctuation" id="L1455">1455
</span><span class="punctuation" id="L1456">1456
</span><span class="punctuation" id="L1457">1457
</span><span class="punctuation" id="L1458">1458
</span><span class="punctuation" id="L1459">1459
</span><span class="punctuation" id="L1460">1460
</span><span class="punctuation" id="L1461">1461
</span><span class="punctuation" id="L1462">1462
</span><span class="punctuation" id="L1463">1463
</span><span class="punctuation" id="L1464">1464
</span><span class="punctuation" id="L1465">1465
</span><span class="punctuation" id="L1466">1466
</span><span class="punctuation" id="L1467">1467
</span><span class="punctuation" id="L1468">1468
</span><span class="punctuation" id="L1469">1469
</span><span class="punctuation" id="L1470">1470
</span><span class="punctuation" id="L1471">1471
</span><span class="punctuation" id="L1472">1472
</span><span class="punctuation" id="L1473">1473
</span><span class="punctuation" id="L1474">1474
</span><span class="punctuation" id="L1475">1475
</span><span class="punctuation" id="L1476">1476
</span><span class="punctuation" id="L1477">1477
</span><span class="punctuation" id="L1478">1478
</span><span class="punctuation" id="L1479">1479
</span><span class="punctuation" id="L1480">1480
</span><span class="punctuation" id="L1481">1481
</span><span class="punctuation" id="L1482">1482
</span><span class="punctuation" id="L1483">1483
</span><span class="punctuation" id="L1484">1484
</span><span class="punctuation" id="L1485">1485
</span><span class="punctuation" id="L1486">1486
</span><span class="punctuation" id="L1487">1487
</span><span class="punctuation" id="L1488">1488
</span><span class="punctuation" id="L1489">1489
</span><span class="punctuation" id="L1490">1490
</span><span class="punctuation" id="L1491">1491
</span><span class="punctuation" id="L1492">1492
</span><span class="punctuation" id="L1493">1493
</span><span class="punctuation" id="L1494">1494
</span><span class="punctuation" id="L1495">1495
</span><span class="punctuation" id="L1496">1496
</span><span class="punctuation" id="L1497">1497
</span><span class="punctuation" id="L1498">1498
</span><span class="punctuation" id="L1499">1499
</span><span class="punctuation" id="L1500">1500
</span><span class="punctuation" id="L1501">1501
</span><span class="punctuation" id="L1502">1502
</span><span class="punctuation" id="L1503">1503
</span><span class="punctuation" id="L1504">1504
</span><span class="punctuation" id="L1505">1505
</span><span class="punctuation" id="L1506">1506
</span><span class="punctuation" id="L1507">1507
</span><span class="punctuation" id="L1508">1508
</span><span class="punctuation" id="L1509">1509
</span><span class="punctuation" id="L1510">1510
</span><span class="punctuation" id="L1511">1511
</span><span class="punctuation" id="L1512">1512
</span><span class="punctuation" id="L1513">1513
</span><span class="punctuation" id="L1514">1514
</span><span class="punctuation" id="L1515">1515
</span><span class="punctuation" id="L1516">1516
</span><span class="punctuation" id="L1517">1517
</span><span class="punctuation" id="L1518">1518
</span><span class="punctuation" id="L1519">1519
</span><span class="punctuation" id="L1520">1520
</span><span class="punctuation" id="L1521">1521
</span><span class="punctuation" id="L1522">1522
</span><span class="punctuation" id="L1523">1523
</span><span class="punctuation" id="L1524">1524
</span><span class="punctuation" id="L1525">1525
</span><span class="punctuation" id="L1526">1526
</span><span class="punctuation" id="L1527">1527
</span><span class="punctuation" id="L1528">1528
</span><span class="punctuation" id="L1529">1529
</span><span class="punctuation" id="L1530">1530
</span><span class="punctuation" id="L1531">1531
</span><span class="punctuation" id="L1532">1532
</span><span class="punctuation" id="L1533">1533
</span><span class="punctuation" id="L1534">1534
</span><span class="punctuation" id="L1535">1535
</span><span class="punctuation" id="L1536">1536
</span><span class="punctuation" id="L1537">1537
</span><span class="punctuation" id="L1538">1538
</span><span class="punctuation" id="L1539">1539
</span><span class="punctuation" id="L1540">1540
</span><span class="punctuation" id="L1541">1541
</span><span class="punctuation" id="L1542">1542
</span><span class="punctuation" id="L1543">1543
</span><span class="punctuation" id="L1544">1544
</span><span class="punctuation" id="L1545">1545
</span><span class="punctuation" id="L1546">1546
</span><span class="punctuation" id="L1547">1547
</span><span class="punctuation" id="L1548">1548
</span><span class="punctuation" id="L1549">1549
</span><span class="punctuation" id="L1550">1550
</span><span class="punctuation" id="L1551">1551
</span><span class="punctuation" id="L1552">1552
</span><span class="punctuation" id="L1553">1553
</span><span class="punctuation" id="L1554">1554
</span><span class="punctuation" id="L1555">1555
</span><span class="punctuation" id="L1556">1556
</span><span class="punctuation" id="L1557">1557
</span><span class="punctuation" id="L1558">1558
</span><span class="punctuation" id="L1559">1559
</span><span class="punctuation" id="L1560">1560
</span><span class="punctuation" id="L1561">1561
</span><span class="punctuation" id="L1562">1562
</span><span class="punctuation" id="L1563">1563
</span><span class="punctuation" id="L1564">1564
</span><span class="punctuation" id="L1565">1565
</span><span class="punctuation" id="L1566">1566
</span><span class="punctuation" id="L1567">1567
</span><span class="punctuation" id="L1568">1568
</span><span class="punctuation" id="L1569">1569
</span><span class="punctuation" id="L1570">1570
</span><span class="punctuation" id="L1571">1571
</span><span class="punctuation" id="L1572">1572
</span><span class="punctuation" id="L1573">1573
</span><span class="punctuation" id="L1574">1574
</span><span class="punctuation" id="L1575">1575
</span><span class="punctuation" id="L1576">1576
</span><span class="punctuation" id="L1577">1577
</span><span class="punctuation" id="L1578">1578
</span><span class="punctuation" id="L1579">1579
</span><span class="punctuation" id="L1580">1580
</span><span class="punctuation" id="L1581">1581
</span><span class="punctuation" id="L1582">1582
</span><span class="punctuation" id="L1583">1583
</span><span class="punctuation" id="L1584">1584
</span><span class="punctuation" id="L1585">1585
</span><span class="punctuation" id="L1586">1586
</span><span class="punctuation" id="L1587">1587
</span><span class="punctuation" id="L1588">1588
</span><span class="punctuation" id="L1589">1589
</span><span class="punctuation" id="L1590">1590
</span><span class="punctuation" id="L1591">1591
</span><span class="punctuation" id="L1592">1592
</span><span class="punctuation" id="L1593">1593
</span><span class="punctuation" id="L1594">1594
</span><span class="punctuation" id="L1595">1595
</span><span class="punctuation" id="L1596">1596
</span><span class="punctuation" id="L1597">1597
</span><span class="punctuation" id="L1598">1598
</span><span class="punctuation" id="L1599">1599
</span><span class="punctuation" id="L1600">1600
</span><span class="punctuation" id="L1601">1601
</span><span class="punctuation" id="L1602">1602
</span><span class="punctuation" id="L1603">1603
</span><span class="punctuation" id="L1604">1604
</span><span class="punctuation" id="L1605">1605
</span><span class="punctuation" id="L1606">1606
</span><span class="punctuation" id="L1607">1607
</span><span class="punctuation" id="L1608">1608
</span><span class="punctuation" id="L1609">1609
</span><span class="punctuation" id="L1610">1610
</span><span class="punctuation" id="L1611">1611
</span><span class="punctuation" id="L1612">1612
</span><span class="punctuation" id="L1613">1613
</span><span class="punctuation" id="L1614">1614
</span><span class="punctuation" id="L1615">1615
</span><span class="punctuation" id="L1616">1616
</span><span class="punctuation" id="L1617">1617
</span><span class="punctuation" id="L1618">1618
</span><span class="punctuation" id="L1619">1619
</span><span class="punctuation" id="L1620">1620
</span><span class="punctuation" id="L1621">1621
</span><span class="punctuation" id="L1622">1622
</span><span class="punctuation" id="L1623">1623
</span><span class="punctuation" id="L1624">1624
</span><span class="punctuation" id="L1625">1625
</span><span class="punctuation" id="L1626">1626
</span><span class="punctuation" id="L1627">1627
</span><span class="punctuation" id="L1628">1628
</span><span class="punctuation" id="L1629">1629
</span><span class="punctuation" id="L1630">1630
</span><span class="punctuation" id="L1631">1631
</span><span class="punctuation" id="L1632">1632
</span><span class="punctuation" id="L1633">1633
</span><span class="punctuation" id="L1634">1634
</span><span class="punctuation" id="L1635">1635
</span><span class="punctuation" id="L1636">1636
</span><span class="punctuation" id="L1637">1637
</span><span class="punctuation" id="L1638">1638
</span><span class="punctuation" id="L1639">1639
</span><span class="punctuation" id="L1640">1640
</span><span class="punctuation" id="L1641">1641
</span><span class="punctuation" id="L1642">1642
</span><span class="punctuation" id="L1643">1643
</span><span class="punctuation" id="L1644">1644
</span><span class="punctuation" id="L1645">1645
</span><span class="punctuation" id="L1646">1646
</span><span class="punctuation" id="L1647">1647
</span><span class="punctuation" id="L1648">1648
</span><span class="punctuation" id="L1649">1649
</span><span class="punctuation" id="L1650">1650
</span><span class="punctuation" id="L1651">1651
</span><span class="punctuation" id="L1652">1652
</span><span class="punctuation" id="L1653">1653
</span><span class="punctuation" id="L1654">1654
</span><span class="punctuation" id="L1655">1655
</span><span class="punctuation" id="L1656">1656
</span><span class="punctuation" id="L1657">1657
</span><span class="punctuation" id="L1658">1658
</span><span class="punctuation" id="L1659">1659
</span><span class="punctuation" id="L1660">1660
</span><span class="punctuation" id="L1661">1661
</span><span class="punctuation" id="L1662">1662
</span><span class="punctuation" id="L1663">1663
</span><span class="punctuation" id="L1664">1664
</span><span class="punctuation" id="L1665">1665
</span><span class="punctuation" id="L1666">1666
</span><span class="punctuation" id="L1667">1667
</span><span class="punctuation" id="L1668">1668
</span><span class="punctuation" id="L1669">1669
</span><span class="punctuation" id="L1670">1670
</span><span class="punctuation" id="L1671">1671
</span><span class="punctuation" id="L1672">1672
</span><span class="punctuation" id="L1673">1673
</span><span class="punctuation" id="L1674">1674
</span><span class="punctuation" id="L1675">1675
</span><span class="punctuation" id="L1676">1676
</span><span class="punctuation" id="L1677">1677
</span><span class="punctuation" id="L1678">1678
</span><span class="punctuation" id="L1679">1679
</span><span class="punctuation" id="L1680">1680
</span><span class="punctuation" id="L1681">1681
</span><span class="punctuation" id="L1682">1682
</span><span class="punctuation" id="L1683">1683
</span><span class="punctuation" id="L1684">1684
</span><span class="punctuation" id="L1685">1685
</span><span class="punctuation" id="L1686">1686
</span><span class="punctuation" id="L1687">1687
</span><span class="punctuation" id="L1688">1688
</span><span class="punctuation" id="L1689">1689
</span><span class="punctuation" id="L1690">1690
</span><span class="punctuation" id="L1691">1691
</span><span class="punctuation" id="L1692">1692
</span><span class="punctuation" id="L1693">1693
</span><span class="punctuation" id="L1694">1694
</span><span class="punctuation" id="L1695">1695
</span><span class="punctuation" id="L1696">1696
</span><span class="punctuation" id="L1697">1697
</span><span class="punctuation" id="L1698">1698
</span><span class="punctuation" id="L1699">1699
</span><span class="punctuation" id="L1700">1700
</span><span class="punctuation" id="L1701">1701
</span><span class="punctuation" id="L1702">1702
</span><span class="punctuation" id="L1703">1703
</span><span class="punctuation" id="L1704">1704
</span><span class="punctuation" id="L1705">1705
</span><span class="punctuation" id="L1706">1706
</span><span class="punctuation" id="L1707">1707
</span><span class="punctuation" id="L1708">1708
</span><span class="punctuation" id="L1709">1709
</span><span class="punctuation" id="L1710">1710
</span><span class="punctuation" id="L1711">1711
</span><span class="punctuation" id="L1712">1712
</span><span class="punctuation" id="L1713">1713
</span><span class="punctuation" id="L1714">1714
</span><span class="punctuation" id="L1715">1715
</span><span class="punctuation" id="L1716">1716
</span><span class="punctuation" id="L1717">1717
</span><span class="punctuation" id="L1718">1718
</span><span class="punctuation" id="L1719">1719
</span><span class="punctuation" id="L1720">1720
</span><span class="punctuation" id="L1721">1721
</span><span class="punctuation" id="L1722">1722
</span><span class="punctuation" id="L1723">1723
</span><span class="punctuation" id="L1724">1724
</span><span class="punctuation" id="L1725">1725
</span><span class="punctuation" id="L1726">1726
</span><span class="punctuation" id="L1727">1727
</span><span class="punctuation" id="L1728">1728
</span><span class="punctuation" id="L1729">1729
</span><span class="punctuation" id="L1730">1730
</span><span class="punctuation" id="L1731">1731
</span><span class="punctuation" id="L1732">1732
</span><span class="punctuation" id="L1733">1733
</span><span class="punctuation" id="L1734">1734
</span><span class="punctuation" id="L1735">1735
</span><span class="punctuation" id="L1736">1736
</span><span class="punctuation" id="L1737">1737
</span><span class="punctuation" id="L1738">1738
</span><span class="punctuation" id="L1739">1739
</span><span class="punctuation" id="L1740">1740
</span><span class="punctuation" id="L1741">1741
</span><span class="punctuation" id="L1742">1742
</span><span class="punctuation" id="L1743">1743
</span><span class="punctuation" id="L1744">1744
</span><span class="punctuation" id="L1745">1745
</span><span class="punctuation" id="L1746">1746
</span><span class="punctuation" id="L1747">1747
</span><span class="punctuation" id="L1748">1748
</span><span class="punctuation" id="L1749">1749
</span><span class="punctuation" id="L1750">1750
</span><span class="punctuation" id="L1751">1751
</span><span class="punctuation" id="L1752">1752
</span><span class="punctuation" id="L1753">1753
</span><span class="punctuation" id="L1754">1754
</span><span class="punctuation" id="L1755">1755
</span><span class="punctuation" id="L1756">1756
</span><span class="punctuation" id="L1757">1757
</span><span class="punctuation" id="L1758">1758
</span><span class="punctuation" id="L1759">1759
</span><span class="punctuation" id="L1760">1760
</span><span class="punctuation" id="L1761">1761
</span><span class="punctuation" id="L1762">1762
</span><span class="punctuation" id="L1763">1763
</span><span class="punctuation" id="L1764">1764
</span><span class="punctuation" id="L1765">1765
</span><span class="punctuation" id="L1766">1766
</span><span class="punctuation" id="L1767">1767
</span><span class="punctuation" id="L1768">1768
</span><span class="punctuation" id="L1769">1769
</span><span class="punctuation" id="L1770">1770
</span><span class="punctuation" id="L1771">1771
</span><span class="punctuation" id="L1772">1772
</span><span class="punctuation" id="L1773">1773
</span><span class="punctuation" id="L1774">1774
</span><span class="punctuation" id="L1775">1775
</span><span class="punctuation" id="L1776">1776
</span><span class="punctuation" id="L1777">1777
</span><span class="punctuation" id="L1778">1778
</span><span class="punctuation" id="L1779">1779
</span><span class="punctuation" id="L1780">1780
</span><span class="punctuation" id="L1781">1781
</span><span class="punctuation" id="L1782">1782
</span><span class="punctuation" id="L1783">1783
</span><span class="punctuation" id="L1784">1784
</span><span class="punctuation" id="L1785">1785
</span><span class="punctuation" id="L1786">1786
</span><span class="punctuation" id="L1787">1787
</span><span class="punctuation" id="L1788">1788
</span><span class="punctuation" id="L1789">1789
</span><span class="punctuation" id="L1790">1790
</span><span class="punctuation" id="L1791">1791
</span><span class="punctuation" id="L1792">1792
</span><span class="punctuation" id="L1793">1793
</span><span class="punctuation" id="L1794">1794
</span><span class="punctuation" id="L1795">1795
</span><span class="punctuation" id="L1796">1796
</span><span class="punctuation" id="L1797">1797
</span><span class="punctuation" id="L1798">1798
</span><span class="punctuation" id="L1799">1799
</span><span class="punctuation" id="L1800">1800
</span><span class="punctuation" id="L1801">1801
</span><span class="punctuation" id="L1802">1802
</span><span class="punctuation" id="L1803">1803
</span><span class="punctuation" id="L1804">1804
</span><span class="punctuation" id="L1805">1805
</span><span class="punctuation" id="L1806">1806
</span><span class="punctuation" id="L1807">1807
</span><span class="punctuation" id="L1808">1808
</span><span class="punctuation" id="L1809">1809
</span><span class="punctuation" id="L1810">1810
</span><span class="punctuation" id="L1811">1811
</span><span class="punctuation" id="L1812">1812
</span><span class="punctuation" id="L1813">1813
</span><span class="punctuation" id="L1814">1814
</span><span class="punctuation" id="L1815">1815
</span><span class="punctuation" id="L1816">1816
</span><span class="punctuation" id="L1817">1817
</span><span class="punctuation" id="L1818">1818
</span><span class="punctuation" id="L1819">1819
</span><span class="punctuation" id="L1820">1820
</span><span class="punctuation" id="L1821">1821
</span><span class="punctuation" id="L1822">1822
</span><span class="punctuation" id="L1823">1823
</span><span class="punctuation" id="L1824">1824
</span><span class="punctuation" id="L1825">1825
</span><span class="punctuation" id="L1826">1826
</span><span class="punctuation" id="L1827">1827
</span><span class="punctuation" id="L1828">1828
</span><span class="punctuation" id="L1829">1829
</span><span class="punctuation" id="L1830">1830
</span><span class="punctuation" id="L1831">1831
</span><span class="punctuation" id="L1832">1832
</span><span class="punctuation" id="L1833">1833
</span><span class="punctuation" id="L1834">1834
</span><span class="punctuation" id="L1835">1835
</span><span class="punctuation" id="L1836">1836
</span><span class="punctuation" id="L1837">1837
</span><span class="punctuation" id="L1838">1838
</span><span class="punctuation" id="L1839">1839
</span><span class="punctuation" id="L1840">1840
</span><span class="punctuation" id="L1841">1841
</span><span class="punctuation" id="L1842">1842
</span><span class="punctuation" id="L1843">1843
</span><span class="punctuation" id="L1844">1844
</span><span class="punctuation" id="L1845">1845
</span><span class="punctuation" id="L1846">1846
</span><span class="punctuation" id="L1847">1847
</span><span class="punctuation" id="L1848">1848
</span><span class="punctuation" id="L1849">1849
</span><span class="punctuation" id="L1850">1850
</span><span class="punctuation" id="L1851">1851
</span><span class="punctuation" id="L1852">1852
</span><span class="punctuation" id="L1853">1853
</span><span class="punctuation" id="L1854">1854
</span><span class="punctuation" id="L1855">1855
</span><span class="punctuation" id="L1856">1856
</span><span class="punctuation" id="L1857">1857
</span><span class="punctuation" id="L1858">1858
</span><span class="punctuation" id="L1859">1859
</span><span class="punctuation" id="L1860">1860
</span><span class="punctuation" id="L1861">1861
</span><span class="punctuation" id="L1862">1862
</span><span class="punctuation" id="L1863">1863
</span><span class="punctuation" id="L1864">1864
</span><span class="punctuation" id="L1865">1865
</span><span class="punctuation" id="L1866">1866
</span><span class="punctuation" id="L1867">1867
</span><span class="punctuation" id="L1868">1868
</span><span class="punctuation" id="L1869">1869
</span><span class="punctuation" id="L1870">1870
</span><span class="punctuation" id="L1871">1871
</span><span class="punctuation" id="L1872">1872
</span><span class="punctuation" id="L1873">1873
</span><span class="punctuation" id="L1874">1874
</span><span class="punctuation" id="L1875">1875
</span><span class="punctuation" id="L1876">1876
</span><span class="punctuation" id="L1877">1877
</span><span class="punctuation" id="L1878">1878
</span><span class="punctuation" id="L1879">1879
</span><span class="punctuation" id="L1880">1880
</span><span class="punctuation" id="L1881">1881
</span><span class="punctuation" id="L1882">1882
</span><span class="punctuation" id="L1883">1883
</span><span class="punctuation" id="L1884">1884
</span><span class="punctuation" id="L1885">1885
</span><span class="punctuation" id="L1886">1886
</span><span class="punctuation" id="L1887">1887
</span><span class="punctuation" id="L1888">1888
</span><span class="punctuation" id="L1889">1889
</span><span class="punctuation" id="L1890">1890
</span><span class="punctuation" id="L1891">1891
</span><span class="punctuation" id="L1892">1892
</span><span class="punctuation" id="L1893">1893
</span><span class="punctuation" id="L1894">1894
</span><span class="punctuation" id="L1895">1895
</span><span class="punctuation" id="L1896">1896
</span><span class="punctuation" id="L1897">1897
</span><span class="punctuation" id="L1898">1898
</span><span class="punctuation" id="L1899">1899
</span><span class="punctuation" id="L1900">1900
</span><span class="punctuation" id="L1901">1901
</span><span class="punctuation" id="L1902">1902
</span><span class="punctuation" id="L1903">1903
</span><span class="punctuation" id="L1904">1904
</span><span class="punctuation" id="L1905">1905
</span><span class="punctuation" id="L1906">1906
</span><span class="punctuation" id="L1907">1907
</span><span class="punctuation" id="L1908">1908
</span><span class="punctuation" id="L1909">1909
</span><span class="punctuation" id="L1910">1910
</span><span class="punctuation" id="L1911">1911
</span><span class="punctuation" id="L1912">1912
</span><span class="punctuation" id="L1913">1913
</span><span class="punctuation" id="L1914">1914
</span><span class="punctuation" id="L1915">1915
</span><span class="punctuation" id="L1916">1916
</span><span class="punctuation" id="L1917">1917
</span><span class="punctuation" id="L1918">1918
</span><span class="punctuation" id="L1919">1919
</span><span class="punctuation" id="L1920">1920
</span><span class="punctuation" id="L1921">1921
</span><span class="punctuation" id="L1922">1922
</span><span class="punctuation" id="L1923">1923
</span><span class="punctuation" id="L1924">1924
</span><span class="punctuation" id="L1925">1925
</span><span class="punctuation" id="L1926">1926
</span><span class="punctuation" id="L1927">1927
</span><span class="punctuation" id="L1928">1928
</span><span class="punctuation" id="L1929">1929
</span><span class="punctuation" id="L1930">1930
</span><span class="punctuation" id="L1931">1931
</span><span class="punctuation" id="L1932">1932
</span><span class="punctuation" id="L1933">1933
</span><span class="punctuation" id="L1934">1934
</span><span class="punctuation" id="L1935">1935
</span><span class="punctuation" id="L1936">1936
</span><span class="punctuation" id="L1937">1937
</span><span class="punctuation" id="L1938">1938
</span><span class="punctuation" id="L1939">1939
</span><span class="punctuation" id="L1940">1940
</span><span class="punctuation" id="L1941">1941
</span><span class="punctuation" id="L1942">1942
</span><span class="punctuation" id="L1943">1943
</span><span class="punctuation" id="L1944">1944
</span><span class="punctuation" id="L1945">1945
</span><span class="punctuation" id="L1946">1946
</span><span class="punctuation" id="L1947">1947
</span><span class="punctuation" id="L1948">1948
</span><span class="punctuation" id="L1949">1949
</span><span class="punctuation" id="L1950">1950
</span><span class="punctuation" id="L1951">1951
</span><span class="punctuation" id="L1952">1952
</span><span class="punctuation" id="L1953">1953
</span><span class="punctuation" id="L1954">1954
</span><span class="punctuation" id="L1955">1955
</span><span class="punctuation" id="L1956">1956
</span><span class="punctuation" id="L1957">1957
</span><span class="punctuation" id="L1958">1958
</span><span class="punctuation" id="L1959">1959
</span><span class="punctuation" id="L1960">1960
</span><span class="punctuation" id="L1961">1961
</span><span class="punctuation" id="L1962">1962
</span><span class="punctuation" id="L1963">1963
</span><span class="punctuation" id="L1964">1964
</span><span class="punctuation" id="L1965">1965
</span><span class="punctuation" id="L1966">1966
</span><span class="punctuation" id="L1967">1967
</span><span class="punctuation" id="L1968">1968
</span><span class="punctuation" id="L1969">1969
</span><span class="punctuation" id="L1970">1970
</span><span class="punctuation" id="L1971">1971
</span><span class="punctuation" id="L1972">1972
</span><span class="punctuation" id="L1973">1973
</span><span class="punctuation" id="L1974">1974
</span><span class="punctuation" id="L1975">1975
</span><span class="punctuation" id="L1976">1976
</span><span class="punctuation" id="L1977">1977
</span><span class="punctuation" id="L1978">1978
</span><span class="punctuation" id="L1979">1979
</span><span class="punctuation" id="L1980">1980
</span><span class="punctuation" id="L1981">1981
</span><span class="punctuation" id="L1982">1982
</span><span class="punctuation" id="L1983">1983
</span><span class="punctuation" id="L1984">1984
</span><span class="punctuation" id="L1985">1985
</span><span class="punctuation" id="L1986">1986
</span><span class="punctuation" id="L1987">1987
</span><span class="punctuation" id="L1988">1988
</span><span class="punctuation" id="L1989">1989
</span><span class="punctuation" id="L1990">1990
</span><span class="punctuation" id="L1991">1991
</span><span class="punctuation" id="L1992">1992
</span><span class="punctuation" id="L1993">1993
</span><span class="punctuation" id="L1994">1994
</span><span class="punctuation" id="L1995">1995
</span><span class="punctuation" id="L1996">1996
</span><span class="punctuation" id="L1997">1997
</span><span class="punctuation" id="L1998">1998
</span><span class="punctuation" id="L1999">1999
</span><span class="punctuation" id="L2000">2000
</span><span class="punctuation" id="L2001">2001
</span><span class="punctuation" id="L2002">2002
</span><span class="punctuation" id="L2003">2003
</span><span class="punctuation" id="L2004">2004
</span><span class="punctuation" id="L2005">2005
</span><span class="punctuation" id="L2006">2006
</span><span class="punctuation" id="L2007">2007
</span><span class="punctuation" id="L2008">2008
</span><span class="punctuation" id="L2009">2009
</span><span class="punctuation" id="L2010">2010
</span><span class="punctuation" id="L2011">2011
</span><span class="punctuation" id="L2012">2012
</span><span class="punctuation" id="L2013">2013
</span><span class="punctuation" id="L2014">2014
</span><span class="punctuation" id="L2015">2015
</span><span class="punctuation" id="L2016">2016
</span><span class="punctuation" id="L2017">2017
</span><span class="punctuation" id="L2018">2018
</span><span class="punctuation" id="L2019">2019
</span><span class="punctuation" id="L2020">2020
</span><span class="punctuation" id="L2021">2021
</span><span class="punctuation" id="L2022">2022
</span><span class="punctuation" id="L2023">2023
</span><span class="punctuation" id="L2024">2024
</span><span class="punctuation" id="L2025">2025
</span><span class="punctuation" id="L2026">2026
</span><span class="punctuation" id="L2027">2027
</span><span class="punctuation" id="L2028">2028
</span><span class="punctuation" id="L2029">2029
</span><span class="punctuation" id="L2030">2030
</span><span class="punctuation" id="L2031">2031
</span><span class="punctuation" id="L2032">2032
</span><span class="punctuation" id="L2033">2033
</span><span class="punctuation" id="L2034">2034
</span><span class="punctuation" id="L2035">2035
</span><span class="punctuation" id="L2036">2036
</span><span class="punctuation" id="L2037">2037
</span><span class="punctuation" id="L2038">2038
</span><span class="punctuation" id="L2039">2039
</span><span class="punctuation" id="L2040">2040
</span><span class="punctuation" id="L2041">2041
</span><span class="punctuation" id="L2042">2042
</span><span class="punctuation" id="L2043">2043
</span><span class="punctuation" id="L2044">2044
</span><span class="punctuation" id="L2045">2045
</span><span class="punctuation" id="L2046">2046
</span><span class="punctuation" id="L2047">2047
</span><span class="punctuation" id="L2048">2048
</span><span class="punctuation" id="L2049">2049
</span><span class="punctuation" id="L2050">2050
</span><span class="punctuation" id="L2051">2051
</span><span class="punctuation" id="L2052">2052
</span><span class="punctuation" id="L2053">2053
</span><span class="punctuation" id="L2054">2054
</span><span class="punctuation" id="L2055">2055
</span><span class="punctuation" id="L2056">2056
</span><span class="punctuation" id="L2057">2057
</span><span class="punctuation" id="L2058">2058
</span><span class="punctuation" id="L2059">2059
</span><span class="punctuation" id="L2060">2060
</span><span class="punctuation" id="L2061">2061
</span><span class="punctuation" id="L2062">2062
</span><span class="punctuation" id="L2063">2063
</span><span class="punctuation" id="L2064">2064
</span><span class="punctuation" id="L2065">2065
</span><span class="punctuation" id="L2066">2066
</span><span class="punctuation" id="L2067">2067
</span><span class="punctuation" id="L2068">2068
</span><span class="punctuation" id="L2069">2069
</span><span class="punctuation" id="L2070">2070
</span><span class="punctuation" id="L2071">2071
</span><span class="punctuation" id="L2072">2072
</span><span class="punctuation" id="L2073">2073
</span><span class="punctuation" id="L2074">2074
</span><span class="punctuation" id="L2075">2075
</span><span class="punctuation" id="L2076">2076
</span><span class="punctuation" id="L2077">2077
</span><span class="punctuation" id="L2078">2078
</span><span class="punctuation" id="L2079">2079
</span><span class="punctuation" id="L2080">2080
</span><span class="punctuation" id="L2081">2081
</span><span class="punctuation" id="L2082">2082
</span><span class="punctuation" id="L2083">2083
</span><span class="punctuation" id="L2084">2084
</span><span class="punctuation" id="L2085">2085
</span><span class="punctuation" id="L2086">2086
</span><span class="punctuation" id="L2087">2087
</span><span class="punctuation" id="L2088">2088
</span><span class="punctuation" id="L2089">2089
</span><span class="punctuation" id="L2090">2090
</span><span class="punctuation" id="L2091">2091
</span><span class="punctuation" id="L2092">2092
</span><span class="punctuation" id="L2093">2093
</span><span class="punctuation" id="L2094">2094
</span><span class="punctuation" id="L2095">2095
</span><span class="punctuation" id="L2096">2096
</span><span class="punctuation" id="L2097">2097
</span><span class="punctuation" id="L2098">2098
</span><span class="punctuation" id="L2099">2099
</span><span class="punctuation" id="L2100">2100
</span><span class="punctuation" id="L2101">2101
</span><span class="punctuation" id="L2102">2102
</span><span class="punctuation" id="L2103">2103
</span><span class="punctuation" id="L2104">2104
</span><span class="punctuation" id="L2105">2105
</span><span class="punctuation" id="L2106">2106
</span><span class="punctuation" id="L2107">2107
</span><span class="punctuation" id="L2108">2108
</span><span class="punctuation" id="L2109">2109
</span><span class="punctuation" id="L2110">2110
</span><span class="punctuation" id="L2111">2111
</span><span class="punctuation" id="L2112">2112
</span><span class="punctuation" id="L2113">2113
</span><span class="punctuation" id="L2114">2114
</span><span class="punctuation" id="L2115">2115
</span><span class="punctuation" id="L2116">2116
</span><span class="punctuation" id="L2117">2117
</span><span class="punctuation" id="L2118">2118
</span><span class="punctuation" id="L2119">2119
</span><span class="punctuation" id="L2120">2120
</span><span class="punctuation" id="L2121">2121
</span><span class="punctuation" id="L2122">2122
</span><span class="punctuation" id="L2123">2123
</span><span class="punctuation" id="L2124">2124
</span><span class="punctuation" id="L2125">2125
</span><span class="punctuation" id="L2126">2126
</span><span class="punctuation" id="L2127">2127
</span><span class="punctuation" id="L2128">2128
</span><span class="punctuation" id="L2129">2129
</span><span class="punctuation" id="L2130">2130
</span><span class="punctuation" id="L2131">2131
</span><span class="punctuation" id="L2132">2132
</span><span class="punctuation" id="L2133">2133
</span><span class="punctuation" id="L2134">2134
</span><span class="punctuation" id="L2135">2135
</span><span class="punctuation" id="L2136">2136
</span><span class="punctuation" id="L2137">2137
</span><span class="punctuation" id="L2138">2138
</span><span class="punctuation" id="L2139">2139
</span><span class="punctuation" id="L2140">2140
</span><span class="punctuation" id="L2141">2141
</span><span class="punctuation" id="L2142">2142
</span><span class="punctuation" id="L2143">2143
</span><span class="punctuation" id="L2144">2144
</span><span class="punctuation" id="L2145">2145
</span><span class="punctuation" id="L2146">2146
</span><span class="punctuation" id="L2147">2147
</span><span class="punctuation" id="L2148">2148
</span><span class="punctuation" id="L2149">2149
</span><span class="punctuation" id="L2150">2150
</span><span class="punctuation" id="L2151">2151
</span><span class="punctuation" id="L2152">2152
</span><span class="punctuation" id="L2153">2153
</span><span class="punctuation" id="L2154">2154
</span><span class="punctuation" id="L2155">2155
</span><span class="punctuation" id="L2156">2156
</span><span class="punctuation" id="L2157">2157
</span><span class="punctuation" id="L2158">2158
</span><span class="punctuation" id="L2159">2159
</span><span class="punctuation" id="L2160">2160
</span><span class="punctuation" id="L2161">2161
</span><span class="punctuation" id="L2162">2162
</span><span class="punctuation" id="L2163">2163
</span><span class="punctuation" id="L2164">2164
</span><span class="punctuation" id="L2165">2165
</span><span class="punctuation" id="L2166">2166
</span><span class="punctuation" id="L2167">2167
</span><span class="punctuation" id="L2168">2168
</span><span class="punctuation" id="L2169">2169
</span><span class="punctuation" id="L2170">2170
</span><span class="punctuation" id="L2171">2171
</span><span class="punctuation" id="L2172">2172
</span><span class="punctuation" id="L2173">2173
</span><span class="punctuation" id="L2174">2174
</span><span class="punctuation" id="L2175">2175
</span><span class="punctuation" id="L2176">2176
</span><span class="punctuation" id="L2177">2177
</span><span class="punctuation" id="L2178">2178
</span><span class="punctuation" id="L2179">2179
</span><span class="punctuation" id="L2180">2180
</span><span class="punctuation" id="L2181">2181
</span><span class="punctuation" id="L2182">2182
</span><span class="punctuation" id="L2183">2183
</span><span class="punctuation" id="L2184">2184
</span><span class="punctuation" id="L2185">2185
</span><span class="punctuation" id="L2186">2186
</span><span class="punctuation" id="L2187">2187
</span><span class="punctuation" id="L2188">2188
</span><span class="punctuation" id="L2189">2189
</span><span class="punctuation" id="L2190">2190
</span><span class="punctuation" id="L2191">2191
</span><span class="punctuation" id="L2192">2192
</span><span class="punctuation" id="L2193">2193
</span><span class="punctuation" id="L2194">2194
</span><span class="punctuation" id="L2195">2195
</span><span class="punctuation" id="L2196">2196
</span><span class="punctuation" id="L2197">2197
</span><span class="punctuation" id="L2198">2198
</span><span class="punctuation" id="L2199">2199
</span><span class="punctuation" id="L2200">2200
</span><span class="punctuation" id="L2201">2201
</span><span class="punctuation" id="L2202">2202
</span><span class="punctuation" id="L2203">2203
</span><span class="punctuation" id="L2204">2204
</span><span class="punctuation" id="L2205">2205
</span><span class="punctuation" id="L2206">2206
</span><span class="punctuation" id="L2207">2207
</span><span class="punctuation" id="L2208">2208
</span><span class="punctuation" id="L2209">2209
</span><span class="punctuation" id="L2210">2210
</span><span class="punctuation" id="L2211">2211
</span><span class="punctuation" id="L2212">2212
</span><span class="punctuation" id="L2213">2213
</span><span class="punctuation" id="L2214">2214
</span><span class="punctuation" id="L2215">2215
</span><span class="punctuation" id="L2216">2216
</span><span class="punctuation" id="L2217">2217
</span><span class="punctuation" id="L2218">2218
</span><span class="punctuation" id="L2219">2219
</span><span class="punctuation" id="L2220">2220
</span><span class="punctuation" id="L2221">2221
</span><span class="punctuation" id="L2222">2222
</span><span class="punctuation" id="L2223">2223
</span><span class="punctuation" id="L2224">2224
</span><span class="punctuation" id="L2225">2225
</span><span class="punctuation" id="L2226">2226
</span><span class="punctuation" id="L2227">2227
</span><span class="punctuation" id="L2228">2228
</span><span class="punctuation" id="L2229">2229
</span><span class="punctuation" id="L2230">2230
</span><span class="punctuation" id="L2231">2231
</span><span class="punctuation" id="L2232">2232
</span><span class="punctuation" id="L2233">2233
</span><span class="punctuation" id="L2234">2234
</span><span class="punctuation" id="L2235">2235
</span><span class="punctuation" id="L2236">2236
</span><span class="punctuation" id="L2237">2237
</span><span class="punctuation" id="L2238">2238
</span><span class="punctuation" id="L2239">2239
</span><span class="punctuation" id="L2240">2240
</span><span class="punctuation" id="L2241">2241
</span><span class="punctuation" id="L2242">2242
</span><span class="punctuation" id="L2243">2243
</span><span class="punctuation" id="L2244">2244
</span><span class="punctuation" id="L2245">2245
</span><span class="punctuation" id="L2246">2246
</span><span class="punctuation" id="L2247">2247
</span><span class="punctuation" id="L2248">2248
</span><span class="punctuation" id="L2249">2249
</span><span class="punctuation" id="L2250">2250
</span><span class="punctuation" id="L2251">2251
</span><span class="punctuation" id="L2252">2252
</span><span class="punctuation" id="L2253">2253
</span><span class="punctuation" id="L2254">2254
</span><span class="punctuation" id="L2255">2255
</span><span class="punctuation" id="L2256">2256
</span><span class="punctuation" id="L2257">2257
</span><span class="punctuation" id="L2258">2258
</span><span class="punctuation" id="L2259">2259
</span><span class="punctuation" id="L2260">2260
</span><span class="punctuation" id="L2261">2261
</span><span class="punctuation" id="L2262">2262
</span><span class="punctuation" id="L2263">2263
</span><span class="punctuation" id="L2264">2264
</span><span class="punctuation" id="L2265">2265
</span><span class="punctuation" id="L2266">2266
</span><span class="punctuation" id="L2267">2267
</span><span class="punctuation" id="L2268">2268
</span><span class="punctuation" id="L2269">2269
</span><span class="punctuation" id="L2270">2270
</span><span class="punctuation" id="L2271">2271
</span><span class="punctuation" id="L2272">2272
</span><span class="punctuation" id="L2273">2273
</span><span class="punctuation" id="L2274">2274
</span><span class="punctuation" id="L2275">2275
</span><span class="punctuation" id="L2276">2276
</span><span class="punctuation" id="L2277">2277
</span><span class="punctuation" id="L2278">2278
</span><span class="punctuation" id="L2279">2279
</span><span class="punctuation" id="L2280">2280
</span><span class="punctuation" id="L2281">2281
</span><span class="punctuation" id="L2282">2282
</span><span class="punctuation" id="L2283">2283
</span><span class="punctuation" id="L2284">2284
</span><span class="punctuation" id="L2285">2285
</span><span class="punctuation" id="L2286">2286
</span><span class="punctuation" id="L2287">2287
</span><span class="punctuation" id="L2288">2288
</span><span class="punctuation" id="L2289">2289
</span><span class="punctuation" id="L2290">2290
</span><span class="punctuation" id="L2291">2291
</span><span class="punctuation" id="L2292">2292
</span><span class="punctuation" id="L2293">2293
</span><span class="punctuation" id="L2294">2294
</span><span class="punctuation" id="L2295">2295
</span><span class="punctuation" id="L2296">2296
</span><span class="punctuation" id="L2297">2297
</span><span class="punctuation" id="L2298">2298
</span><span class="punctuation" id="L2299">2299
</span><span class="punctuation" id="L2300">2300
</span><span class="punctuation" id="L2301">2301
</span><span class="punctuation" id="L2302">2302
</span><span class="punctuation" id="L2303">2303
</span><span class="punctuation" id="L2304">2304
</span><span class="punctuation" id="L2305">2305
</span><span class="punctuation" id="L2306">2306
</span><span class="punctuation" id="L2307">2307
</span><span class="punctuation" id="L2308">2308
</span><span class="punctuation" id="L2309">2309
</span><span class="punctuation" id="L2310">2310
</span><span class="punctuation" id="L2311">2311
</span><span class="punctuation" id="L2312">2312
</span><span class="punctuation" id="L2313">2313
</span><span class="punctuation" id="L2314">2314
</span><span class="punctuation" id="L2315">2315
</span><span class="punctuation" id="L2316">2316
</span><span class="punctuation" id="L2317">2317
</span><span class="punctuation" id="L2318">2318
</span><span class="punctuation" id="L2319">2319
</span><span class="punctuation" id="L2320">2320
</span><span class="punctuation" id="L2321">2321
</span><span class="punctuation" id="L2322">2322
</span><span class="punctuation" id="L2323">2323
</span><span class="punctuation" id="L2324">2324
</span><span class="punctuation" id="L2325">2325
</span><span class="punctuation" id="L2326">2326
</span><span class="punctuation" id="L2327">2327
</span><span class="punctuation" id="L2328">2328
</span><span class="punctuation" id="L2329">2329
</span><span class="punctuation" id="L2330">2330
</span><span class="punctuation" id="L2331">2331
</span><span class="punctuation" id="L2332">2332
</span><span class="punctuation" id="L2333">2333
</span><span class="punctuation" id="L2334">2334
</span><span class="punctuation" id="L2335">2335
</span><span class="punctuation" id="L2336">2336
</span><span class="punctuation" id="L2337">2337
</span><span class="punctuation" id="L2338">2338
</span><span class="punctuation" id="L2339">2339
</span><span class="punctuation" id="L2340">2340
</span><span class="punctuation" id="L2341">2341
</span><span class="punctuation" id="L2342">2342
</span><span class="punctuation" id="L2343">2343
</span><span class="punctuation" id="L2344">2344
</span><span class="punctuation" id="L2345">2345
</span><span class="punctuation" id="L2346">2346
</span><span class="punctuation" id="L2347">2347
</span><span class="punctuation" id="L2348">2348
</span><span class="punctuation" id="L2349">2349
</span><span class="punctuation" id="L2350">2350
</span><span class="punctuation" id="L2351">2351
</span><span class="punctuation" id="L2352">2352
</span><span class="punctuation" id="L2353">2353
</span><span class="punctuation" id="L2354">2354
</span><span class="punctuation" id="L2355">2355
</span><span class="punctuation" id="L2356">2356
</span><span class="punctuation" id="L2357">2357
</span><span class="punctuation" id="L2358">2358
</span><span class="punctuation" id="L2359">2359
</span><span class="punctuation" id="L2360">2360
</span><span class="punctuation" id="L2361">2361
</span><span class="punctuation" id="L2362">2362
</span><span class="punctuation" id="L2363">2363
</span><span class="punctuation" id="L2364">2364
</span><span class="punctuation" id="L2365">2365
</span><span class="punctuation" id="L2366">2366
</span><span class="punctuation" id="L2367">2367
</span><span class="punctuation" id="L2368">2368
</span><span class="punctuation" id="L2369">2369
</span><span class="punctuation" id="L2370">2370
</span><span class="punctuation" id="L2371">2371
</span><span class="punctuation" id="L2372">2372
</span><span class="punctuation" id="L2373">2373
</span><span class="punctuation" id="L2374">2374
</span><span class="punctuation" id="L2375">2375
</span><span class="punctuation" id="L2376">2376
</span><span class="punctuation" id="L2377">2377
</span><span class="punctuation" id="L2378">2378
</span><span class="punctuation" id="L2379">2379
</span><span class="punctuation" id="L2380">2380
</span><span class="punctuation" id="L2381">2381
</span><span class="punctuation" id="L2382">2382
</span><span class="punctuation" id="L2383">2383
</span><span class="punctuation" id="L2384">2384
</span><span class="punctuation" id="L2385">2385
</span><span class="punctuation" id="L2386">2386
</span><span class="punctuation" id="L2387">2387
</span><span class="punctuation" id="L2388">2388
</span><span class="punctuation" id="L2389">2389
</span><span class="punctuation" id="L2390">2390
</span><span class="punctuation" id="L2391">2391
</span><span class="punctuation" id="L2392">2392
</span><span class="punctuation" id="L2393">2393
</span><span class="punctuation" id="L2394">2394
</span><span class="punctuation" id="L2395">2395
</span><span class="punctuation" id="L2396">2396
</span><span class="punctuation" id="L2397">2397
</span><span class="punctuation" id="L2398">2398
</span><span class="punctuation" id="L2399">2399
</span><span class="punctuation" id="L2400">2400
</span><span class="punctuation" id="L2401">2401
</span><span class="punctuation" id="L2402">2402
</span><span class="punctuation" id="L2403">2403
</span><span class="punctuation" id="L2404">2404
</span><span class="punctuation" id="L2405">2405
</span><span class="punctuation" id="L2406">2406
</span><span class="punctuation" id="L2407">2407
</span><span class="punctuation" id="L2408">2408
</span><span class="punctuation" id="L2409">2409
</span><span class="punctuation" id="L2410">2410
</span><span class="punctuation" id="L2411">2411
</span><span class="punctuation" id="L2412">2412
</span><span class="punctuation" id="L2413">2413
</span><span class="punctuation" id="L2414">2414
</span><span class="punctuation" id="L2415">2415
</span><span class="punctuation" id="L2416">2416
</span><span class="punctuation" id="L2417">2417
</span><span class="punctuation" id="L2418">2418
</span><span class="punctuation" id="L2419">2419
</span><span class="punctuation" id="L2420">2420
</span><span class="punctuation" id="L2421">2421
</span><span class="punctuation" id="L2422">2422
</span><span class="punctuation" id="L2423">2423
</span><span class="punctuation" id="L2424">2424
</span><span class="punctuation" id="L2425">2425
</span><span class="punctuation" id="L2426">2426
</span><span class="punctuation" id="L2427">2427
</span><span class="punctuation" id="L2428">2428
</span><span class="punctuation" id="L2429">2429
</span><span class="punctuation" id="L2430">2430
</span><span class="punctuation" id="L2431">2431
</span><span class="punctuation" id="L2432">2432
</span><span class="punctuation" id="L2433">2433
</span><span class="punctuation" id="L2434">2434
</span><span class="punctuation" id="L2435">2435
</span><span class="punctuation" id="L2436">2436
</span><span class="punctuation" id="L2437">2437
</span><span class="punctuation" id="L2438">2438
</span><span class="punctuation" id="L2439">2439
</span><span class="punctuation" id="L2440">2440
</span><span class="punctuation" id="L2441">2441
</span><span class="punctuation" id="L2442">2442
</span><span class="punctuation" id="L2443">2443
</span><span class="punctuation" id="L2444">2444
</span><span class="punctuation" id="L2445">2445
</span><span class="punctuation" id="L2446">2446
</span><span class="punctuation" id="L2447">2447
</span><span class="punctuation" id="L2448">2448
</span><span class="punctuation" id="L2449">2449
</span><span class="punctuation" id="L2450">2450
</span><span class="punctuation" id="L2451">2451
</span><span class="punctuation" id="L2452">2452
</span><span class="punctuation" id="L2453">2453
</span><span class="punctuation" id="L2454">2454
</span><span class="punctuation" id="L2455">2455
</span><span class="punctuation" id="L2456">2456
</span><span class="punctuation" id="L2457">2457
</span><span class="punctuation" id="L2458">2458
</span><span class="punctuation" id="L2459">2459
</span><span class="punctuation" id="L2460">2460
</span><span class="punctuation" id="L2461">2461
</span><span class="punctuation" id="L2462">2462
</span><span class="punctuation" id="L2463">2463
</span><span class="punctuation" id="L2464">2464
</span><span class="punctuation" id="L2465">2465
</span><span class="punctuation" id="L2466">2466
</span><span class="punctuation" id="L2467">2467
</span><span class="punctuation" id="L2468">2468
</span><span class="punctuation" id="L2469">2469
</span><span class="punctuation" id="L2470">2470
</span><span class="punctuation" id="L2471">2471
</span><span class="punctuation" id="L2472">2472
</span><span class="punctuation" id="L2473">2473
</span><span class="punctuation" id="L2474">2474
</span><span class="punctuation" id="L2475">2475
</span><span class="punctuation" id="L2476">2476
</span><span class="punctuation" id="L2477">2477
</span><span class="punctuation" id="L2478">2478
</span><span class="punctuation" id="L2479">2479
</span><span class="punctuation" id="L2480">2480
</span><span class="punctuation" id="L2481">2481
</span><span class="punctuation" id="L2482">2482
</span><span class="punctuation" id="L2483">2483
</span><span class="punctuation" id="L2484">2484
</span><span class="punctuation" id="L2485">2485
</span><span class="punctuation" id="L2486">2486
</span><span class="punctuation" id="L2487">2487
</span><span class="punctuation" id="L2488">2488
</span><span class="punctuation" id="L2489">2489
</span><span class="punctuation" id="L2490">2490
</span><span class="punctuation" id="L2491">2491
</span><span class="punctuation" id="L2492">2492
</span><span class="punctuation" id="L2493">2493
</span><span class="punctuation" id="L2494">2494
</span><span class="punctuation" id="L2495">2495
</span><span class="punctuation" id="L2496">2496
</span><span class="punctuation" id="L2497">2497
</span><span class="punctuation" id="L2498">2498
</span><span class="punctuation" id="L2499">2499
</span><span class="punctuation" id="L2500">2500
</span><span class="punctuation" id="L2501">2501
</span><span class="punctuation" id="L2502">2502
</span><span class="punctuation" id="L2503">2503
</span><span class="punctuation" id="L2504">2504
</span><span class="punctuation" id="L2505">2505
</span><span class="punctuation" id="L2506">2506
</span><span class="punctuation" id="L2507">2507
</span><span class="punctuation" id="L2508">2508
</span><span class="punctuation" id="L2509">2509
</span><span class="punctuation" id="L2510">2510
</span><span class="punctuation" id="L2511">2511
</span><span class="punctuation" id="L2512">2512
</span><span class="punctuation" id="L2513">2513
</span><span class="punctuation" id="L2514">2514
</span><span class="punctuation" id="L2515">2515
</span><span class="punctuation" id="L2516">2516
</span><span class="punctuation" id="L2517">2517
</span><span class="punctuation" id="L2518">2518
</span><span class="punctuation" id="L2519">2519
</span><span class="punctuation" id="L2520">2520
</span><span class="punctuation" id="L2521">2521
</span><span class="punctuation" id="L2522">2522
</span><span class="punctuation" id="L2523">2523
</span><span class="punctuation" id="L2524">2524
</span><span class="punctuation" id="L2525">2525
</span><span class="punctuation" id="L2526">2526
</span><span class="punctuation" id="L2527">2527
</span><span class="punctuation" id="L2528">2528
</span><span class="punctuation" id="L2529">2529
</span><span class="punctuation" id="L2530">2530
</span><span class="punctuation" id="L2531">2531
</span><span class="punctuation" id="L2532">2532
</span><span class="punctuation" id="L2533">2533
</span><span class="punctuation" id="L2534">2534
</span><span class="punctuation" id="L2535">2535
</span><span class="punctuation" id="L2536">2536
</span><span class="punctuation" id="L2537">2537
</span><span class="punctuation" id="L2538">2538
</span><span class="punctuation" id="L2539">2539
</span><span class="punctuation" id="L2540">2540
</span><span class="punctuation" id="L2541">2541
</span><span class="punctuation" id="L2542">2542
</span><span class="punctuation" id="L2543">2543
</span><span class="punctuation" id="L2544">2544
</span><span class="punctuation" id="L2545">2545
</span><span class="punctuation" id="L2546">2546
</span><span class="punctuation" id="L2547">2547
</span><span class="punctuation" id="L2548">2548
</span><span class="punctuation" id="L2549">2549
</span><span class="punctuation" id="L2550">2550
</span><span class="punctuation" id="L2551">2551
</span><span class="punctuation" id="L2552">2552
</span><span class="punctuation" id="L2553">2553
</span><span class="punctuation" id="L2554">2554
</span><span class="punctuation" id="L2555">2555
</span><span class="punctuation" id="L2556">2556
</span><span class="punctuation" id="L2557">2557
</span><span class="punctuation" id="L2558">2558
</span><span class="punctuation" id="L2559">2559
</span><span class="punctuation" id="L2560">2560
</span><span class="punctuation" id="L2561">2561
</span><span class="punctuation" id="L2562">2562
</span><span class="punctuation" id="L2563">2563
</span><span class="punctuation" id="L2564">2564
</span><span class="punctuation" id="L2565">2565
</span><span class="punctuation" id="L2566">2566
</span><span class="punctuation" id="L2567">2567
</span><span class="punctuation" id="L2568">2568
</span><span class="punctuation" id="L2569">2569
</span><span class="punctuation" id="L2570">2570
</span><span class="punctuation" id="L2571">2571
</span><span class="punctuation" id="L2572">2572
</span><span class="punctuation" id="L2573">2573
</span><span class="punctuation" id="L2574">2574
</span><span class="punctuation" id="L2575">2575
</span><span class="punctuation" id="L2576">2576
</span><span class="punctuation" id="L2577">2577
</span><span class="punctuation" id="L2578">2578
</span><span class="punctuation" id="L2579">2579
</span><span class="punctuation" id="L2580">2580
</span><span class="punctuation" id="L2581">2581
</span><span class="punctuation" id="L2582">2582
</span><span class="punctuation" id="L2583">2583
</span><span class="punctuation" id="L2584">2584
</span><span class="punctuation" id="L2585">2585
</span><span class="punctuation" id="L2586">2586
</span><span class="punctuation" id="L2587">2587
</span><span class="punctuation" id="L2588">2588
</span><span class="punctuation" id="L2589">2589
</span><span class="punctuation" id="L2590">2590
</span><span class="punctuation" id="L2591">2591
</span><span class="punctuation" id="L2592">2592
</span><span class="punctuation" id="L2593">2593
</span><span class="punctuation" id="L2594">2594
</span><span class="punctuation" id="L2595">2595
</span><span class="punctuation" id="L2596">2596
</span><span class="punctuation" id="L2597">2597
</span><span class="punctuation" id="L2598">2598
</span><span class="punctuation" id="L2599">2599
</span><span class="punctuation" id="L2600">2600
</span><span class="punctuation" id="L2601">2601
</span><span class="punctuation" id="L2602">2602
</span><span class="punctuation" id="L2603">2603
</span><span class="punctuation" id="L2604">2604
</span><span class="punctuation" id="L2605">2605
</span><span class="punctuation" id="L2606">2606
</span><span class="punctuation" id="L2607">2607
</span><span class="punctuation" id="L2608">2608
</span><span class="punctuation" id="L2609">2609
</span><span class="punctuation" id="L2610">2610
</span><span class="punctuation" id="L2611">2611
</span><span class="punctuation" id="L2612">2612
</span><span class="punctuation" id="L2613">2613
</span><span class="punctuation" id="L2614">2614
</span><span class="punctuation" id="L2615">2615
</span><span class="punctuation" id="L2616">2616
</span><span class="punctuation" id="L2617">2617
</span><span class="punctuation" id="L2618">2618
</span><span class="punctuation" id="L2619">2619
</span><span class="punctuation" id="L2620">2620
</span><span class="punctuation" id="L2621">2621
</span><span class="punctuation" id="L2622">2622
</span><span class="punctuation" id="L2623">2623
</span><span class="punctuation" id="L2624">2624
</span><span class="punctuation" id="L2625">2625
</span><span class="punctuation" id="L2626">2626
</span><span class="punctuation" id="L2627">2627
</span><span class="punctuation" id="L2628">2628
</span><span class="punctuation" id="L2629">2629
</span><span class="punctuation" id="L2630">2630
</span><span class="punctuation" id="L2631">2631
</span><span class="punctuation" id="L2632">2632
</span><span class="punctuation" id="L2633">2633
</span><span class="punctuation" id="L2634">2634
</span><span class="punctuation" id="L2635">2635
</span><span class="punctuation" id="L2636">2636
</span><span class="punctuation" id="L2637">2637
</span><span class="punctuation" id="L2638">2638
</span><span class="punctuation" id="L2639">2639
</span><span class="punctuation" id="L2640">2640
</span><span class="punctuation" id="L2641">2641
</span><span class="punctuation" id="L2642">2642
</span><span class="punctuation" id="L2643">2643
</span><span class="punctuation" id="L2644">2644
</span><span class="punctuation" id="L2645">2645
</span><span class="punctuation" id="L2646">2646
</span><span class="punctuation" id="L2647">2647
</span><span class="punctuation" id="L2648">2648
</span><span class="punctuation" id="L2649">2649
</span><span class="punctuation" id="L2650">2650
</span><span class="punctuation" id="L2651">2651
</span><span class="punctuation" id="L2652">2652
</span><span class="punctuation" id="L2653">2653
</span><span class="punctuation" id="L2654">2654
</span><span class="punctuation" id="L2655">2655
</span><span class="punctuation" id="L2656">2656
</span><span class="punctuation" id="L2657">2657
</span><span class="punctuation" id="L2658">2658
</span><span class="punctuation" id="L2659">2659
</span><span class="punctuation" id="L2660">2660
</span><span class="punctuation" id="L2661">2661
</span><span class="punctuation" id="L2662">2662
</span><span class="punctuation" id="L2663">2663
</span><span class="punctuation" id="L2664">2664
</span><span class="punctuation" id="L2665">2665
</span><span class="punctuation" id="L2666">2666
</span><span class="punctuation" id="L2667">2667
</span><span class="punctuation" id="L2668">2668
</span><span class="punctuation" id="L2669">2669
</span><span class="punctuation" id="L2670">2670
</span><span class="punctuation" id="L2671">2671
</span><span class="punctuation" id="L2672">2672
</span><span class="punctuation" id="L2673">2673
</span><span class="punctuation" id="L2674">2674
</span><span class="punctuation" id="L2675">2675
</span><span class="punctuation" id="L2676">2676
</span><span class="punctuation" id="L2677">2677
</span><span class="punctuation" id="L2678">2678
</span><span class="punctuation" id="L2679">2679
</span><span class="punctuation" id="L2680">2680
</span><span class="punctuation" id="L2681">2681
</span><span class="punctuation" id="L2682">2682
</span><span class="punctuation" id="L2683">2683
</span><span class="punctuation" id="L2684">2684
</span><span class="punctuation" id="L2685">2685
</span><span class="punctuation" id="L2686">2686
</span><span class="punctuation" id="L2687">2687
</span><span class="punctuation" id="L2688">2688
</span><span class="punctuation" id="L2689">2689
</span><span class="punctuation" id="L2690">2690
</span><span class="punctuation" id="L2691">2691
</span><span class="punctuation" id="L2692">2692
</span><span class="punctuation" id="L2693">2693
</span><span class="punctuation" id="L2694">2694
</span><span class="punctuation" id="L2695">2695
</span><span class="punctuation" id="L2696">2696
</span><span class="punctuation" id="L2697">2697
</span><span class="punctuation" id="L2698">2698
</span><span class="punctuation" id="L2699">2699
</span><span class="punctuation" id="L2700">2700
</span><span class="punctuation" id="L2701">2701
</span><span class="punctuation" id="L2702">2702
</span><span class="punctuation" id="L2703">2703
</span><span class="punctuation" id="L2704">2704
</span><span class="punctuation" id="L2705">2705
</span><span class="punctuation" id="L2706">2706
</span><span class="punctuation" id="L2707">2707
</span><span class="punctuation" id="L2708">2708
</span><span class="punctuation" id="L2709">2709
</span><span class="punctuation" id="L2710">2710
</span><span class="punctuation" id="L2711">2711
</span><span class="punctuation" id="L2712">2712
</span><span class="punctuation" id="L2713">2713
</span><span class="punctuation" id="L2714">2714
</span><span class="punctuation" id="L2715">2715
</span><span class="punctuation" id="L2716">2716
</span><span class="punctuation" id="L2717">2717
</span><span class="punctuation" id="L2718">2718
</span><span class="punctuation" id="L2719">2719
</span><span class="punctuation" id="L2720">2720
</span><span class="punctuation" id="L2721">2721
</span><span class="punctuation" id="L2722">2722
</span><span class="punctuation" id="L2723">2723
</span><span class="punctuation" id="L2724">2724
</span><span class="punctuation" id="L2725">2725
</span><span class="punctuation" id="L2726">2726
</span><span class="punctuation" id="L2727">2727
</span><span class="punctuation" id="L2728">2728
</span><span class="punctuation" id="L2729">2729
</span><span class="punctuation" id="L2730">2730
</span><span class="punctuation" id="L2731">2731
</span><span class="punctuation" id="L2732">2732
</span><span class="punctuation" id="L2733">2733
</span><span class="punctuation" id="L2734">2734
</span><span class="punctuation" id="L2735">2735
</span><span class="punctuation" id="L2736">2736
</span><span class="punctuation" id="L2737">2737
</span><span class="punctuation" id="L2738">2738
</span><span class="punctuation" id="L2739">2739
</span><span class="punctuation" id="L2740">2740
</span><span class="punctuation" id="L2741">2741
</span><span class="punctuation" id="L2742">2742
</span><span class="punctuation" id="L2743">2743
</span><span class="punctuation" id="L2744">2744
</span><span class="punctuation" id="L2745">2745
</span><span class="punctuation" id="L2746">2746
</span><span class="punctuation" id="L2747">2747
</span><span class="punctuation" id="L2748">2748
</span><span class="punctuation" id="L2749">2749
</span><span class="punctuation" id="L2750">2750
</span><span class="punctuation" id="L2751">2751
</span><span class="punctuation" id="L2752">2752
</span><span class="punctuation" id="L2753">2753
</span><span class="punctuation" id="L2754">2754
</span><span class="punctuation" id="L2755">2755
</span><span class="punctuation" id="L2756">2756
</span><span class="punctuation" id="L2757">2757
</span><span class="punctuation" id="L2758">2758
</span><span class="punctuation" id="L2759">2759
</span><span class="punctuation" id="L2760">2760
</span><span class="punctuation" id="L2761">2761
</span><span class="punctuation" id="L2762">2762
</span><span class="punctuation" id="L2763">2763
</span><span class="punctuation" id="L2764">2764
</span><span class="punctuation" id="L2765">2765
</span><span class="punctuation" id="L2766">2766
</span><span class="punctuation" id="L2767">2767
</span><span class="punctuation" id="L2768">2768
</span><span class="punctuation" id="L2769">2769
</span><span class="punctuation" id="L2770">2770
</span><span class="punctuation" id="L2771">2771
</span><span class="punctuation" id="L2772">2772
</span><span class="punctuation" id="L2773">2773
</span><span class="punctuation" id="L2774">2774
</span><span class="punctuation" id="L2775">2775
</span><span class="punctuation" id="L2776">2776
</span><span class="punctuation" id="L2777">2777
</span><span class="punctuation" id="L2778">2778
</span><span class="punctuation" id="L2779">2779
</span><span class="punctuation" id="L2780">2780
</span><span class="punctuation" id="L2781">2781
</span><span class="punctuation" id="L2782">2782
</span><span class="punctuation" id="L2783">2783
</span><span class="punctuation" id="L2784">2784
</span><span class="punctuation" id="L2785">2785
</span><span class="punctuation" id="L2786">2786
</span><span class="punctuation" id="L2787">2787
</span><span class="punctuation" id="L2788">2788
</span><span class="punctuation" id="L2789">2789
</span><span class="punctuation" id="L2790">2790
</span><span class="punctuation" id="L2791">2791
</span><span class="punctuation" id="L2792">2792
</span><span class="punctuation" id="L2793">2793
</span><span class="punctuation" id="L2794">2794
</span><span class="punctuation" id="L2795">2795
</span><span class="punctuation" id="L2796">2796
</span><span class="punctuation" id="L2797">2797
</span><span class="punctuation" id="L2798">2798
</span><span class="punctuation" id="L2799">2799
</span><span class="punctuation" id="L2800">2800
</span><span class="punctuation" id="L2801">2801
</span><span class="punctuation" id="L2802">2802
</span><span class="punctuation" id="L2803">2803
</span><span class="punctuation" id="L2804">2804
</span><span class="punctuation" id="L2805">2805
</span><span class="punctuation" id="L2806">2806
</span><span class="punctuation" id="L2807">2807
</span><span class="punctuation" id="L2808">2808
</span><span class="punctuation" id="L2809">2809
</span><span class="punctuation" id="L2810">2810
</span><span class="punctuation" id="L2811">2811
</span><span class="punctuation" id="L2812">2812
</span><span class="punctuation" id="L2813">2813
</span><span class="punctuation" id="L2814">2814
</span><span class="punctuation" id="L2815">2815
</span><span class="punctuation" id="L2816">2816
</span><span class="punctuation" id="L2817">2817
</span><span class="punctuation" id="L2818">2818
</span><span class="punctuation" id="L2819">2819
</span><span class="punctuation" id="L2820">2820
</span><span class="punctuation" id="L2821">2821
</span><span class="punctuation" id="L2822">2822
</span><span class="punctuation" id="L2823">2823
</span><span class="punctuation" id="L2824">2824
</span><span class="punctuation" id="L2825">2825
</span><span class="punctuation" id="L2826">2826
</span><span class="punctuation" id="L2827">2827
</span><span class="punctuation" id="L2828">2828
</span><span class="punctuation" id="L2829">2829
</span><span class="punctuation" id="L2830">2830
</span><span class="punctuation" id="L2831">2831
</span><span class="punctuation" id="L2832">2832
</span><span class="punctuation" id="L2833">2833
</span><span class="punctuation" id="L2834">2834
</span><span class="punctuation" id="L2835">2835
</span><span class="punctuation" id="L2836">2836
</span><span class="punctuation" id="L2837">2837
</span><span class="punctuation" id="L2838">2838
</span><span class="punctuation" id="L2839">2839
</span><span class="punctuation" id="L2840">2840
</span><span class="punctuation" id="L2841">2841
</span><span class="punctuation" id="L2842">2842
</span><span class="punctuation" id="L2843">2843
</span><span class="punctuation" id="L2844">2844
</span><span class="punctuation" id="L2845">2845
</span><span class="punctuation" id="L2846">2846
</span><span class="punctuation" id="L2847">2847
</span><span class="punctuation" id="L2848">2848
</span><span class="punctuation" id="L2849">2849
</span><span class="punctuation" id="L2850">2850
</span><span class="punctuation" id="L2851">2851
</span><span class="punctuation" id="L2852">2852
</span><span class="punctuation" id="L2853">2853
</span><span class="punctuation" id="L2854">2854
</span><span class="punctuation" id="L2855">2855
</span><span class="punctuation" id="L2856">2856
</span><span class="punctuation" id="L2857">2857
</span><span class="punctuation" id="L2858">2858
</span><span class="punctuation" id="L2859">2859
</span><span class="punctuation" id="L2860">2860
</span><span class="punctuation" id="L2861">2861
</span><span class="punctuation" id="L2862">2862
</span><span class="punctuation" id="L2863">2863
</span><span class="punctuation" id="L2864">2864
</span><span class="punctuation" id="L2865">2865
</span><span class="punctuation" id="L2866">2866
</span><span class="punctuation" id="L2867">2867
</span><span class="punctuation" id="L2868">2868
</span><span class="punctuation" id="L2869">2869
</span><span class="punctuation" id="L2870">2870
</span><span class="punctuation" id="L2871">2871
</span><span class="punctuation" id="L2872">2872
</span><span class="punctuation" id="L2873">2873
</span><span class="punctuation" id="L2874">2874
</span><span class="punctuation" id="L2875">2875
</span><span class="punctuation" id="L2876">2876
</span><span class="punctuation" id="L2877">2877
</span><span class="punctuation" id="L2878">2878
</span><span class="punctuation" id="L2879">2879
</span><span class="punctuation" id="L2880">2880
</span><span class="punctuation" id="L2881">2881
</span><span class="punctuation" id="L2882">2882
</span><span class="punctuation" id="L2883">2883
</span><span class="punctuation" id="L2884">2884
</span><span class="punctuation" id="L2885">2885
</span><span class="punctuation" id="L2886">2886
</span><span class="punctuation" id="L2887">2887
</span><span class="punctuation" id="L2888">2888
</span><span class="punctuation" id="L2889">2889
</span><span class="punctuation" id="L2890">2890
</span><span class="punctuation" id="L2891">2891
</span><span class="punctuation" id="L2892">2892
</span><span class="punctuation" id="L2893">2893
</span><span class="punctuation" id="L2894">2894
</span><span class="punctuation" id="L2895">2895
</span><span class="punctuation" id="L2896">2896
</span><span class="punctuation" id="L2897">2897
</span><span class="punctuation" id="L2898">2898
</span><span class="punctuation" id="L2899">2899
</span><span class="punctuation" id="L2900">2900
</span><span class="punctuation" id="L2901">2901
</span><span class="punctuation" id="L2902">2902
</span><span class="punctuation" id="L2903">2903
</span><span class="punctuation" id="L2904">2904
</span><span class="punctuation" id="L2905">2905
</span><span class="punctuation" id="L2906">2906
</span><span class="punctuation" id="L2907">2907
</span><span class="punctuation" id="L2908">2908
</span><span class="punctuation" id="L2909">2909
</span><span class="punctuation" id="L2910">2910
</span><span class="punctuation" id="L2911">2911
</span><span class="punctuation" id="L2912">2912
</span><span class="punctuation" id="L2913">2913
</span><span class="punctuation" id="L2914">2914
</span><span class="punctuation" id="L2915">2915
</span><span class="punctuation" id="L2916">2916
</span><span class="punctuation" id="L2917">2917
</span><span class="punctuation" id="L2918">2918
</span><span class="punctuation" id="L2919">2919
</span><span class="punctuation" id="L2920">2920
</span><span class="punctuation" id="L2921">2921
</span><span class="punctuation" id="L2922">2922
</span><span class="punctuation" id="L2923">2923
</span><span class="punctuation" id="L2924">2924
</span><span class="punctuation" id="L2925">2925
</span><span class="punctuation" id="L2926">2926
</span><span class="punctuation" id="L2927">2927
</span><span class="punctuation" id="L2928">2928
</span><span class="punctuation" id="L2929">2929
</span><span class="punctuation" id="L2930">2930
</span><span class="punctuation" id="L2931">2931
</span><span class="punctuation" id="L2932">2932
</span><span class="punctuation" id="L2933">2933
</span><span class="punctuation" id="L2934">2934
</span><span class="punctuation" id="L2935">2935
</span><span class="punctuation" id="L2936">2936
</span><span class="punctuation" id="L2937">2937
</span><span class="punctuation" id="L2938">2938
</span><span class="punctuation" id="L2939">2939
</span><span class="punctuation" id="L2940">2940
</span><span class="punctuation" id="L2941">2941
</span><span class="punctuation" id="L2942">2942
</span><span class="punctuation" id="L2943">2943
</span><span class="punctuation" id="L2944">2944
</span><span class="punctuation" id="L2945">2945
</span><span class="punctuation" id="L2946">2946
</span><span class="punctuation" id="L2947">2947
</span><span class="punctuation" id="L2948">2948
</span><span class="punctuation" id="L2949">2949
</span><span class="punctuation" id="L2950">2950
</span><span class="punctuation" id="L2951">2951
</span><span class="punctuation" id="L2952">2952
</span><span class="punctuation" id="L2953">2953
</span><span class="punctuation" id="L2954">2954
</span><span class="punctuation" id="L2955">2955
</span><span class="punctuation" id="L2956">2956
</span><span class="punctuation" id="L2957">2957
</span><span class="punctuation" id="L2958">2958
</span><span class="punctuation" id="L2959">2959
</span><span class="punctuation" id="L2960">2960
</span><span class="punctuation" id="L2961">2961
</span><span class="punctuation" id="L2962">2962
</span><span class="punctuation" id="L2963">2963
</span><span class="punctuation" id="L2964">2964
</span><span class="punctuation" id="L2965">2965
</span><span class="punctuation" id="L2966">2966
</span><span class="punctuation" id="L2967">2967
</span><span class="punctuation" id="L2968">2968
</span><span class="punctuation" id="L2969">2969
</span><span class="punctuation" id="L2970">2970
</span><span class="punctuation" id="L2971">2971
</span><span class="punctuation" id="L2972">2972
</span><span class="punctuation" id="L2973">2973
</span><span class="punctuation" id="L2974">2974
</span><span class="punctuation" id="L2975">2975
</span><span class="punctuation" id="L2976">2976
</span><span class="punctuation" id="L2977">2977
</span><span class="punctuation" id="L2978">2978
</span><span class="punctuation" id="L2979">2979
</span><span class="punctuation" id="L2980">2980
</span><span class="punctuation" id="L2981">2981
</span><span class="punctuation" id="L2982">2982
</span><span class="punctuation" id="L2983">2983
</span><span class="punctuation" id="L2984">2984
</span><span class="punctuation" id="L2985">2985
</span><span class="punctuation" id="L2986">2986
</span><span class="punctuation" id="L2987">2987
</span><span class="punctuation" id="L2988">2988
</span><span class="punctuation" id="L2989">2989
</span><span class="punctuation" id="L2990">2990
</span><span class="punctuation" id="L2991">2991
</span><span class="punctuation" id="L2992">2992
</span><span class="punctuation" id="L2993">2993
</span><span class="punctuation" id="L2994">2994
</span><span class="punctuation" id="L2995">2995
</span><span class="punctuation" id="L2996">2996
</span><span class="punctuation" id="L2997">2997
</span><span class="punctuation" id="L2998">2998
</span><span class="punctuation" id="L2999">2999
</span><span class="punctuation" id="L3000">3000
</span><span class="punctuation" id="L3001">3001
</span><span class="punctuation" id="L3002">3002
</span><span class="punctuation" id="L3003">3003
</span><span class="punctuation" id="L3004">3004
</span><span class="punctuation" id="L3005">3005
</span><span class="punctuation" id="L3006">3006
</span><span class="punctuation" id="L3007">3007
</span><span class="punctuation" id="L3008">3008
</span><span class="punctuation" id="L3009">3009
</span><span class="punctuation" id="L3010">3010
</span><span class="punctuation" id="L3011">3011
</span><span class="punctuation" id="L3012">3012
</span><span class="punctuation" id="L3013">3013
</span><span class="punctuation" id="L3014">3014
</span><span class="punctuation" id="L3015">3015
</span><span class="punctuation" id="L3016">3016
</span><span class="punctuation" id="L3017">3017
</span><span class="punctuation" id="L3018">3018
</span><span class="punctuation" id="L3019">3019
</span><span class="punctuation" id="L3020">3020
</span><span class="punctuation" id="L3021">3021
</span><span class="punctuation" id="L3022">3022
</span><span class="punctuation" id="L3023">3023
</span><span class="punctuation" id="L3024">3024
</span><span class="punctuation" id="L3025">3025
</span><span class="punctuation" id="L3026">3026
</span><span class="punctuation" id="L3027">3027
</span><span class="punctuation" id="L3028">3028
</span><span class="punctuation" id="L3029">3029
</span><span class="punctuation" id="L3030">3030
</span><span class="punctuation" id="L3031">3031
</span><span class="punctuation" id="L3032">3032
</span><span class="punctuation" id="L3033">3033
</span><span class="punctuation" id="L3034">3034
</span><span class="punctuation" id="L3035">3035
</span><span class="punctuation" id="L3036">3036
</span><span class="punctuation" id="L3037">3037
</span><span class="punctuation" id="L3038">3038
</span><span class="punctuation" id="L3039">3039
</span><span class="punctuation" id="L3040">3040
</span><span class="punctuation" id="L3041">3041
</span><span class="punctuation" id="L3042">3042
</span><span class="punctuation" id="L3043">3043
</span><span class="punctuation" id="L3044">3044
</span><span class="punctuation" id="L3045">3045
</span><span class="punctuation" id="L3046">3046
</span><span class="punctuation" id="L3047">3047
</span><span class="punctuation" id="L3048">3048
</span><span class="punctuation" id="L3049">3049
</span><span class="punctuation" id="L3050">3050
</span><span class="punctuation" id="L3051">3051
</span><span class="punctuation" id="L3052">3052
</span><span class="punctuation" id="L3053">3053
</span><span class="punctuation" id="L3054">3054
</span><span class="punctuation" id="L3055">3055
</span><span class="punctuation" id="L3056">3056
</span><span class="punctuation" id="L3057">3057
</span><span class="punctuation" id="L3058">3058
</span><span class="punctuation" id="L3059">3059
</span><span class="punctuation" id="L3060">3060
</span><span class="punctuation" id="L3061">3061
</span><span class="punctuation" id="L3062">3062
</span><span class="punctuation" id="L3063">3063
</span><span class="punctuation" id="L3064">3064
</span><span class="punctuation" id="L3065">3065
</span><span class="punctuation" id="L3066">3066
</span><span class="punctuation" id="L3067">3067
</span><span class="punctuation" id="L3068">3068
</span><span class="punctuation" id="L3069">3069
</span><span class="punctuation" id="L3070">3070
</span><span class="punctuation" id="L3071">3071
</span><span class="punctuation" id="L3072">3072
</span><span class="punctuation" id="L3073">3073
</span><span class="punctuation" id="L3074">3074
</span><span class="punctuation" id="L3075">3075
</span><span class="punctuation" id="L3076">3076
</span><span class="punctuation" id="L3077">3077
</span><span class="punctuation" id="L3078">3078
</span><span class="punctuation" id="L3079">3079
</span><span class="punctuation" id="L3080">3080
</span><span class="punctuation" id="L3081">3081
</span><span class="punctuation" id="L3082">3082
</span><span class="punctuation" id="L3083">3083
</span><span class="punctuation" id="L3084">3084
</span><span class="punctuation" id="L3085">3085
</span><span class="punctuation" id="L3086">3086
</span><span class="punctuation" id="L3087">3087
</span><span class="punctuation" id="L3088">3088
</span><span class="punctuation" id="L3089">3089
</span><span class="punctuation" id="L3090">3090
</span><span class="punctuation" id="L3091">3091
</span><span class="punctuation" id="L3092">3092
</span><span class="punctuation" id="L3093">3093
</span><span class="punctuation" id="L3094">3094
</span><span class="punctuation" id="L3095">3095
</span><span class="punctuation" id="L3096">3096
</span><span class="punctuation" id="L3097">3097
</span><span class="punctuation" id="L3098">3098
</span><span class="punctuation" id="L3099">3099
</span><span class="punctuation" id="L3100">3100
</span><span class="punctuation" id="L3101">3101
</span><span class="punctuation" id="L3102">3102
</span><span class="punctuation" id="L3103">3103
</span><span class="punctuation" id="L3104">3104
</span><span class="punctuation" id="L3105">3105
</span><span class="punctuation" id="L3106">3106
</span><span class="punctuation" id="L3107">3107
</span><span class="punctuation" id="L3108">3108
</span><span class="punctuation" id="L3109">3109
</span><span class="punctuation" id="L3110">3110
</span><span class="punctuation" id="L3111">3111
</span><span class="punctuation" id="L3112">3112
</span><span class="punctuation" id="L3113">3113
</span><span class="punctuation" id="L3114">3114
</span><span class="punctuation" id="L3115">3115
</span><span class="punctuation" id="L3116">3116
</span><span class="punctuation" id="L3117">3117
</span><span class="punctuation" id="L3118">3118
</span><span class="punctuation" id="L3119">3119
</span><span class="punctuation" id="L3120">3120
</span><span class="punctuation" id="L3121">3121
</span><span class="punctuation" id="L3122">3122
</span><span class="punctuation" id="L3123">3123
</span><span class="punctuation" id="L3124">3124
</span><span class="punctuation" id="L3125">3125
</span><span class="punctuation" id="L3126">3126
</span><span class="punctuation" id="L3127">3127
</span><span class="punctuation" id="L3128">3128
</span><span class="punctuation" id="L3129">3129
</span><span class="punctuation" id="L3130">3130
</span><span class="punctuation" id="L3131">3131
</span><span class="punctuation" id="L3132">3132
</span><span class="punctuation" id="L3133">3133
</span><span class="punctuation" id="L3134">3134
</span><span class="punctuation" id="L3135">3135
</span><span class="punctuation" id="L3136">3136
</span><span class="punctuation" id="L3137">3137
</span><span class="punctuation" id="L3138">3138
</span><span class="punctuation" id="L3139">3139
</span><span class="punctuation" id="L3140">3140
</span><span class="punctuation" id="L3141">3141
</span><span class="punctuation" id="L3142">3142
</span><span class="punctuation" id="L3143">3143
</span><span class="punctuation" id="L3144">3144
</span><span class="punctuation" id="L3145">3145
</span><span class="punctuation" id="L3146">3146
</span><span class="punctuation" id="L3147">3147
</span><span class="punctuation" id="L3148">3148
</span><span class="punctuation" id="L3149">3149
</span><span class="punctuation" id="L3150">3150
</span><span class="punctuation" id="L3151">3151
</span><span class="punctuation" id="L3152">3152
</span><span class="punctuation" id="L3153">3153
</span><span class="punctuation" id="L3154">3154
</span><span class="punctuation" id="L3155">3155
</span><span class="punctuation" id="L3156">3156
</span><span class="punctuation" id="L3157">3157
</span><span class="punctuation" id="L3158">3158
</span><span class="punctuation" id="L3159">3159
</span><span class="punctuation" id="L3160">3160
</span><span class="punctuation" id="L3161">3161
</span><span class="punctuation" id="L3162">3162
</span><span class="punctuation" id="L3163">3163
</span><span class="punctuation" id="L3164">3164
</span><span class="punctuation" id="L3165">3165
</span><span class="punctuation" id="L3166">3166
</span><span class="punctuation" id="L3167">3167
</span><span class="punctuation" id="L3168">3168
</span><span class="punctuation" id="L3169">3169
</span><span class="punctuation" id="L3170">3170
</span><span class="punctuation" id="L3171">3171
</span><span class="punctuation" id="L3172">3172
</span><span class="punctuation" id="L3173">3173
</span><span class="punctuation" id="L3174">3174
</span><span class="punctuation" id="L3175">3175
</span><span class="punctuation" id="L3176">3176
</span><span class="punctuation" id="L3177">3177
</span><span class="punctuation" id="L3178">3178
</span><span class="punctuation" id="L3179">3179
</span><span class="punctuation" id="L3180">3180
</span><span class="punctuation" id="L3181">3181
</span><span class="punctuation" id="L3182">3182
</span><span class="punctuation" id="L3183">3183
</span><span class="punctuation" id="L3184">3184
</span><span class="punctuation" id="L3185">3185
</span><span class="punctuation" id="L3186">3186
</span><span class="punctuation" id="L3187">3187
</span><span class="punctuation" id="L3188">3188
</span><span class="punctuation" id="L3189">3189
</span><span class="punctuation" id="L3190">3190
</span><span class="punctuation" id="L3191">3191
</span><span class="punctuation" id="L3192">3192
</span><span class="punctuation" id="L3193">3193
</span><span class="punctuation" id="L3194">3194
</span><span class="punctuation" id="L3195">3195
</span><span class="punctuation" id="L3196">3196
</span><span class="punctuation" id="L3197">3197
</span><span class="punctuation" id="L3198">3198
</span><span class="punctuation" id="L3199">3199
</span><span class="punctuation" id="L3200">3200
</span><span class="punctuation" id="L3201">3201
</span><span class="punctuation" id="L3202">3202
</span><span class="punctuation" id="L3203">3203
</span><span class="punctuation" id="L3204">3204
</span><span class="punctuation" id="L3205">3205
</span><span class="punctuation" id="L3206">3206
</span><span class="punctuation" id="L3207">3207
</span><span class="punctuation" id="L3208">3208
</span><span class="punctuation" id="L3209">3209
</span><span class="punctuation" id="L3210">3210
</span><span class="punctuation" id="L3211">3211
</span><span class="punctuation" id="L3212">3212
</span><span class="punctuation" id="L3213">3213
</span><span class="punctuation" id="L3214">3214
</span><span class="punctuation" id="L3215">3215
</span><span class="punctuation" id="L3216">3216
</span><span class="punctuation" id="L3217">3217
</span><span class="punctuation" id="L3218">3218
</span><span class="punctuation" id="L3219">3219
</span><span class="punctuation" id="L3220">3220
</span><span class="punctuation" id="L3221">3221
</span><span class="punctuation" id="L3222">3222
</span><span class="punctuation" id="L3223">3223
</span><span class="punctuation" id="L3224">3224
</span><span class="punctuation" id="L3225">3225
</span><span class="punctuation" id="L3226">3226
</span><span class="punctuation" id="L3227">3227
</span><span class="punctuation" id="L3228">3228
</span><span class="punctuation" id="L3229">3229
</span><span class="punctuation" id="L3230">3230
</span><span class="punctuation" id="L3231">3231
</span><span class="punctuation" id="L3232">3232
</span><span class="punctuation" id="L3233">3233
</span><span class="punctuation" id="L3234">3234
</span><span class="punctuation" id="L3235">3235
</span><span class="punctuation" id="L3236">3236
</span><span class="punctuation" id="L3237">3237
</span><span class="punctuation" id="L3238">3238
</span><span class="punctuation" id="L3239">3239
</span><span class="punctuation" id="L3240">3240
</span><span class="punctuation" id="L3241">3241
</span><span class="punctuation" id="L3242">3242
</span><span class="punctuation" id="L3243">3243
</span><span class="punctuation" id="L3244">3244
</span><span class="punctuation" id="L3245">3245
</span><span class="punctuation" id="L3246">3246
</span><span class="punctuation" id="L3247">3247
</span><span class="punctuation" id="L3248">3248
</span><span class="punctuation" id="L3249">3249
</span><span class="punctuation" id="L3250">3250
</span><span class="punctuation" id="L3251">3251
</span><span class="punctuation" id="L3252">3252
</span><span class="punctuation" id="L3253">3253
</span><span class="punctuation" id="L3254">3254
</span><span class="punctuation" id="L3255">3255
</span><span class="punctuation" id="L3256">3256
</span><span class="punctuation" id="L3257">3257
</span><span class="punctuation" id="L3258">3258
</span><span class="punctuation" id="L3259">3259
</span><span class="punctuation" id="L3260">3260
</span><span class="punctuation" id="L3261">3261
</span><span class="punctuation" id="L3262">3262
</span><span class="punctuation" id="L3263">3263
</span><span class="punctuation" id="L3264">3264
</span><span class="punctuation" id="L3265">3265
</span><span class="punctuation" id="L3266">3266
</span><span class="punctuation" id="L3267">3267
</span><span class="punctuation" id="L3268">3268
</span><span class="punctuation" id="L3269">3269
</span><span class="punctuation" id="L3270">3270
</span><span class="punctuation" id="L3271">3271
</span><span class="punctuation" id="L3272">3272
</span><span class="punctuation" id="L3273">3273
</span><span class="punctuation" id="L3274">3274
</span><span class="punctuation" id="L3275">3275
</span><span class="punctuation" id="L3276">3276
</span><span class="punctuation" id="L3277">3277
</span><span class="punctuation" id="L3278">3278
</span><span class="punctuation" id="L3279">3279
</span><span class="punctuation" id="L3280">3280
</span><span class="punctuation" id="L3281">3281
</span><span class="punctuation" id="L3282">3282
</span><span class="punctuation" id="L3283">3283
</span><span class="punctuation" id="L3284">3284
</span><span class="punctuation" id="L3285">3285
</span><span class="punctuation" id="L3286">3286
</span><span class="punctuation" id="L3287">3287
</span><span class="punctuation" id="L3288">3288
</span><span class="punctuation" id="L3289">3289
</span><span class="punctuation" id="L3290">3290
</span><span class="punctuation" id="L3291">3291
</span><span class="punctuation" id="L3292">3292
</span><span class="punctuation" id="L3293">3293
</span><span class="punctuation" id="L3294">3294
</span><span class="punctuation" id="L3295">3295
</span><span class="punctuation" id="L3296">3296
</span><span class="punctuation" id="L3297">3297
</span><span class="punctuation" id="L3298">3298
</span><span class="punctuation" id="L3299">3299
</span><span class="punctuation" id="L3300">3300
</span><span class="punctuation" id="L3301">3301
</span><span class="punctuation" id="L3302">3302
</span><span class="punctuation" id="L3303">3303
</span><span class="punctuation" id="L3304">3304
</span><span class="punctuation" id="L3305">3305
</span><span class="punctuation" id="L3306">3306
</span><span class="punctuation" id="L3307">3307
</span><span class="punctuation" id="L3308">3308
</span><span class="punctuation" id="L3309">3309
</span><span class="punctuation" id="L3310">3310
</span><span class="punctuation" id="L3311">3311
</span><span class="punctuation" id="L3312">3312
</span><span class="punctuation" id="L3313">3313
</span><span class="punctuation" id="L3314">3314
</span><span class="punctuation" id="L3315">3315
</span><span class="punctuation" id="L3316">3316
</span><span class="punctuation" id="L3317">3317
</span><span class="punctuation" id="L3318">3318
</span><span class="punctuation" id="L3319">3319
</span><span class="punctuation" id="L3320">3320
</span><span class="punctuation" id="L3321">3321
</span><span class="punctuation" id="L3322">3322
</span><span class="punctuation" id="L3323">3323
</span><span class="punctuation" id="L3324">3324
</span><span class="punctuation" id="L3325">3325
</span><span class="punctuation" id="L3326">3326
</span><span class="punctuation" id="L3327">3327
</span><span class="punctuation" id="L3328">3328
</span><span class="punctuation" id="L3329">3329
</span><span class="punctuation" id="L3330">3330
</span><span class="punctuation" id="L3331">3331
</span><span class="punctuation" id="L3332">3332
</span><span class="punctuation" id="L3333">3333
</span><span class="punctuation" id="L3334">3334
</span><span class="punctuation" id="L3335">3335
</span><span class="punctuation" id="L3336">3336
</span><span class="punctuation" id="L3337">3337
</span><span class="punctuation" id="L3338">3338
</span><span class="punctuation" id="L3339">3339
</span><span class="punctuation" id="L3340">3340
</span><span class="punctuation" id="L3341">3341
</span><span class="punctuation" id="L3342">3342
</span><span class="punctuation" id="L3343">3343
</span><span class="punctuation" id="L3344">3344
</span><span class="punctuation" id="L3345">3345
</span><span class="punctuation" id="L3346">3346
</span><span class="punctuation" id="L3347">3347
</span><span class="punctuation" id="L3348">3348
</span><span class="punctuation" id="L3349">3349
</span><span class="punctuation" id="L3350">3350
</span><span class="punctuation" id="L3351">3351
</span><span class="punctuation" id="L3352">3352
</span><span class="punctuation" id="L3353">3353
</span><span class="punctuation" id="L3354">3354
</span><span class="punctuation" id="L3355">3355
</span><span class="punctuation" id="L3356">3356
</span><span class="punctuation" id="L3357">3357
</span><span class="punctuation" id="L3358">3358
</span><span class="punctuation" id="L3359">3359
</span><span class="punctuation" id="L3360">3360
</span><span class="punctuation" id="L3361">3361
</span><span class="punctuation" id="L3362">3362
</span><span class="punctuation" id="L3363">3363
</span><span class="punctuation" id="L3364">3364
</span><span class="punctuation" id="L3365">3365
</span><span class="punctuation" id="L3366">3366
</span><span class="punctuation" id="L3367">3367
</span><span class="punctuation" id="L3368">3368
</span><span class="punctuation" id="L3369">3369
</span><span class="punctuation" id="L3370">3370
</span><span class="punctuation" id="L3371">3371
</span><span class="punctuation" id="L3372">3372
</span><span class="punctuation" id="L3373">3373
</span><span class="punctuation" id="L3374">3374
</span><span class="punctuation" id="L3375">3375
</span><span class="punctuation" id="L3376">3376
</span><span class="punctuation" id="L3377">3377
</span><span class="punctuation" id="L3378">3378
</span><span class="punctuation" id="L3379">3379
</span><span class="punctuation" id="L3380">3380
</span><span class="punctuation" id="L3381">3381
</span><span class="punctuation" id="L3382">3382
</span><span class="punctuation" id="L3383">3383
</span><span class="punctuation" id="L3384">3384
</span><span class="punctuation" id="L3385">3385
</span><span class="punctuation" id="L3386">3386
</span><span class="punctuation" id="L3387">3387
</span><span class="punctuation" id="L3388">3388
</span><span class="punctuation" id="L3389">3389
</span><span class="punctuation" id="L3390">3390
</span><span class="punctuation" id="L3391">3391
</span><span class="punctuation" id="L3392">3392
</span><span class="punctuation" id="L3393">3393
</span><span class="punctuation" id="L3394">3394
</span><span class="punctuation" id="L3395">3395
</span><span class="punctuation" id="L3396">3396
</span><span class="punctuation" id="L3397">3397
</span><span class="punctuation" id="L3398">3398
</span><span class="punctuation" id="L3399">3399
</span><span class="punctuation" id="L3400">3400
</span><span class="punctuation" id="L3401">3401
</span><span class="punctuation" id="L3402">3402
</span><span class="punctuation" id="L3403">3403
</span><span class="punctuation" id="L3404">3404
</span><span class="punctuation" id="L3405">3405
</span><span class="punctuation" id="L3406">3406
</span><span class="punctuation" id="L3407">3407
</span><span class="punctuation" id="L3408">3408
</span><span class="punctuation" id="L3409">3409
</span><span class="punctuation" id="L3410">3410
</span><span class="punctuation" id="L3411">3411
</span><span class="punctuation" id="L3412">3412
</span><span class="punctuation" id="L3413">3413
</span><span class="punctuation" id="L3414">3414
</span><span class="punctuation" id="L3415">3415
</span><span class="punctuation" id="L3416">3416
</span><span class="punctuation" id="L3417">3417
</span><span class="punctuation" id="L3418">3418
</span><span class="punctuation" id="L3419">3419
</span><span class="punctuation" id="L3420">3420
</span><span class="punctuation" id="L3421">3421
</span><span class="punctuation" id="L3422">3422
</span><span class="punctuation" id="L3423">3423
</span><span class="punctuation" id="L3424">3424
</span><span class="punctuation" id="L3425">3425
</span><span class="punctuation" id="L3426">3426
</span><span class="punctuation" id="L3427">3427
</span><span class="punctuation" id="L3428">3428
</span><span class="punctuation" id="L3429">3429
</span><span class="punctuation" id="L3430">3430
</span><span class="punctuation" id="L3431">3431
</span><span class="punctuation" id="L3432">3432
</span><span class="punctuation" id="L3433">3433
</span><span class="punctuation" id="L3434">3434
</span><span class="punctuation" id="L3435">3435
</span><span class="punctuation" id="L3436">3436
</span><span class="punctuation" id="L3437">3437
</span><span class="punctuation" id="L3438">3438
</span><span class="punctuation" id="L3439">3439
</span><span class="punctuation" id="L3440">3440
</span><span class="punctuation" id="L3441">3441
</span><span class="punctuation" id="L3442">3442
</span><span class="punctuation" id="L3443">3443
</span><span class="punctuation" id="L3444">3444
</span><span class="punctuation" id="L3445">3445
</span><span class="punctuation" id="L3446">3446
</span><span class="punctuation" id="L3447">3447
</span><span class="punctuation" id="L3448">3448
</span><span class="punctuation" id="L3449">3449
</span><span class="punctuation" id="L3450">3450
</span><span class="punctuation" id="L3451">3451
</span><span class="punctuation" id="L3452">3452
</span><span class="punctuation" id="L3453">3453
</span><span class="punctuation" id="L3454">3454
</span><span class="punctuation" id="L3455">3455
</span><span class="punctuation" id="L3456">3456
</span><span class="punctuation" id="L3457">3457
</span><span class="punctuation" id="L3458">3458
</span><span class="punctuation" id="L3459">3459
</span><span class="punctuation" id="L3460">3460
</span><span class="punctuation" id="L3461">3461
</span><span class="punctuation" id="L3462">3462
</span><span class="punctuation" id="L3463">3463
</span><span class="punctuation" id="L3464">3464
</span><span class="punctuation" id="L3465">3465
</span><span class="punctuation" id="L3466">3466
</span><span class="punctuation" id="L3467">3467
</span><span class="punctuation" id="L3468">3468
</span><span class="punctuation" id="L3469">3469
</span><span class="punctuation" id="L3470">3470
</span><span class="punctuation" id="L3471">3471
</span><span class="punctuation" id="L3472">3472
</span><span class="punctuation" id="L3473">3473
</span><span class="punctuation" id="L3474">3474
</span><span class="punctuation" id="L3475">3475
</span><span class="punctuation" id="L3476">3476
</span><span class="punctuation" id="L3477">3477
</span><span class="punctuation" id="L3478">3478
</span><span class="punctuation" id="L3479">3479
</span><span class="punctuation" id="L3480">3480
</span><span class="punctuation" id="L3481">3481
</span><span class="punctuation" id="L3482">3482
</span><span class="punctuation" id="L3483">3483
</span><span class="punctuation" id="L3484">3484
</span><span class="punctuation" id="L3485">3485
</span><span class="punctuation" id="L3486">3486
</span><span class="punctuation" id="L3487">3487
</span><span class="punctuation" id="L3488">3488
</span><span class="punctuation" id="L3489">3489
</span><span class="punctuation" id="L3490">3490
</span><span class="punctuation" id="L3491">3491
</span><span class="punctuation" id="L3492">3492
</span><span class="punctuation" id="L3493">3493
</span><span class="punctuation" id="L3494">3494
</span><span class="punctuation" id="L3495">3495
</span><span class="punctuation" id="L3496">3496
</span><span class="punctuation" id="L3497">3497
</span><span class="punctuation" id="L3498">3498
</span><span class="punctuation" id="L3499">3499
</span><span class="punctuation" id="L3500">3500
</span><span class="punctuation" id="L3501">3501
</span><span class="punctuation" id="L3502">3502
</span><span class="punctuation" id="L3503">3503
</span><span class="punctuation" id="L3504">3504
</span><span class="punctuation" id="L3505">3505
</span><span class="punctuation" id="L3506">3506
</span><span class="punctuation" id="L3507">3507
</span><span class="punctuation" id="L3508">3508
</span><span class="punctuation" id="L3509">3509
</span><span class="punctuation" id="L3510">3510
</span><span class="punctuation" id="L3511">3511
</span><span class="punctuation" id="L3512">3512
</span><span class="punctuation" id="L3513">3513
</span><span class="punctuation" id="L3514">3514
</span><span class="punctuation" id="L3515">3515
</span><span class="punctuation" id="L3516">3516
</span><span class="punctuation" id="L3517">3517
</span><span class="punctuation" id="L3518">3518
</span><span class="punctuation" id="L3519">3519
</span><span class="punctuation" id="L3520">3520
</span><span class="punctuation" id="L3521">3521
</span><span class="punctuation" id="L3522">3522
</span><span class="punctuation" id="L3523">3523
</span><span class="punctuation" id="L3524">3524
</span><span class="punctuation" id="L3525">3525
</span><span class="punctuation" id="L3526">3526
</span><span class="punctuation" id="L3527">3527
</span><span class="punctuation" id="L3528">3528
</span><span class="punctuation" id="L3529">3529
</span><span class="punctuation" id="L3530">3530
</span><span class="punctuation" id="L3531">3531
</span><span class="punctuation" id="L3532">3532
</span><span class="punctuation" id="L3533">3533
</span><span class="punctuation" id="L3534">3534
</span><span class="punctuation" id="L3535">3535
</span><span class="punctuation" id="L3536">3536
</span><span class="punctuation" id="L3537">3537
</span><span class="punctuation" id="L3538">3538
</span><span class="punctuation" id="L3539">3539
</span><span class="punctuation" id="L3540">3540
</span><span class="punctuation" id="L3541">3541
</span><span class="punctuation" id="L3542">3542
</span><span class="punctuation" id="L3543">3543
</span><span class="punctuation" id="L3544">3544
</span><span class="punctuation" id="L3545">3545
</span><span class="punctuation" id="L3546">3546
</span><span class="punctuation" id="L3547">3547
</span><span class="punctuation" id="L3548">3548
</span><span class="punctuation" id="L3549">3549
</span><span class="punctuation" id="L3550">3550
</span><span class="punctuation" id="L3551">3551
</span><span class="punctuation" id="L3552">3552
</span><span class="punctuation" id="L3553">3553
</span><span class="punctuation" id="L3554">3554
</span><span class="punctuation" id="L3555">3555
</span><span class="punctuation" id="L3556">3556
</span><span class="punctuation" id="L3557">3557
</span><span class="punctuation" id="L3558">3558
</span><span class="punctuation" id="L3559">3559
</span><span class="punctuation" id="L3560">3560
</span><span class="punctuation" id="L3561">3561
</span><span class="punctuation" id="L3562">3562
</span><span class="punctuation" id="L3563">3563
</span><span class="punctuation" id="L3564">3564
</span><span class="punctuation" id="L3565">3565
</span><span class="punctuation" id="L3566">3566
</span><span class="punctuation" id="L3567">3567
</span><span class="punctuation" id="L3568">3568
</span><span class="punctuation" id="L3569">3569
</span><span class="punctuation" id="L3570">3570
</span><span class="punctuation" id="L3571">3571
</span><span class="punctuation" id="L3572">3572
</span><span class="punctuation" id="L3573">3573
</span><span class="punctuation" id="L3574">3574
</span><span class="punctuation" id="L3575">3575
</span><span class="punctuation" id="L3576">3576
</span><span class="punctuation" id="L3577">3577
</span><span class="punctuation" id="L3578">3578
</span><span class="punctuation" id="L3579">3579
</span><span class="punctuation" id="L3580">3580
</span><span class="punctuation" id="L3581">3581
</span><span class="punctuation" id="L3582">3582
</span><span class="punctuation" id="L3583">3583
</span><span class="punctuation" id="L3584">3584
</span><span class="punctuation" id="L3585">3585
</span><span class="punctuation" id="L3586">3586
</span><span class="punctuation" id="L3587">3587
</span><span class="punctuation" id="L3588">3588
</span><span class="punctuation" id="L3589">3589
</span><span class="punctuation" id="L3590">3590
</span><span class="punctuation" id="L3591">3591
</span><span class="punctuation" id="L3592">3592
</span><span class="punctuation" id="L3593">3593
</span><span class="punctuation" id="L3594">3594
</span><span class="punctuation" id="L3595">3595
</span><span class="punctuation" id="L3596">3596
</span><span class="punctuation" id="L3597">3597
</span><span class="punctuation" id="L3598">3598
</span><span class="punctuation" id="L3599">3599
</span><span class="punctuation" id="L3600">3600
</span><span class="punctuation" id="L3601">3601
</span><span class="punctuation" id="L3602">3602
</span><span class="punctuation" id="L3603">3603
</span><span class="punctuation" id="L3604">3604
</span><span class="punctuation" id="L3605">3605
</span><span class="punctuation" id="L3606">3606
</span><span class="punctuation" id="L3607">3607
</span><span class="punctuation" id="L3608">3608
</span><span class="punctuation" id="L3609">3609
</span><span class="punctuation" id="L3610">3610
</span><span class="punctuation" id="L3611">3611
</span><span class="punctuation" id="L3612">3612
</span><span class="punctuation" id="L3613">3613
</span><span class="punctuation" id="L3614">3614
</span><span class="punctuation" id="L3615">3615
</span><span class="punctuation" id="L3616">3616
</span><span class="punctuation" id="L3617">3617
</span><span class="punctuation" id="L3618">3618
</span><span class="punctuation" id="L3619">3619
</span><span class="punctuation" id="L3620">3620
</span><span class="punctuation" id="L3621">3621
</span><span class="punctuation" id="L3622">3622
</span><span class="punctuation" id="L3623">3623
</span><span class="punctuation" id="L3624">3624
</span><span class="punctuation" id="L3625">3625
</span><span class="punctuation" id="L3626">3626
</span><span class="punctuation" id="L3627">3627
</span><span class="punctuation" id="L3628">3628
</span><span class="punctuation" id="L3629">3629
</span><span class="punctuation" id="L3630">3630
</span><span class="punctuation" id="L3631">3631
</span><span class="punctuation" id="L3632">3632
</span><span class="punctuation" id="L3633">3633
</span><span class="punctuation" id="L3634">3634
</span><span class="punctuation" id="L3635">3635
</span><span class="punctuation" id="L3636">3636
</span><span class="punctuation" id="L3637">3637
</span><span class="punctuation" id="L3638">3638
</span><span class="punctuation" id="L3639">3639
</span><span class="punctuation" id="L3640">3640
</span><span class="punctuation" id="L3641">3641
</span><span class="punctuation" id="L3642">3642
</span><span class="punctuation" id="L3643">3643
</span><span class="punctuation" id="L3644">3644
</span><span class="punctuation" id="L3645">3645
</span><span class="punctuation" id="L3646">3646
</span><span class="punctuation" id="L3647">3647
</span><span class="punctuation" id="L3648">3648
</span><span class="punctuation" id="L3649">3649
</span><span class="punctuation" id="L3650">3650
</span><span class="punctuation" id="L3651">3651
</span><span class="punctuation" id="L3652">3652
</span><span class="punctuation" id="L3653">3653
</span><span class="punctuation" id="L3654">3654
</span><span class="punctuation" id="L3655">3655
</span><span class="punctuation" id="L3656">3656
</span><span class="punctuation" id="L3657">3657
</span><span class="punctuation" id="L3658">3658
</span><span class="punctuation" id="L3659">3659
</span><span class="punctuation" id="L3660">3660
</span><span class="punctuation" id="L3661">3661
</span><span class="punctuation" id="L3662">3662
</span><span class="punctuation" id="L3663">3663
</span><span class="punctuation" id="L3664">3664
</span><span class="punctuation" id="L3665">3665
</span><span class="punctuation" id="L3666">3666
</span><span class="punctuation" id="L3667">3667
</span><span class="punctuation" id="L3668">3668
</span><span class="punctuation" id="L3669">3669
</span><span class="punctuation" id="L3670">3670
</span><span class="punctuation" id="L3671">3671
</span><span class="punctuation" id="L3672">3672
</span><span class="punctuation" id="L3673">3673
</span><span class="punctuation" id="L3674">3674
</span><span class="punctuation" id="L3675">3675
</span><span class="punctuation" id="L3676">3676
</span><span class="punctuation" id="L3677">3677
</span><span class="punctuation" id="L3678">3678
</span><span class="punctuation" id="L3679">3679
</span><span class="punctuation" id="L3680">3680
</span><span class="punctuation" id="L3681">3681
</span><span class="punctuation" id="L3682">3682
</span><span class="punctuation" id="L3683">3683
</span><span class="punctuation" id="L3684">3684
</span><span class="punctuation" id="L3685">3685
</span><span class="punctuation" id="L3686">3686
</span><span class="punctuation" id="L3687">3687
</span><span class="punctuation" id="L3688">3688
</span><span class="punctuation" id="L3689">3689
</span><span class="punctuation" id="L3690">3690
</span><span class="punctuation" id="L3691">3691
</span><span class="punctuation" id="L3692">3692
</span><span class="punctuation" id="L3693">3693
</span><span class="punctuation" id="L3694">3694
</span><span class="punctuation" id="L3695">3695
</span><span class="punctuation" id="L3696">3696
</span><span class="punctuation" id="L3697">3697
</span><span class="punctuation" id="L3698">3698
</span><span class="punctuation" id="L3699">3699
</span><span class="punctuation" id="L3700">3700
</span><span class="punctuation" id="L3701">3701
</span><span class="punctuation" id="L3702">3702
</span><span class="punctuation" id="L3703">3703
</span><span class="punctuation" id="L3704">3704
</span><span class="punctuation" id="L3705">3705
</span><span class="punctuation" id="L3706">3706
</span><span class="punctuation" id="L3707">3707
</span><span class="punctuation" id="L3708">3708
</span><span class="punctuation" id="L3709">3709
</span><span class="punctuation" id="L3710">3710
</span><span class="punctuation" id="L3711">3711
</span><span class="punctuation" id="L3712">3712
</span><span class="punctuation" id="L3713">3713
</span><span class="punctuation" id="L3714">3714
</span><span class="punctuation" id="L3715">3715
</span><span class="punctuation" id="L3716">3716
</span><span class="punctuation" id="L3717">3717
</span><span class="punctuation" id="L3718">3718
</span><span class="punctuation" id="L3719">3719
</span><span class="punctuation" id="L3720">3720
</span><span class="punctuation" id="L3721">3721
</span><span class="punctuation" id="L3722">3722
</span><span class="punctuation" id="L3723">3723
</span><span class="punctuation" id="L3724">3724
</span><span class="punctuation" id="L3725">3725
</span><span class="punctuation" id="L3726">3726
</span><span class="punctuation" id="L3727">3727
</span><span class="punctuation" id="L3728">3728
</span><span class="punctuation" id="L3729">3729
</span><span class="punctuation" id="L3730">3730
</span><span class="punctuation" id="L3731">3731
</span><span class="punctuation" id="L3732">3732
</span><span class="punctuation" id="L3733">3733
</span><span class="punctuation" id="L3734">3734
</span><span class="punctuation" id="L3735">3735
</span><span class="punctuation" id="L3736">3736
</span><span class="punctuation" id="L3737">3737
</span><span class="punctuation" id="L3738">3738
</span><span class="punctuation" id="L3739">3739
</span><span class="punctuation" id="L3740">3740
</span><span class="punctuation" id="L3741">3741
</span><span class="punctuation" id="L3742">3742
</span><span class="punctuation" id="L3743">3743
</span><span class="punctuation" id="L3744">3744
</span><span class="punctuation" id="L3745">3745
</span><span class="punctuation" id="L3746">3746
</span><span class="punctuation" id="L3747">3747
</span><span class="punctuation" id="L3748">3748
</span><span class="punctuation" id="L3749">3749
</span><span class="punctuation" id="L3750">3750
</span><span class="punctuation" id="L3751">3751
</span><span class="punctuation" id="L3752">3752
</span><span class="punctuation" id="L3753">3753
</span><span class="punctuation" id="L3754">3754
</span><span class="punctuation" id="L3755">3755
</span><span class="punctuation" id="L3756">3756
</span><span class="punctuation" id="L3757">3757
</span><span class="punctuation" id="L3758">3758
</span><span class="punctuation" id="L3759">3759
</span><span class="punctuation" id="L3760">3760
</span><span class="punctuation" id="L3761">3761
</span><span class="punctuation" id="L3762">3762
</span><span class="punctuation" id="L3763">3763
</span><span class="punctuation" id="L3764">3764
</span><span class="punctuation" id="L3765">3765
</span><span class="punctuation" id="L3766">3766
</span><span class="punctuation" id="L3767">3767
</span><span class="punctuation" id="L3768">3768
</span><span class="punctuation" id="L3769">3769
</span><span class="punctuation" id="L3770">3770
</span><span class="punctuation" id="L3771">3771
</span><span class="punctuation" id="L3772">3772
</span><span class="punctuation" id="L3773">3773
</span><span class="punctuation" id="L3774">3774
</span><span class="punctuation" id="L3775">3775
</span><span class="punctuation" id="L3776">3776
</span><span class="punctuation" id="L3777">3777
</span><span class="punctuation" id="L3778">3778
</span><span class="punctuation" id="L3779">3779
</span><span class="punctuation" id="L3780">3780
</span><span class="punctuation" id="L3781">3781
</span><span class="punctuation" id="L3782">3782
</span><span class="punctuation" id="L3783">3783
</span><span class="punctuation" id="L3784">3784
</span><span class="punctuation" id="L3785">3785
</span><span class="punctuation" id="L3786">3786
</span><span class="punctuation" id="L3787">3787
</span><span class="punctuation" id="L3788">3788
</span><span class="punctuation" id="L3789">3789
</span><span class="punctuation" id="L3790">3790
</span><span class="punctuation" id="L3791">3791
</span><span class="punctuation" id="L3792">3792
</span><span class="punctuation" id="L3793">3793
</span><span class="punctuation" id="L3794">3794
</span><span class="punctuation" id="L3795">3795
</span><span class="punctuation" id="L3796">3796
</span><span class="punctuation" id="L3797">3797
</span><span class="punctuation" id="L3798">3798
</span><span class="punctuation" id="L3799">3799
</span><span class="punctuation" id="L3800">3800
</span><span class="punctuation" id="L3801">3801
</span><span class="punctuation" id="L3802">3802
</span><span class="punctuation" id="L3803">3803
</span><span class="punctuation" id="L3804">3804
</span><span class="punctuation" id="L3805">3805
</span><span class="punctuation" id="L3806">3806
</span><span class="punctuation" id="L3807">3807
</span><span class="punctuation" id="L3808">3808
</span><span class="punctuation" id="L3809">3809
</span><span class="punctuation" id="L3810">3810
</span><span class="punctuation" id="L3811">3811
</span><span class="punctuation" id="L3812">3812
</span><span class="punctuation" id="L3813">3813
</span><span class="punctuation" id="L3814">3814
</span><span class="punctuation" id="L3815">3815
</span><span class="punctuation" id="L3816">3816
</span><span class="punctuation" id="L3817">3817
</span><span class="punctuation" id="L3818">3818
</span><span class="punctuation" id="L3819">3819
</span><span class="punctuation" id="L3820">3820
</span><span class="punctuation" id="L3821">3821
</span><span class="punctuation" id="L3822">3822
</span><span class="punctuation" id="L3823">3823
</span><span class="punctuation" id="L3824">3824
</span><span class="punctuation" id="L3825">3825
</span><span class="punctuation" id="L3826">3826
</span><span class="punctuation" id="L3827">3827
</span><span class="punctuation" id="L3828">3828
</span><span class="punctuation" id="L3829">3829
</span><span class="punctuation" id="L3830">3830
</span><span class="punctuation" id="L3831">3831
</span><span class="punctuation" id="L3832">3832
</span><span class="punctuation" id="L3833">3833
</span><span class="punctuation" id="L3834">3834
</span><span class="punctuation" id="L3835">3835
</span><span class="punctuation" id="L3836">3836
</span><span class="punctuation" id="L3837">3837
</span><span class="punctuation" id="L3838">3838
</span><span class="punctuation" id="L3839">3839
</span><span class="punctuation" id="L3840">3840
</span><span class="punctuation" id="L3841">3841
</span><span class="punctuation" id="L3842">3842
</span><span class="punctuation" id="L3843">3843
</span><span class="punctuation" id="L3844">3844
</span><span class="punctuation" id="L3845">3845
</span><span class="punctuation" id="L3846">3846
</span><span class="punctuation" id="L3847">3847
</span><span class="punctuation" id="L3848">3848
</span><span class="punctuation" id="L3849">3849
</span><span class="punctuation" id="L3850">3850
</span><span class="punctuation" id="L3851">3851
</span><span class="punctuation" id="L3852">3852
</span><span class="punctuation" id="L3853">3853
</span><span class="punctuation" id="L3854">3854
</span><span class="punctuation" id="L3855">3855
</span><span class="punctuation" id="L3856">3856
</span><span class="punctuation" id="L3857">3857
</span><span class="punctuation" id="L3858">3858
</span><span class="punctuation" id="L3859">3859
</span><span class="punctuation" id="L3860">3860
</span><span class="punctuation" id="L3861">3861
</span><span class="punctuation" id="L3862">3862
</span><span class="punctuation" id="L3863">3863
</span><span class="punctuation" id="L3864">3864
</span><span class="punctuation" id="L3865">3865
</span><span class="punctuation" id="L3866">3866
</span><span class="punctuation" id="L3867">3867
</span><span class="punctuation" id="L3868">3868
</span><span class="punctuation" id="L3869">3869
</span><span class="punctuation" id="L3870">3870
</span><span class="punctuation" id="L3871">3871
</span><span class="punctuation" id="L3872">3872
</span><span class="punctuation" id="L3873">3873
</span><span class="punctuation" id="L3874">3874
</span><span class="punctuation" id="L3875">3875
</span><span class="punctuation" id="L3876">3876
</span><span class="punctuation" id="L3877">3877
</span><span class="punctuation" id="L3878">3878
</span><span class="punctuation" id="L3879">3879
</span><span class="punctuation" id="L3880">3880
</span><span class="punctuation" id="L3881">3881
</span><span class="punctuation" id="L3882">3882
</span><span class="punctuation" id="L3883">3883
</span><span class="punctuation" id="L3884">3884
</span><span class="punctuation" id="L3885">3885
</span><span class="punctuation" id="L3886">3886
</span><span class="punctuation" id="L3887">3887
</span><span class="punctuation" id="L3888">3888
</span><span class="punctuation" id="L3889">3889
</span><span class="punctuation" id="L3890">3890
</span><span class="punctuation" id="L3891">3891
</span><span class="punctuation" id="L3892">3892
</span><span class="punctuation" id="L3893">3893
</span><span class="punctuation" id="L3894">3894
</span><span class="punctuation" id="L3895">3895
</span><span class="punctuation" id="L3896">3896
</span><span class="punctuation" id="L3897">3897
</span><span class="punctuation" id="L3898">3898
</span><span class="punctuation" id="L3899">3899
</span><span class="punctuation" id="L3900">3900
</span><span class="punctuation" id="L3901">3901
</span><span class="punctuation" id="L3902">3902
</span><span class="punctuation" id="L3903">3903
</span><span class="punctuation" id="L3904">3904
</span><span class="punctuation" id="L3905">3905
</span><span class="punctuation" id="L3906">3906
</span><span class="punctuation" id="L3907">3907
</span><span class="punctuation" id="L3908">3908
</span><span class="punctuation" id="L3909">3909
</span><span class="punctuation" id="L3910">3910
</span><span class="punctuation" id="L3911">3911
</span><span class="punctuation" id="L3912">3912
</span><span class="punctuation" id="L3913">3913
</span><span class="punctuation" id="L3914">3914
</span><span class="punctuation" id="L3915">3915
</span><span class="punctuation" id="L3916">3916
</span><span class="punctuation" id="L3917">3917
</span><span class="punctuation" id="L3918">3918
</span><span class="punctuation" id="L3919">3919
</span><span class="punctuation" id="L3920">3920
</span><span class="punctuation" id="L3921">3921
</span><span class="punctuation" id="L3922">3922
</span><span class="punctuation" id="L3923">3923
</span><span class="punctuation" id="L3924">3924
</span><span class="punctuation" id="L3925">3925
</span><span class="punctuation" id="L3926">3926
</span><span class="punctuation" id="L3927">3927
</span><span class="punctuation" id="L3928">3928
</span><span class="punctuation" id="L3929">3929
</span><span class="punctuation" id="L3930">3930
</span><span class="punctuation" id="L3931">3931
</span><span class="punctuation" id="L3932">3932
</span><span class="punctuation" id="L3933">3933
</span><span class="punctuation" id="L3934">3934
</span><span class="punctuation" id="L3935">3935
</span><span class="punctuation" id="L3936">3936
</span><span class="punctuation" id="L3937">3937
</span><span class="punctuation" id="L3938">3938
</span><span class="punctuation" id="L3939">3939
</span><span class="punctuation" id="L3940">3940
</span><span class="punctuation" id="L3941">3941
</span><span class="punctuation" id="L3942">3942
</span><span class="punctuation" id="L3943">3943
</span><span class="punctuation" id="L3944">3944
</span><span class="punctuation" id="L3945">3945
</span><span class="punctuation" id="L3946">3946
</span><span class="punctuation" id="L3947">3947
</span><span class="punctuation" id="L3948">3948
</span><span class="punctuation" id="L3949">3949
</span><span class="punctuation" id="L3950">3950
</span><span class="punctuation" id="L3951">3951
</span><span class="punctuation" id="L3952">3952
</span><span class="punctuation" id="L3953">3953
</span><span class="punctuation" id="L3954">3954
</span><span class="punctuation" id="L3955">3955
</span><span class="punctuation" id="L3956">3956
</span><span class="punctuation" id="L3957">3957
</span><span class="punctuation" id="L3958">3958
</span><span class="punctuation" id="L3959">3959
</span><span class="punctuation" id="L3960">3960
</span><span class="punctuation" id="L3961">3961
</span><span class="punctuation" id="L3962">3962
</span><span class="punctuation" id="L3963">3963
</span><span class="punctuation" id="L3964">3964
</span><span class="punctuation" id="L3965">3965
</span><span class="punctuation" id="L3966">3966
</span><span class="punctuation" id="L3967">3967
</span><span class="punctuation" id="L3968">3968
</span><span class="punctuation" id="L3969">3969
</span><span class="punctuation" id="L3970">3970
</span><span class="punctuation" id="L3971">3971
</span><span class="punctuation" id="L3972">3972
</span><span class="punctuation" id="L3973">3973
</span><span class="punctuation" id="L3974">3974
</span><span class="punctuation" id="L3975">3975
</span><span class="punctuation" id="L3976">3976
</span><span class="punctuation" id="L3977">3977
</span><span class="punctuation" id="L3978">3978
</span><span class="punctuation" id="L3979">3979
</span><span class="punctuation" id="L3980">3980
</span><span class="punctuation" id="L3981">3981
</span><span class="punctuation" id="L3982">3982
</span><span class="punctuation" id="L3983">3983
</span><span class="punctuation" id="L3984">3984
</span><span class="punctuation" id="L3985">3985
</span><span class="punctuation" id="L3986">3986
</span><span class="punctuation" id="L3987">3987
</span><span class="punctuation" id="L3988">3988
</span><span class="punctuation" id="L3989">3989
</span><span class="punctuation" id="L3990">3990
</span><span class="punctuation" id="L3991">3991
</span><span class="punctuation" id="L3992">3992
</span><span class="punctuation" id="L3993">3993
</span><span class="punctuation" id="L3994">3994
</span><span class="punctuation" id="L3995">3995
</span><span class="punctuation" id="L3996">3996
</span><span class="punctuation" id="L3997">3997
</span><span class="punctuation" id="L3998">3998
</span><span class="punctuation" id="L3999">3999
</span><span class="punctuation" id="L4000">4000
</span><span class="punctuation" id="L4001">4001
</span><span class="punctuation" id="L4002">4002
</span><span class="punctuation" id="L4003">4003
</span><span class="punctuation" id="L4004">4004
</span><span class="punctuation" id="L4005">4005
</span><span class="punctuation" id="L4006">4006
</span><span class="punctuation" id="L4007">4007
</span><span class="punctuation" id="L4008">4008
</span><span class="punctuation" id="L4009">4009
</span><span class="punctuation" id="L4010">4010
</span><span class="punctuation" id="L4011">4011
</span><span class="punctuation" id="L4012">4012
</span><span class="punctuation" id="L4013">4013
</span><span class="punctuation" id="L4014">4014
</span><span class="punctuation" id="L4015">4015
</span><span class="punctuation" id="L4016">4016
</span><span class="punctuation" id="L4017">4017
</span><span class="punctuation" id="L4018">4018
</span><span class="punctuation" id="L4019">4019
</span><span class="punctuation" id="L4020">4020
</span><span class="punctuation" id="L4021">4021
</span><span class="punctuation" id="L4022">4022
</span><span class="punctuation" id="L4023">4023
</span><span class="punctuation" id="L4024">4024
</span><span class="punctuation" id="L4025">4025
</span><span class="punctuation" id="L4026">4026
</span><span class="punctuation" id="L4027">4027
</span><span class="punctuation" id="L4028">4028
</span><span class="punctuation" id="L4029">4029
</span><span class="punctuation" id="L4030">4030
</span><span class="punctuation" id="L4031">4031
</span><span class="punctuation" id="L4032">4032
</span><span class="punctuation" id="L4033">4033
</span><span class="punctuation" id="L4034">4034
</span><span class="punctuation" id="L4035">4035
</span><span class="punctuation" id="L4036">4036
</span><span class="punctuation" id="L4037">4037
</span><span class="punctuation" id="L4038">4038
</span><span class="punctuation" id="L4039">4039
</span><span class="punctuation" id="L4040">4040
</span><span class="punctuation" id="L4041">4041
</span><span class="punctuation" id="L4042">4042
</span><span class="punctuation" id="L4043">4043
</span><span class="punctuation" id="L4044">4044
</span><span class="punctuation" id="L4045">4045
</span><span class="punctuation" id="L4046">4046
</span><span class="punctuation" id="L4047">4047
</span><span class="punctuation" id="L4048">4048
</span><span class="punctuation" id="L4049">4049
</span><span class="punctuation" id="L4050">4050
</span><span class="punctuation" id="L4051">4051
</span><span class="punctuation" id="L4052">4052
</span><span class="punctuation" id="L4053">4053
</span><span class="punctuation" id="L4054">4054
</span><span class="punctuation" id="L4055">4055
</span><span class="punctuation" id="L4056">4056
</span><span class="punctuation" id="L4057">4057
</span><span class="punctuation" id="L4058">4058
</span><span class="punctuation" id="L4059">4059
</span><span class="punctuation" id="L4060">4060
</span><span class="punctuation" id="L4061">4061
</span><span class="punctuation" id="L4062">4062
</span><span class="punctuation" id="L4063">4063
</span><span class="punctuation" id="L4064">4064
</span><span class="punctuation" id="L4065">4065
</span><span class="punctuation" id="L4066">4066
</span><span class="punctuation" id="L4067">4067
</span><span class="punctuation" id="L4068">4068
</span><span class="punctuation" id="L4069">4069
</span><span class="punctuation" id="L4070">4070
</span><span class="punctuation" id="L4071">4071
</span><span class="punctuation" id="L4072">4072
</span><span class="punctuation" id="L4073">4073
</span><span class="punctuation" id="L4074">4074
</span><span class="punctuation" id="L4075">4075
</span><span class="punctuation" id="L4076">4076
</span><span class="punctuation" id="L4077">4077
</span><span class="punctuation" id="L4078">4078
</span><span class="punctuation" id="L4079">4079
</span><span class="punctuation" id="L4080">4080
</span><span class="punctuation" id="L4081">4081
</span><span class="punctuation" id="L4082">4082
</span><span class="punctuation" id="L4083">4083
</span><span class="punctuation" id="L4084">4084
</span><span class="punctuation" id="L4085">4085
</span><span class="punctuation" id="L4086">4086
</span><span class="punctuation" id="L4087">4087
</span><span class="punctuation" id="L4088">4088
</span><span class="punctuation" id="L4089">4089
</span><span class="punctuation" id="L4090">4090
</span><span class="punctuation" id="L4091">4091
</span><span class="punctuation" id="L4092">4092
</span><span class="punctuation" id="L4093">4093
</span><span class="punctuation" id="L4094">4094
</span><span class="punctuation" id="L4095">4095
</span><span class="punctuation" id="L4096">4096
</span><span class="punctuation" id="L4097">4097
</span><span class="punctuation" id="L4098">4098
</span><span class="punctuation" id="L4099">4099
</span><span class="punctuation" id="L4100">4100
</span><span class="punctuation" id="L4101">4101
</span><span class="punctuation" id="L4102">4102
</span><span class="punctuation" id="L4103">4103
</span><span class="punctuation" id="L4104">4104
</span><span class="punctuation" id="L4105">4105
</span><span class="punctuation" id="L4106">4106
</span><span class="punctuation" id="L4107">4107
</span><span class="punctuation" id="L4108">4108
</span><span class="punctuation" id="L4109">4109
</span><span class="punctuation" id="L4110">4110
</span><span class="punctuation" id="L4111">4111
</span><span class="punctuation" id="L4112">4112
</span><span class="punctuation" id="L4113">4113
</span><span class="punctuation" id="L4114">4114
</span><span class="punctuation" id="L4115">4115
</span><span class="punctuation" id="L4116">4116
</span><span class="punctuation" id="L4117">4117
</span><span class="punctuation" id="L4118">4118
</span><span class="punctuation" id="L4119">4119
</span><span class="punctuation" id="L4120">4120
</span><span class="punctuation" id="L4121">4121
</span><span class="punctuation" id="L4122">4122
</span><span class="punctuation" id="L4123">4123
</span><span class="punctuation" id="L4124">4124
</span><span class="punctuation" id="L4125">4125
</span><span class="punctuation" id="L4126">4126
</span><span class="punctuation" id="L4127">4127
</span><span class="punctuation" id="L4128">4128
</span><span class="punctuation" id="L4129">4129
</span><span class="punctuation" id="L4130">4130
</span><span class="punctuation" id="L4131">4131
</span><span class="punctuation" id="L4132">4132
</span><span class="punctuation" id="L4133">4133
</span><span class="punctuation" id="L4134">4134
</span><span class="punctuation" id="L4135">4135
</span><span class="punctuation" id="L4136">4136
</span><span class="punctuation" id="L4137">4137
</span><span class="punctuation" id="L4138">4138
</span><span class="punctuation" id="L4139">4139
</span><span class="punctuation" id="L4140">4140
</span><span class="punctuation" id="L4141">4141
</span><span class="punctuation" id="L4142">4142
</span><span class="punctuation" id="L4143">4143
</span><span class="punctuation" id="L4144">4144
</span><span class="punctuation" id="L4145">4145
</span><span class="punctuation" id="L4146">4146
</span><span class="punctuation" id="L4147">4147
</span><span class="punctuation" id="L4148">4148
</span><span class="punctuation" id="L4149">4149
</span><span class="punctuation" id="L4150">4150
</span><span class="punctuation" id="L4151">4151
</span><span class="punctuation" id="L4152">4152
</span><span class="punctuation" id="L4153">4153
</span><span class="punctuation" id="L4154">4154
</span><span class="punctuation" id="L4155">4155
</span><span class="punctuation" id="L4156">4156
</span><span class="punctuation" id="L4157">4157
</span><span class="punctuation" id="L4158">4158
</span><span class="punctuation" id="L4159">4159
</span><span class="punctuation" id="L4160">4160
</span><span class="punctuation" id="L4161">4161
</span><span class="punctuation" id="L4162">4162
</span><span class="punctuation" id="L4163">4163
</span><span class="punctuation" id="L4164">4164
</span><span class="punctuation" id="L4165">4165
</span><span class="punctuation" id="L4166">4166
</span><span class="punctuation" id="L4167">4167
</span><span class="punctuation" id="L4168">4168
</span><span class="punctuation" id="L4169">4169
</span><span class="punctuation" id="L4170">4170
</span><span class="punctuation" id="L4171">4171
</span><span class="punctuation" id="L4172">4172
</span><span class="punctuation" id="L4173">4173
</span><span class="punctuation" id="L4174">4174
</span><span class="punctuation" id="L4175">4175
</span><span class="punctuation" id="L4176">4176
</span><span class="punctuation" id="L4177">4177
</span><span class="punctuation" id="L4178">4178
</span><span class="punctuation" id="L4179">4179
</span><span class="punctuation" id="L4180">4180
</span><span class="punctuation" id="L4181">4181
</span><span class="punctuation" id="L4182">4182
</span><span class="punctuation" id="L4183">4183
</span><span class="punctuation" id="L4184">4184
</span><span class="punctuation" id="L4185">4185
</span><span class="punctuation" id="L4186">4186
</span><span class="punctuation" id="L4187">4187
</span><span class="punctuation" id="L4188">4188
</span><span class="punctuation" id="L4189">4189
</span><span class="punctuation" id="L4190">4190
</span><span class="punctuation" id="L4191">4191
</span><span class="punctuation" id="L4192">4192
</span><span class="punctuation" id="L4193">4193
</span><span class="punctuation" id="L4194">4194
</span><span class="punctuation" id="L4195">4195
</span><span class="punctuation" id="L4196">4196
</span><span class="punctuation" id="L4197">4197
</span><span class="punctuation" id="L4198">4198
</span><span class="punctuation" id="L4199">4199
</span><span class="punctuation" id="L4200">4200
</span><span class="punctuation" id="L4201">4201
</span><span class="punctuation" id="L4202">4202
</span><span class="punctuation" id="L4203">4203
</span><span class="punctuation" id="L4204">4204
</span><span class="punctuation" id="L4205">4205
</span><span class="punctuation" id="L4206">4206
</span><span class="punctuation" id="L4207">4207
</span><span class="punctuation" id="L4208">4208
</span><span class="punctuation" id="L4209">4209
</span><span class="punctuation" id="L4210">4210
</span><span class="punctuation" id="L4211">4211
</span><span class="punctuation" id="L4212">4212
</span><span class="punctuation" id="L4213">4213
</span><span class="punctuation" id="L4214">4214
</span><span class="punctuation" id="L4215">4215
</span><span class="punctuation" id="L4216">4216
</span><span class="punctuation" id="L4217">4217
</span><span class="punctuation" id="L4218">4218
</span><span class="punctuation" id="L4219">4219
</span><span class="punctuation" id="L4220">4220
</span><span class="punctuation" id="L4221">4221
</span><span class="punctuation" id="L4222">4222
</span><span class="punctuation" id="L4223">4223
</span><span class="punctuation" id="L4224">4224
</span><span class="punctuation" id="L4225">4225
</span><span class="punctuation" id="L4226">4226
</span><span class="punctuation" id="L4227">4227
</span><span class="punctuation" id="L4228">4228
</span><span class="punctuation" id="L4229">4229
</span><span class="punctuation" id="L4230">4230
</span><span class="punctuation" id="L4231">4231
</span><span class="punctuation" id="L4232">4232
</span><span class="punctuation" id="L4233">4233
</span><span class="punctuation" id="L4234">4234
</span><span class="punctuation" id="L4235">4235
</span><span class="punctuation" id="L4236">4236
</span><span class="punctuation" id="L4237">4237
</span><span class="punctuation" id="L4238">4238
</span><span class="punctuation" id="L4239">4239
</span><span class="punctuation" id="L4240">4240
</span><span class="punctuation" id="L4241">4241
</span><span class="punctuation" id="L4242">4242
</span><span class="punctuation" id="L4243">4243
</span><span class="punctuation" id="L4244">4244
</span><span class="punctuation" id="L4245">4245
</span><span class="punctuation" id="L4246">4246
</span><span class="punctuation" id="L4247">4247
</span><span class="punctuation" id="L4248">4248
</span><span class="punctuation" id="L4249">4249
</span><span class="punctuation" id="L4250">4250
</span><span class="punctuation" id="L4251">4251
</span><span class="punctuation" id="L4252">4252
</span><span class="punctuation" id="L4253">4253
</span><span class="punctuation" id="L4254">4254
</span><span class="punctuation" id="L4255">4255
</span><span class="punctuation" id="L4256">4256
</span><span class="punctuation" id="L4257">4257
</span><span class="punctuation" id="L4258">4258
</span><span class="punctuation" id="L4259">4259
</span><span class="punctuation" id="L4260">4260
</span><span class="punctuation" id="L4261">4261
</span><span class="punctuation" id="L4262">4262
</span><span class="punctuation" id="L4263">4263
</span><span class="punctuation" id="L4264">4264
</span><span class="punctuation" id="L4265">4265
</span><span class="punctuation" id="L4266">4266
</span><span class="punctuation" id="L4267">4267
</span><span class="punctuation" id="L4268">4268
</span><span class="punctuation" id="L4269">4269
</span><span class="punctuation" id="L4270">4270
</span><span class="punctuation" id="L4271">4271
</span><span class="punctuation" id="L4272">4272
</span><span class="punctuation" id="L4273">4273
</span><span class="punctuation" id="L4274">4274
</span><span class="punctuation" id="L4275">4275
</span><span class="punctuation" id="L4276">4276
</span><span class="punctuation" id="L4277">4277
</span><span class="punctuation" id="L4278">4278
</span><span class="punctuation" id="L4279">4279
</span><span class="punctuation" id="L4280">4280
</span><span class="punctuation" id="L4281">4281
</span><span class="punctuation" id="L4282">4282
</span><span class="punctuation" id="L4283">4283
</span><span class="punctuation" id="L4284">4284
</span><span class="punctuation" id="L4285">4285
</span><span class="punctuation" id="L4286">4286
</span><span class="punctuation" id="L4287">4287
</span><span class="punctuation" id="L4288">4288
</span><span class="punctuation" id="L4289">4289
</span><span class="punctuation" id="L4290">4290
</span><span class="punctuation" id="L4291">4291
</span><span class="punctuation" id="L4292">4292
</span><span class="punctuation" id="L4293">4293
</span><span class="punctuation" id="L4294">4294
</span><span class="punctuation" id="L4295">4295
</span><span class="punctuation" id="L4296">4296
</span><span class="punctuation" id="L4297">4297
</span><span class="punctuation" id="L4298">4298
</span><span class="punctuation" id="L4299">4299
</span><span class="punctuation" id="L4300">4300
</span><span class="punctuation" id="L4301">4301
</span><span class="punctuation" id="L4302">4302
</span><span class="punctuation" id="L4303">4303
</span><span class="punctuation" id="L4304">4304
</span><span class="punctuation" id="L4305">4305
</span><span class="punctuation" id="L4306">4306
</span><span class="punctuation" id="L4307">4307
</span><span class="punctuation" id="L4308">4308
</span><span class="punctuation" id="L4309">4309
</span><span class="punctuation" id="L4310">4310
</span><span class="punctuation" id="L4311">4311
</span><span class="punctuation" id="L4312">4312
</span><span class="punctuation" id="L4313">4313
</span><span class="punctuation" id="L4314">4314
</span><span class="punctuation" id="L4315">4315
</span><span class="punctuation" id="L4316">4316
</span><span class="punctuation" id="L4317">4317
</span><span class="punctuation" id="L4318">4318
</span><span class="punctuation" id="L4319">4319
</span><span class="punctuation" id="L4320">4320
</span><span class="punctuation" id="L4321">4321
</span><span class="punctuation" id="L4322">4322
</span><span class="punctuation" id="L4323">4323
</span><span class="punctuation" id="L4324">4324
</span><span class="punctuation" id="L4325">4325
</span><span class="punctuation" id="L4326">4326
</span><span class="punctuation" id="L4327">4327
</span><span class="punctuation" id="L4328">4328
</span><span class="punctuation" id="L4329">4329
</span><span class="punctuation" id="L4330">4330
</span><span class="punctuation" id="L4331">4331
</span><span class="punctuation" id="L4332">4332
</span><span class="punctuation" id="L4333">4333
</span><span class="punctuation" id="L4334">4334
</span><span class="punctuation" id="L4335">4335
</span><span class="punctuation" id="L4336">4336
</span><span class="punctuation" id="L4337">4337
</span><span class="punctuation" id="L4338">4338
</span><span class="punctuation" id="L4339">4339
</span><span class="punctuation" id="L4340">4340
</span><span class="punctuation" id="L4341">4341
</span><span class="punctuation" id="L4342">4342
</span><span class="punctuation" id="L4343">4343
</span><span class="punctuation" id="L4344">4344
</span><span class="punctuation" id="L4345">4345
</span><span class="punctuation" id="L4346">4346
</span><span class="punctuation" id="L4347">4347
</span><span class="punctuation" id="L4348">4348
</span><span class="punctuation" id="L4349">4349
</span><span class="punctuation" id="L4350">4350
</span><span class="punctuation" id="L4351">4351
</span><span class="punctuation" id="L4352">4352
</span><span class="punctuation" id="L4353">4353
</span><span class="punctuation" id="L4354">4354
</span><span class="punctuation" id="L4355">4355
</span><span class="punctuation" id="L4356">4356
</span><span class="punctuation" id="L4357">4357
</span><span class="punctuation" id="L4358">4358
</span><span class="punctuation" id="L4359">4359
</span><span class="punctuation" id="L4360">4360
</span><span class="punctuation" id="L4361">4361
</span><span class="punctuation" id="L4362">4362
</span><span class="punctuation" id="L4363">4363
</span><span class="punctuation" id="L4364">4364
</span><span class="punctuation" id="L4365">4365
</span><span class="punctuation" id="L4366">4366
</span><span class="punctuation" id="L4367">4367
</span><span class="punctuation" id="L4368">4368
</span><span class="punctuation" id="L4369">4369
</span><span class="punctuation" id="L4370">4370
</span><span class="punctuation" id="L4371">4371
</span><span class="punctuation" id="L4372">4372
</span><span class="punctuation" id="L4373">4373
</span><span class="punctuation" id="L4374">4374
</span><span class="punctuation" id="L4375">4375
</span><span class="punctuation" id="L4376">4376
</span><span class="punctuation" id="L4377">4377
</span><span class="punctuation" id="L4378">4378
</span><span class="punctuation" id="L4379">4379
</span><span class="punctuation" id="L4380">4380
</span><span class="punctuation" id="L4381">4381
</span><span class="punctuation" id="L4382">4382
</span><span class="punctuation" id="L4383">4383
</span><span class="punctuation" id="L4384">4384
</span><span class="punctuation" id="L4385">4385
</span><span class="punctuation" id="L4386">4386
</span><span class="punctuation" id="L4387">4387
</span><span class="punctuation" id="L4388">4388
</span><span class="punctuation" id="L4389">4389
</span><span class="punctuation" id="L4390">4390
</span><span class="punctuation" id="L4391">4391
</span><span class="punctuation" id="L4392">4392
</span><span class="punctuation" id="L4393">4393
</span><span class="punctuation" id="L4394">4394
</span><span class="punctuation" id="L4395">4395
</span><span class="punctuation" id="L4396">4396
</span><span class="punctuation" id="L4397">4397
</span><span class="punctuation" id="L4398">4398
</span><span class="punctuation" id="L4399">4399
</span><span class="punctuation" id="L4400">4400
</span><span class="punctuation" id="L4401">4401
</span><span class="punctuation" id="L4402">4402
</span><span class="punctuation" id="L4403">4403
</span><span class="punctuation" id="L4404">4404
</span><span class="punctuation" id="L4405">4405
</span><span class="punctuation" id="L4406">4406
</span><span class="punctuation" id="L4407">4407
</span><span class="punctuation" id="L4408">4408
</span><span class="punctuation" id="L4409">4409
</span><span class="punctuation" id="L4410">4410
</span><span class="punctuation" id="L4411">4411
</span><span class="punctuation" id="L4412">4412
</span><span class="punctuation" id="L4413">4413
</span><span class="punctuation" id="L4414">4414
</span><span class="punctuation" id="L4415">4415
</span><span class="punctuation" id="L4416">4416
</span><span class="punctuation" id="L4417">4417
</span><span class="punctuation" id="L4418">4418
</span><span class="punctuation" id="L4419">4419
</span><span class="punctuation" id="L4420">4420
</span><span class="punctuation" id="L4421">4421
</span><span class="punctuation" id="L4422">4422
</span><span class="punctuation" id="L4423">4423
</span><span class="punctuation" id="L4424">4424
</span><span class="punctuation" id="L4425">4425
</span><span class="punctuation" id="L4426">4426
</span><span class="punctuation" id="L4427">4427
</span><span class="punctuation" id="L4428">4428
</span><span class="punctuation" id="L4429">4429
</span><span class="punctuation" id="L4430">4430
</span><span class="punctuation" id="L4431">4431
</span><span class="punctuation" id="L4432">4432
</span><span class="punctuation" id="L4433">4433
</span><span class="punctuation" id="L4434">4434
</span><span class="punctuation" id="L4435">4435
</span><span class="punctuation" id="L4436">4436
</span><span class="punctuation" id="L4437">4437
</span><span class="punctuation" id="L4438">4438
</span><span class="punctuation" id="L4439">4439
</span><span class="punctuation" id="L4440">4440
</span><span class="punctuation" id="L4441">4441
</span><span class="punctuation" id="L4442">4442
</span><span class="punctuation" id="L4443">4443
</span><span class="punctuation" id="L4444">4444
</span><span class="punctuation" id="L4445">4445
</span><span class="punctuation" id="L4446">4446
</span><span class="punctuation" id="L4447">4447
</span><span class="punctuation" id="L4448">4448
</span><span class="punctuation" id="L4449">4449
</span><span class="punctuation" id="L4450">4450
</span><span class="punctuation" id="L4451">4451
</span><span class="punctuation" id="L4452">4452
</span><span class="punctuation" id="L4453">4453
</span><span class="punctuation" id="L4454">4454
</span><span class="punctuation" id="L4455">4455
</span><span class="punctuation" id="L4456">4456
</span><span class="punctuation" id="L4457">4457
</span><span class="punctuation" id="L4458">4458
</span><span class="punctuation" id="L4459">4459
</span><span class="punctuation" id="L4460">4460
</span><span class="punctuation" id="L4461">4461
</span><span class="punctuation" id="L4462">4462
</span><span class="punctuation" id="L4463">4463
</span><span class="punctuation" id="L4464">4464
</span><span class="punctuation" id="L4465">4465
</span><span class="punctuation" id="L4466">4466
</span><span class="punctuation" id="L4467">4467
</span><span class="punctuation" id="L4468">4468
</span><span class="punctuation" id="L4469">4469
</span><span class="punctuation" id="L4470">4470
</span><span class="punctuation" id="L4471">4471
</span><span class="punctuation" id="L4472">4472
</span><span class="punctuation" id="L4473">4473
</span><span class="punctuation" id="L4474">4474
</span><span class="punctuation" id="L4475">4475
</span><span class="punctuation" id="L4476">4476
</span><span class="punctuation" id="L4477">4477
</span><span class="punctuation" id="L4478">4478
</span><span class="punctuation" id="L4479">4479
</span><span class="punctuation" id="L4480">4480
</span><span class="punctuation" id="L4481">4481
</span><span class="punctuation" id="L4482">4482
</span><span class="punctuation" id="L4483">4483
</span><span class="punctuation" id="L4484">4484
</span><span class="punctuation" id="L4485">4485
</span><span class="punctuation" id="L4486">4486
</span><span class="punctuation" id="L4487">4487
</span><span class="punctuation" id="L4488">4488
</span><span class="punctuation" id="L4489">4489
</span><span class="punctuation" id="L4490">4490
</span><span class="punctuation" id="L4491">4491
</span><span class="punctuation" id="L4492">4492
</span><span class="punctuation" id="L4493">4493
</span><span class="punctuation" id="L4494">4494
</span><span class="punctuation" id="L4495">4495
</span><span class="punctuation" id="L4496">4496
</span><span class="punctuation" id="L4497">4497
</span><span class="punctuation" id="L4498">4498
</span><span class="punctuation" id="L4499">4499
</span><span class="punctuation" id="L4500">4500
</span><span class="punctuation" id="L4501">4501
</span><span class="punctuation" id="L4502">4502
</span><span class="punctuation" id="L4503">4503
</span><span class="punctuation" id="L4504">4504
</span><span class="punctuation" id="L4505">4505
</span><span class="punctuation" id="L4506">4506
</span><span class="punctuation" id="L4507">4507
</span><span class="punctuation" id="L4508">4508
</span><span class="punctuation" id="L4509">4509
</span><span class="punctuation" id="L4510">4510
</span><span class="punctuation" id="L4511">4511
</span><span class="punctuation" id="L4512">4512
</span><span class="punctuation" id="L4513">4513
</span><span class="punctuation" id="L4514">4514
</span><span class="punctuation" id="L4515">4515
</span><span class="punctuation" id="L4516">4516
</span><span class="punctuation" id="L4517">4517
</span><span class="punctuation" id="L4518">4518
</span><span class="punctuation" id="L4519">4519
</span><span class="punctuation" id="L4520">4520
</span><span class="punctuation" id="L4521">4521
</span><span class="punctuation" id="L4522">4522
</span><span class="punctuation" id="L4523">4523
</span><span class="punctuation" id="L4524">4524
</span><span class="punctuation" id="L4525">4525
</span><span class="punctuation" id="L4526">4526
</span><span class="punctuation" id="L4527">4527
</span><span class="punctuation" id="L4528">4528
</span><span class="punctuation" id="L4529">4529
</span><span class="punctuation" id="L4530">4530
</span><span class="punctuation" id="L4531">4531
</span><span class="punctuation" id="L4532">4532
</span><span class="punctuation" id="L4533">4533
</span><span class="punctuation" id="L4534">4534
</span><span class="punctuation" id="L4535">4535
</span><span class="punctuation" id="L4536">4536
</span><span class="punctuation" id="L4537">4537
</span><span class="punctuation" id="L4538">4538
</span><span class="punctuation" id="L4539">4539
</span><span class="punctuation" id="L4540">4540
</span><span class="punctuation" id="L4541">4541
</span><span class="punctuation" id="L4542">4542
</span><span class="punctuation" id="L4543">4543
</span><span class="punctuation" id="L4544">4544
</span><span class="punctuation" id="L4545">4545
</span><span class="punctuation" id="L4546">4546
</span><span class="punctuation" id="L4547">4547
</span><span class="punctuation" id="L4548">4548
</span><span class="punctuation" id="L4549">4549
</span><span class="punctuation" id="L4550">4550
</span><span class="punctuation" id="L4551">4551
</span><span class="punctuation" id="L4552">4552
</span><span class="punctuation" id="L4553">4553
</span><span class="punctuation" id="L4554">4554
</span><span class="punctuation" id="L4555">4555
</span><span class="punctuation" id="L4556">4556
</span><span class="punctuation" id="L4557">4557
</span><span class="punctuation" id="L4558">4558
</span><span class="punctuation" id="L4559">4559
</span><span class="punctuation" id="L4560">4560
</span><span class="punctuation" id="L4561">4561
</span><span class="punctuation" id="L4562">4562
</span><span class="punctuation" id="L4563">4563
</span><span class="punctuation" id="L4564">4564
</span><span class="punctuation" id="L4565">4565
</span><span class="punctuation" id="L4566">4566
</span><span class="punctuation" id="L4567">4567
</span><span class="punctuation" id="L4568">4568
</span><span class="punctuation" id="L4569">4569
</span><span class="punctuation" id="L4570">4570
</span><span class="punctuation" id="L4571">4571
</span><span class="punctuation" id="L4572">4572
</span><span class="punctuation" id="L4573">4573
</span><span class="punctuation" id="L4574">4574
</span><span class="punctuation" id="L4575">4575
</span><span class="punctuation" id="L4576">4576
</span><span class="punctuation" id="L4577">4577
</span><span class="punctuation" id="L4578">4578
</span><span class="punctuation" id="L4579">4579
</span><span class="punctuation" id="L4580">4580
</span><span class="punctuation" id="L4581">4581
</span><span class="punctuation" id="L4582">4582
</span><span class="punctuation" id="L4583">4583
</span><span class="punctuation" id="L4584">4584
</span><span class="punctuation" id="L4585">4585
</span><span class="punctuation" id="L4586">4586
</span><span class="punctuation" id="L4587">4587
</span><span class="punctuation" id="L4588">4588
</span><span class="punctuation" id="L4589">4589
</span><span class="punctuation" id="L4590">4590
</span><span class="punctuation" id="L4591">4591
</span><span class="punctuation" id="L4592">4592
</span><span class="punctuation" id="L4593">4593
</span><span class="punctuation" id="L4594">4594
</span><span class="punctuation" id="L4595">4595
</span><span class="punctuation" id="L4596">4596
</span><span class="punctuation" id="L4597">4597
</span><span class="punctuation" id="L4598">4598
</span><span class="punctuation" id="L4599">4599
</span><span class="punctuation" id="L4600">4600
</span><span class="punctuation" id="L4601">4601
</span><span class="punctuation" id="L4602">4602
</span><span class="punctuation" id="L4603">4603
</span><span class="punctuation" id="L4604">4604
</span><span class="punctuation" id="L4605">4605
</span><span class="punctuation" id="L4606">4606
</span><span class="punctuation" id="L4607">4607
</span><span class="punctuation" id="L4608">4608
</span><span class="punctuation" id="L4609">4609
</span><span class="punctuation" id="L4610">4610
</span><span class="punctuation" id="L4611">4611
</span><span class="punctuation" id="L4612">4612
</span><span class="punctuation" id="L4613">4613
</span><span class="punctuation" id="L4614">4614
</span><span class="punctuation" id="L4615">4615
</span><span class="punctuation" id="L4616">4616
</span><span class="punctuation" id="L4617">4617
</span><span class="punctuation" id="L4618">4618
</span><span class="punctuation" id="L4619">4619
</span><span class="punctuation" id="L4620">4620
</span><span class="punctuation" id="L4621">4621
</span><span class="punctuation" id="L4622">4622
</span><span class="punctuation" id="L4623">4623
</span><span class="punctuation" id="L4624">4624
</span><span class="punctuation" id="L4625">4625
</span><span class="punctuation" id="L4626">4626
</span><span class="punctuation" id="L4627">4627
</span><span class="punctuation" id="L4628">4628
</span><span class="punctuation" id="L4629">4629
</span><span class="punctuation" id="L4630">4630
</span><span class="punctuation" id="L4631">4631
</span><span class="punctuation" id="L4632">4632
</span><span class="punctuation" id="L4633">4633
</span><span class="punctuation" id="L4634">4634
</span><span class="punctuation" id="L4635">4635
</span><span class="punctuation" id="L4636">4636
</span><span class="punctuation" id="L4637">4637
</span><span class="punctuation" id="L4638">4638
</span><span class="punctuation" id="L4639">4639
</span><span class="punctuation" id="L4640">4640
</span><span class="punctuation" id="L4641">4641
</span><span class="punctuation" id="L4642">4642
</span><span class="punctuation" id="L4643">4643
</span><span class="punctuation" id="L4644">4644
</span><span class="punctuation" id="L4645">4645
</span><span class="punctuation" id="L4646">4646
</span><span class="punctuation" id="L4647">4647
</span><span class="punctuation" id="L4648">4648
</span><span class="punctuation" id="L4649">4649
</span><span class="punctuation" id="L4650">4650
</span><span class="punctuation" id="L4651">4651
</span><span class="punctuation" id="L4652">4652
</span><span class="punctuation" id="L4653">4653
</span><span class="punctuation" id="L4654">4654
</span><span class="punctuation" id="L4655">4655
</span><span class="punctuation" id="L4656">4656
</span><span class="punctuation" id="L4657">4657
</span><span class="punctuation" id="L4658">4658
</span><span class="punctuation" id="L4659">4659
</span><span class="punctuation" id="L4660">4660
</span><span class="punctuation" id="L4661">4661
</span><span class="punctuation" id="L4662">4662
</span><span class="punctuation" id="L4663">4663
</span><span class="punctuation" id="L4664">4664
</span><span class="punctuation" id="L4665">4665
</span><span class="punctuation" id="L4666">4666
</span><span class="punctuation" id="L4667">4667
</span><span class="punctuation" id="L4668">4668
</span><span class="punctuation" id="L4669">4669
</span><span class="punctuation" id="L4670">4670
</span><span class="punctuation" id="L4671">4671
</span><span class="punctuation" id="L4672">4672
</span><span class="punctuation" id="L4673">4673
</span><span class="punctuation" id="L4674">4674
</span><span class="punctuation" id="L4675">4675
</span><span class="punctuation" id="L4676">4676
</span><span class="punctuation" id="L4677">4677
</span><span class="punctuation" id="L4678">4678
</span><span class="punctuation" id="L4679">4679
</span><span class="punctuation" id="L4680">4680
</span><span class="punctuation" id="L4681">4681
</span><span class="punctuation" id="L4682">4682
</span><span class="punctuation" id="L4683">4683
</span><span class="punctuation" id="L4684">4684
</span><span class="punctuation" id="L4685">4685
</span><span class="punctuation" id="L4686">4686
</span><span class="punctuation" id="L4687">4687
</span><span class="punctuation" id="L4688">4688
</span><span class="punctuation" id="L4689">4689
</span><span class="punctuation" id="L4690">4690
</span><span class="punctuation" id="L4691">4691
</span><span class="punctuation" id="L4692">4692
</span><span class="punctuation" id="L4693">4693
</span><span class="punctuation" id="L4694">4694
</span><span class="punctuation" id="L4695">4695
</span><span class="punctuation" id="L4696">4696
</span><span class="punctuation" id="L4697">4697
</span><span class="punctuation" id="L4698">4698
</span><span class="punctuation" id="L4699">4699
</span><span class="punctuation" id="L4700">4700
</span><span class="punctuation" id="L4701">4701
</span><span class="punctuation" id="L4702">4702
</span><span class="punctuation" id="L4703">4703
</span><span class="punctuation" id="L4704">4704
</span><span class="punctuation" id="L4705">4705
</span><span class="punctuation" id="L4706">4706
</span><span class="punctuation" id="L4707">4707
</span><span class="punctuation" id="L4708">4708
</span><span class="punctuation" id="L4709">4709
</span><span class="punctuation" id="L4710">4710
</span><span class="punctuation" id="L4711">4711
</span><span class="punctuation" id="L4712">4712
</span><span class="punctuation" id="L4713">4713
</span><span class="punctuation" id="L4714">4714
</span><span class="punctuation" id="L4715">4715
</span><span class="punctuation" id="L4716">4716
</span><span class="punctuation" id="L4717">4717
</span><span class="punctuation" id="L4718">4718
</span><span class="punctuation" id="L4719">4719
</span><span class="punctuation" id="L4720">4720
</span><span class="punctuation" id="L4721">4721
</span><span class="punctuation" id="L4722">4722
</span><span class="punctuation" id="L4723">4723
</span><span class="punctuation" id="L4724">4724
</span><span class="punctuation" id="L4725">4725
</span><span class="punctuation" id="L4726">4726
</span><span class="punctuation" id="L4727">4727
</span><span class="punctuation" id="L4728">4728
</span><span class="punctuation" id="L4729">4729
</span><span class="punctuation" id="L4730">4730
</span><span class="punctuation" id="L4731">4731
</span><span class="punctuation" id="L4732">4732
</span><span class="punctuation" id="L4733">4733
</span><span class="punctuation" id="L4734">4734
</span><span class="punctuation" id="L4735">4735
</span><span class="punctuation" id="L4736">4736
</span><span class="punctuation" id="L4737">4737
</span><span class="punctuation" id="L4738">4738
</span><span class="punctuation" id="L4739">4739
</span><span class="punctuation" id="L4740">4740
</span><span class="punctuation" id="L4741">4741
</span><span class="punctuation" id="L4742">4742
</span><span class="punctuation" id="L4743">4743
</span><span class="punctuation" id="L4744">4744
</span><span class="punctuation" id="L4745">4745
</span><span class="punctuation" id="L4746">4746
</span><span class="punctuation" id="L4747">4747
</span><span class="punctuation" id="L4748">4748
</span><span class="punctuation" id="L4749">4749
</span><span class="punctuation" id="L4750">4750
</span><span class="punctuation" id="L4751">4751
</span><span class="punctuation" id="L4752">4752
</span><span class="punctuation" id="L4753">4753
</span><span class="punctuation" id="L4754">4754
</span><span class="punctuation" id="L4755">4755
</span><span class="punctuation" id="L4756">4756
</span><span class="punctuation" id="L4757">4757
</span><span class="punctuation" id="L4758">4758
</span><span class="punctuation" id="L4759">4759
</span><span class="punctuation" id="L4760">4760
</span><span class="punctuation" id="L4761">4761
</span><span class="punctuation" id="L4762">4762
</span><span class="punctuation" id="L4763">4763
</span><span class="punctuation" id="L4764">4764
</span><span class="punctuation" id="L4765">4765
</span><span class="punctuation" id="L4766">4766
</span><span class="punctuation" id="L4767">4767
</span><span class="punctuation" id="L4768">4768
</span><span class="punctuation" id="L4769">4769
</span><span class="punctuation" id="L4770">4770
</span><span class="punctuation" id="L4771">4771
</span><span class="punctuation" id="L4772">4772
</span><span class="punctuation" id="L4773">4773
</span><span class="punctuation" id="L4774">4774
</span><span class="punctuation" id="L4775">4775
</span><span class="punctuation" id="L4776">4776
</span><span class="punctuation" id="L4777">4777
</span><span class="punctuation" id="L4778">4778
</span><span class="punctuation" id="L4779">4779
</span><span class="punctuation" id="L4780">4780
</span><span class="punctuation" id="L4781">4781
</span><span class="punctuation" id="L4782">4782
</span><span class="punctuation" id="L4783">4783
</span><span class="punctuation" id="L4784">4784
</span><span class="punctuation" id="L4785">4785
</span><span class="punctuation" id="L4786">4786
</span><span class="punctuation" id="L4787">4787
</span><span class="punctuation" id="L4788">4788
</span><span class="punctuation" id="L4789">4789
</span><span class="punctuation" id="L4790">4790
</span><span class="punctuation" id="L4791">4791
</span><span class="punctuation" id="L4792">4792
</span><span class="punctuation" id="L4793">4793
</span><span class="punctuation" id="L4794">4794
</span><span class="punctuation" id="L4795">4795
</span><span class="punctuation" id="L4796">4796
</span><span class="punctuation" id="L4797">4797
</span><span class="punctuation" id="L4798">4798
</span><span class="punctuation" id="L4799">4799
</span><span class="punctuation" id="L4800">4800
</span><span class="punctuation" id="L4801">4801
</span><span class="punctuation" id="L4802">4802
</span><span class="punctuation" id="L4803">4803
</span><span class="punctuation" id="L4804">4804
</span><span class="punctuation" id="L4805">4805
</span><span class="punctuation" id="L4806">4806
</span><span class="punctuation" id="L4807">4807
</span><span class="punctuation" id="L4808">4808
</span><span class="punctuation" id="L4809">4809
</span><span class="punctuation" id="L4810">4810
</span><span class="punctuation" id="L4811">4811
</span><span class="punctuation" id="L4812">4812
</span><span class="punctuation" id="L4813">4813
</span><span class="punctuation" id="L4814">4814
</span><span class="punctuation" id="L4815">4815
</span><span class="punctuation" id="L4816">4816
</span><span class="punctuation" id="L4817">4817
</span><span class="punctuation" id="L4818">4818
</span><span class="punctuation" id="L4819">4819
</span><span class="punctuation" id="L4820">4820
</span><span class="punctuation" id="L4821">4821
</span><span class="punctuation" id="L4822">4822
</span><span class="punctuation" id="L4823">4823
</span><span class="punctuation" id="L4824">4824
</span><span class="punctuation" id="L4825">4825
</span><span class="punctuation" id="L4826">4826
</span><span class="punctuation" id="L4827">4827
</span><span class="punctuation" id="L4828">4828
</span><span class="punctuation" id="L4829">4829
</span><span class="punctuation" id="L4830">4830
</span><span class="punctuation" id="L4831">4831
</span><span class="punctuation" id="L4832">4832
</span><span class="punctuation" id="L4833">4833
</span><span class="punctuation" id="L4834">4834
</span><span class="punctuation" id="L4835">4835
</span><span class="punctuation" id="L4836">4836
</span><span class="punctuation" id="L4837">4837
</span><span class="punctuation" id="L4838">4838
</span><span class="punctuation" id="L4839">4839
</span><span class="punctuation" id="L4840">4840
</span><span class="punctuation" id="L4841">4841
</span><span class="punctuation" id="L4842">4842
</span><span class="punctuation" id="L4843">4843
</span><span class="punctuation" id="L4844">4844
</span><span class="punctuation" id="L4845">4845
</span><span class="punctuation" id="L4846">4846
</span><span class="punctuation" id="L4847">4847
</span><span class="punctuation" id="L4848">4848
</span><span class="punctuation" id="L4849">4849
</span><span class="punctuation" id="L4850">4850
</span><span class="punctuation" id="L4851">4851
</span><span class="punctuation" id="L4852">4852
</span><span class="punctuation" id="L4853">4853
</span><span class="punctuation" id="L4854">4854
</span><span class="punctuation" id="L4855">4855
</span><span class="punctuation" id="L4856">4856
</span><span class="punctuation" id="L4857">4857
</span><span class="punctuation" id="L4858">4858
</span><span class="punctuation" id="L4859">4859
</span><span class="punctuation" id="L4860">4860
</span><span class="punctuation" id="L4861">4861
</span><span class="punctuation" id="L4862">4862
</span><span class="punctuation" id="L4863">4863
</span><span class="punctuation" id="L4864">4864
</span><span class="punctuation" id="L4865">4865
</span><span class="punctuation" id="L4866">4866
</span><span class="punctuation" id="L4867">4867
</span><span class="punctuation" id="L4868">4868
</span><span class="punctuation" id="L4869">4869
</span><span class="punctuation" id="L4870">4870
</span><span class="punctuation" id="L4871">4871
</span><span class="punctuation" id="L4872">4872
</span><span class="punctuation" id="L4873">4873
</span><span class="punctuation" id="L4874">4874
</span><span class="punctuation" id="L4875">4875
</span><span class="punctuation" id="L4876">4876
</span><span class="punctuation" id="L4877">4877
</span><span class="punctuation" id="L4878">4878
</span><span class="punctuation" id="L4879">4879
</span><span class="punctuation" id="L4880">4880
</span><span class="punctuation" id="L4881">4881
</span><span class="punctuation" id="L4882">4882
</span><span class="punctuation" id="L4883">4883
</span><span class="punctuation" id="L4884">4884
</span><span class="punctuation" id="L4885">4885
</span><span class="punctuation" id="L4886">4886
</span><span class="punctuation" id="L4887">4887
</span><span class="punctuation" id="L4888">4888
</span><span class="punctuation" id="L4889">4889
</span><span class="punctuation" id="L4890">4890
</span><span class="punctuation" id="L4891">4891
</span><span class="punctuation" id="L4892">4892
</span><span class="punctuation" id="L4893">4893
</span><span class="punctuation" id="L4894">4894
</span><span class="punctuation" id="L4895">4895
</span><span class="punctuation" id="L4896">4896
</span><span class="punctuation" id="L4897">4897
</span><span class="punctuation" id="L4898">4898
</span><span class="punctuation" id="L4899">4899
</span><span class="punctuation" id="L4900">4900
</span><span class="punctuation" id="L4901">4901
</span><span class="punctuation" id="L4902">4902
</span><span class="punctuation" id="L4903">4903
</span><span class="punctuation" id="L4904">4904
</span><span class="punctuation" id="L4905">4905
</span><span class="punctuation" id="L4906">4906
</span><span class="punctuation" id="L4907">4907
</span><span class="punctuation" id="L4908">4908
</span><span class="punctuation" id="L4909">4909
</span><span class="punctuation" id="L4910">4910
</span><span class="punctuation" id="L4911">4911
</span><span class="punctuation" id="L4912">4912
</span><span class="punctuation" id="L4913">4913
</span><span class="punctuation" id="L4914">4914
</span><span class="punctuation" id="L4915">4915
</span><span class="punctuation" id="L4916">4916
</span><span class="punctuation" id="L4917">4917
</span><span class="punctuation" id="L4918">4918
</span><span class="punctuation" id="L4919">4919
</span><span class="punctuation" id="L4920">4920
</span><span class="punctuation" id="L4921">4921
</span><span class="punctuation" id="L4922">4922
</span><span class="punctuation" id="L4923">4923
</span><span class="punctuation" id="L4924">4924
</span><span class="punctuation" id="L4925">4925
</span><span class="punctuation" id="L4926">4926
</span><span class="punctuation" id="L4927">4927
</span><span class="punctuation" id="L4928">4928
</span><span class="punctuation" id="L4929">4929
</span><span class="punctuation" id="L4930">4930
</span><span class="punctuation" id="L4931">4931
</span><span class="punctuation" id="L4932">4932
</span><span class="punctuation" id="L4933">4933
</span><span class="punctuation" id="L4934">4934
</span><span class="punctuation" id="L4935">4935
</span><span class="punctuation" id="L4936">4936
</span><span class="punctuation" id="L4937">4937
</span><span class="punctuation" id="L4938">4938
</span><span class="punctuation" id="L4939">4939
</span><span class="punctuation" id="L4940">4940
</span><span class="punctuation" id="L4941">4941
</span><span class="punctuation" id="L4942">4942
</span><span class="punctuation" id="L4943">4943
</span><span class="punctuation" id="L4944">4944
</span><span class="punctuation" id="L4945">4945
</span><span class="punctuation" id="L4946">4946
</span><span class="punctuation" id="L4947">4947
</span><span class="punctuation" id="L4948">4948
</span><span class="punctuation" id="L4949">4949
</span><span class="punctuation" id="L4950">4950
</span><span class="punctuation" id="L4951">4951
</span><span class="punctuation" id="L4952">4952
</span><span class="punctuation" id="L4953">4953
</span><span class="punctuation" id="L4954">4954
</span><span class="punctuation" id="L4955">4955
</span><span class="punctuation" id="L4956">4956
</span><span class="punctuation" id="L4957">4957
</span><span class="punctuation" id="L4958">4958
</span><span class="punctuation" id="L4959">4959
</span><span class="punctuation" id="L4960">4960
</span><span class="punctuation" id="L4961">4961
</span><span class="punctuation" id="L4962">4962
</span><span class="punctuation" id="L4963">4963
</span><span class="punctuation" id="L4964">4964
</span><span class="punctuation" id="L4965">4965
</span><span class="punctuation" id="L4966">4966
</span><span class="punctuation" id="L4967">4967
</span><span class="punctuation" id="L4968">4968
</span><span class="punctuation" id="L4969">4969
</span><span class="punctuation" id="L4970">4970
</span><span class="punctuation" id="L4971">4971
</span><span class="punctuation" id="L4972">4972
</span><span class="punctuation" id="L4973">4973
</span><span class="punctuation" id="L4974">4974
</span><span class="punctuation" id="L4975">4975
</span><span class="punctuation" id="L4976">4976
</span><span class="punctuation" id="L4977">4977
</span><span class="punctuation" id="L4978">4978
</span><span class="punctuation" id="L4979">4979
</span><span class="punctuation" id="L4980">4980
</span><span class="punctuation" id="L4981">4981
</span><span class="punctuation" id="L4982">4982
</span><span class="punctuation" id="L4983">4983
</span><span class="punctuation" id="L4984">4984
</span><span class="punctuation" id="L4985">4985
</span><span class="punctuation" id="L4986">4986
</span><span class="punctuation" id="L4987">4987
</span><span class="punctuation" id="L4988">4988
</span><span class="punctuation" id="L4989">4989
</span><span class="punctuation" id="L4990">4990
</span><span class="punctuation" id="L4991">4991
</span><span class="punctuation" id="L4992">4992
</span><span class="punctuation" id="L4993">4993
</span><span class="punctuation" id="L4994">4994
</span><span class="punctuation" id="L4995">4995
</span><span class="punctuation" id="L4996">4996
</span><span class="punctuation" id="L4997">4997
</span><span class="punctuation" id="L4998">4998
</span><span class="punctuation" id="L4999">4999
</span><span class="punctuation" id="L5000">5000
</span><span class="punctuation" id="L5001">5001
</span><span class="punctuation" id="L5002">5002
</span><span class="punctuation" id="L5003">5003
</span><span class="punctuation" id="L5004">5004
</span><span class="punctuation" id="L5005">5005
</span><span class="punctuation" id="L5006">5006
</span><span class="punctuation" id="L5007">5007
</span><span class="punctuation" id="L5008">5008
</span><span class="punctuation" id="L5009">5009
</span><span class="punctuation" id="L5010">5010
</span><span class="punctuation" id="L5011">5011
</span><span class="punctuation" id="L5012">5012
</span><span class="punctuation" id="L5013">5013
</span><span class="punctuation" id="L5014">5014
</span><span class="punctuation" id="L5015">5015
</span><span class="punctuation" id="L5016">5016
</span><span class="punctuation" id="L5017">5017
</span><span class="punctuation" id="L5018">5018
</span><span class="punctuation" id="L5019">5019
</span><span class="punctuation" id="L5020">5020
</span><span class="punctuation" id="L5021">5021
</span><span class="punctuation" id="L5022">5022
</span><span class="punctuation" id="L5023">5023
</span><span class="punctuation" id="L5024">5024
</span><span class="punctuation" id="L5025">5025
</span><span class="punctuation" id="L5026">5026
</span><span class="punctuation" id="L5027">5027
</span><span class="punctuation" id="L5028">5028
</span><span class="punctuation" id="L5029">5029
</span><span class="punctuation" id="L5030">5030
</span><span class="punctuation" id="L5031">5031
</span><span class="punctuation" id="L5032">5032
</span><span class="punctuation" id="L5033">5033
</span><span class="punctuation" id="L5034">5034
</span><span class="punctuation" id="L5035">5035
</span><span class="punctuation" id="L5036">5036
</span><span class="punctuation" id="L5037">5037
</span><span class="punctuation" id="L5038">5038
</span><span class="punctuation" id="L5039">5039
</span><span class="punctuation" id="L5040">5040
</span><span class="punctuation" id="L5041">5041
</span><span class="punctuation" id="L5042">5042
</span><span class="punctuation" id="L5043">5043
</span><span class="punctuation" id="L5044">5044
</span><span class="punctuation" id="L5045">5045
</span><span class="punctuation" id="L5046">5046
</span><span class="punctuation" id="L5047">5047
</span><span class="punctuation" id="L5048">5048
</span><span class="punctuation" id="L5049">5049
</span><span class="punctuation" id="L5050">5050
</span><span class="punctuation" id="L5051">5051
</span><span class="punctuation" id="L5052">5052
</span><span class="punctuation" id="L5053">5053
</span><span class="punctuation" id="L5054">5054
</span><span class="punctuation" id="L5055">5055
</span><span class="punctuation" id="L5056">5056
</span><span class="punctuation" id="L5057">5057
</span><span class="punctuation" id="L5058">5058
</span><span class="punctuation" id="L5059">5059
</span><span class="punctuation" id="L5060">5060
</span><span class="punctuation" id="L5061">5061
</span><span class="punctuation" id="L5062">5062
</span><span class="punctuation" id="L5063">5063
</span><span class="punctuation" id="L5064">5064
</span><span class="punctuation" id="L5065">5065
</span><span class="punctuation" id="L5066">5066
</span><span class="punctuation" id="L5067">5067
</span><span class="punctuation" id="L5068">5068
</span><span class="punctuation" id="L5069">5069
</span><span class="punctuation" id="L5070">5070
</span><span class="punctuation" id="L5071">5071
</span><span class="punctuation" id="L5072">5072
</span><span class="punctuation" id="L5073">5073
</span><span class="punctuation" id="L5074">5074
</span><span class="punctuation" id="L5075">5075
</span><span class="punctuation" id="L5076">5076
</span><span class="punctuation" id="L5077">5077
</span><span class="punctuation" id="L5078">5078
</span><span class="punctuation" id="L5079">5079
</span><span class="punctuation" id="L5080">5080
</span><span class="punctuation" id="L5081">5081
</span><span class="punctuation" id="L5082">5082
</span><span class="punctuation" id="L5083">5083
</span><span class="punctuation" id="L5084">5084
</span><span class="punctuation" id="L5085">5085
</span><span class="punctuation" id="L5086">5086
</span><span class="punctuation" id="L5087">5087
</span><span class="punctuation" id="L5088">5088
</span><span class="punctuation" id="L5089">5089
</span><span class="punctuation" id="L5090">5090
</span><span class="punctuation" id="L5091">5091
</span><span class="punctuation" id="L5092">5092
</span><span class="punctuation" id="L5093">5093
</span><span class="punctuation" id="L5094">5094
</span><span class="punctuation" id="L5095">5095
</span><span class="punctuation" id="L5096">5096
</span><span class="punctuation" id="L5097">5097
</span><span class="punctuation" id="L5098">5098
</span><span class="punctuation" id="L5099">5099
</span><span class="punctuation" id="L5100">5100
</span><span class="punctuation" id="L5101">5101
</span><span class="punctuation" id="L5102">5102
</span><span class="punctuation" id="L5103">5103
</span><span class="punctuation" id="L5104">5104
</span><span class="punctuation" id="L5105">5105
</span><span class="punctuation" id="L5106">5106
</span><span class="punctuation" id="L5107">5107
</span><span class="punctuation" id="L5108">5108
</span><span class="punctuation" id="L5109">5109
</span><span class="punctuation" id="L5110">5110
</span><span class="punctuation" id="L5111">5111
</span><span class="punctuation" id="L5112">5112
</span><span class="punctuation" id="L5113">5113
</span><span class="punctuation" id="L5114">5114
</span><span class="punctuation" id="L5115">5115
</span><span class="punctuation" id="L5116">5116
</span><span class="punctuation" id="L5117">5117
</span><span class="punctuation" id="L5118">5118
</span><span class="punctuation" id="L5119">5119
</span><span class="punctuation" id="L5120">5120
</span><span class="punctuation" id="L5121">5121
</span><span class="punctuation" id="L5122">5122
</span><span class="punctuation" id="L5123">5123
</span><span class="punctuation" id="L5124">5124
</span><span class="punctuation" id="L5125">5125
</span><span class="punctuation" id="L5126">5126
</span><span class="punctuation" id="L5127">5127
</span><span class="punctuation" id="L5128">5128
</span><span class="punctuation" id="L5129">5129
</span><span class="punctuation" id="L5130">5130
</span><span class="punctuation" id="L5131">5131
</span><span class="punctuation" id="L5132">5132
</span><span class="punctuation" id="L5133">5133
</span><span class="punctuation" id="L5134">5134
</span><span class="punctuation" id="L5135">5135
</span><span class="punctuation" id="L5136">5136
</span><span class="punctuation" id="L5137">5137
</span><span class="punctuation" id="L5138">5138
</span><span class="punctuation" id="L5139">5139
</span><span class="punctuation" id="L5140">5140
</span><span class="punctuation" id="L5141">5141
</span><span class="punctuation" id="L5142">5142
</span><span class="punctuation" id="L5143">5143
</span><span class="punctuation" id="L5144">5144
</span><span class="punctuation" id="L5145">5145
</span><span class="punctuation" id="L5146">5146
</span><span class="punctuation" id="L5147">5147
</span><span class="punctuation" id="L5148">5148
</span><span class="punctuation" id="L5149">5149
</span><span class="punctuation" id="L5150">5150
</span><span class="punctuation" id="L5151">5151
</span><span class="punctuation" id="L5152">5152
</span><span class="punctuation" id="L5153">5153
</span><span class="punctuation" id="L5154">5154
</span><span class="punctuation" id="L5155">5155
</span><span class="punctuation" id="L5156">5156
</span><span class="punctuation" id="L5157">5157
</span><span class="punctuation" id="L5158">5158
</span><span class="punctuation" id="L5159">5159
</span><span class="punctuation" id="L5160">5160
</span><span class="punctuation" id="L5161">5161
</span><span class="punctuation" id="L5162">5162
</span><span class="punctuation" id="L5163">5163
</span><span class="punctuation" id="L5164">5164
</span><span class="punctuation" id="L5165">5165
</span><span class="punctuation" id="L5166">5166
</span><span class="punctuation" id="L5167">5167
</span><span class="punctuation" id="L5168">5168
</span><span class="punctuation" id="L5169">5169
</span><span class="punctuation" id="L5170">5170
</span><span class="punctuation" id="L5171">5171
</span><span class="punctuation" id="L5172">5172
</span><span class="punctuation" id="L5173">5173
</span><span class="punctuation" id="L5174">5174
</span><span class="punctuation" id="L5175">5175
</span><span class="punctuation" id="L5176">5176
</span><span class="punctuation" id="L5177">5177
</span><span class="punctuation" id="L5178">5178
</span><span class="punctuation" id="L5179">5179
</span><span class="punctuation" id="L5180">5180
</span><span class="punctuation" id="L5181">5181
</span><span class="punctuation" id="L5182">5182
</span><span class="punctuation" id="L5183">5183
</span><span class="punctuation" id="L5184">5184
</span><span class="punctuation" id="L5185">5185
</span><span class="punctuation" id="L5186">5186
</span><span class="punctuation" id="L5187">5187
</span><span class="punctuation" id="L5188">5188
</span><span class="punctuation" id="L5189">5189
</span><span class="punctuation" id="L5190">5190
</span><span class="punctuation" id="L5191">5191
</span><span class="punctuation" id="L5192">5192
</span><span class="punctuation" id="L5193">5193
</span><span class="punctuation" id="L5194">5194
</span><span class="punctuation" id="L5195">5195
</span><span class="punctuation" id="L5196">5196
</span><span class="punctuation" id="L5197">5197
</span><span class="punctuation" id="L5198">5198
</span><span class="punctuation" id="L5199">5199
</span><span class="punctuation" id="L5200">5200
</span><span class="punctuation" id="L5201">5201
</span><span class="punctuation" id="L5202">5202
</span><span class="punctuation" id="L5203">5203
</span><span class="punctuation" id="L5204">5204
</span><span class="punctuation" id="L5205">5205
</span><span class="punctuation" id="L5206">5206
</span><span class="punctuation" id="L5207">5207
</span><span class="punctuation" id="L5208">5208
</span><span class="punctuation" id="L5209">5209
</span><span class="punctuation" id="L5210">5210
</span><span class="punctuation" id="L5211">5211
</span><span class="punctuation" id="L5212">5212
</span><span class="punctuation" id="L5213">5213
</span><span class="punctuation" id="L5214">5214
</span><span class="punctuation" id="L5215">5215
</span><span class="punctuation" id="L5216">5216
</span><span class="punctuation" id="L5217">5217
</span><span class="punctuation" id="L5218">5218
</span><span class="punctuation" id="L5219">5219
</span><span class="punctuation" id="L5220">5220
</span><span class="punctuation" id="L5221">5221
</span><span class="punctuation" id="L5222">5222
</span><span class="punctuation" id="L5223">5223
</span><span class="punctuation" id="L5224">5224
</span><span class="punctuation" id="L5225">5225
</span><span class="punctuation" id="L5226">5226
</span><span class="punctuation" id="L5227">5227
</span><span class="punctuation" id="L5228">5228
</span><span class="punctuation" id="L5229">5229
</span><span class="punctuation" id="L5230">5230
</span><span class="punctuation" id="L5231">5231
</span><span class="punctuation" id="L5232">5232
</span><span class="punctuation" id="L5233">5233
</span><span class="punctuation" id="L5234">5234
</span><span class="punctuation" id="L5235">5235
</span><span class="punctuation" id="L5236">5236
</span><span class="punctuation" id="L5237">5237
</span><span class="punctuation" id="L5238">5238
</span><span class="punctuation" id="L5239">5239
</span><span class="punctuation" id="L5240">5240
</span><span class="punctuation" id="L5241">5241
</span><span class="punctuation" id="L5242">5242
</span><span class="punctuation" id="L5243">5243
</span><span class="punctuation" id="L5244">5244
</span><span class="punctuation" id="L5245">5245
</span><span class="punctuation" id="L5246">5246
</span><span class="punctuation" id="L5247">5247
</span><span class="punctuation" id="L5248">5248
</span><span class="punctuation" id="L5249">5249
</span><span class="punctuation" id="L5250">5250
</span><span class="punctuation" id="L5251">5251
</span><span class="punctuation" id="L5252">5252
</span><span class="punctuation" id="L5253">5253
</span><span class="punctuation" id="L5254">5254
</span><span class="punctuation" id="L5255">5255
</span><span class="punctuation" id="L5256">5256
</span><span class="punctuation" id="L5257">5257
</span><span class="punctuation" id="L5258">5258
</span><span class="punctuation" id="L5259">5259
</span><span class="punctuation" id="L5260">5260
</span><span class="punctuation" id="L5261">5261
</span><span class="punctuation" id="L5262">5262
</span><span class="punctuation" id="L5263">5263
</span><span class="punctuation" id="L5264">5264
</span><span class="punctuation" id="L5265">5265
</span><span class="punctuation" id="L5266">5266
</span><span class="punctuation" id="L5267">5267
</span><span class="punctuation" id="L5268">5268
</span><span class="punctuation" id="L5269">5269
</span><span class="punctuation" id="L5270">5270
</span><span class="punctuation" id="L5271">5271
</span><span class="punctuation" id="L5272">5272
</span><span class="punctuation" id="L5273">5273
</span><span class="punctuation" id="L5274">5274
</span><span class="punctuation" id="L5275">5275
</span><span class="punctuation" id="L5276">5276
</span><span class="punctuation" id="L5277">5277
</span><span class="punctuation" id="L5278">5278
</span><span class="punctuation" id="L5279">5279
</span><span class="punctuation" id="L5280">5280
</span><span class="punctuation" id="L5281">5281
</span><span class="punctuation" id="L5282">5282
</span><span class="punctuation" id="L5283">5283
</span><span class="punctuation" id="L5284">5284
</span><span class="punctuation" id="L5285">5285
</span><span class="punctuation" id="L5286">5286
</span><span class="punctuation" id="L5287">5287
</span><span class="punctuation" id="L5288">5288
</span><span class="punctuation" id="L5289">5289
</span><span class="punctuation" id="L5290">5290
</span><span class="punctuation" id="L5291">5291
</span><span class="punctuation" id="L5292">5292
</span><span class="punctuation" id="L5293">5293
</span><span class="punctuation" id="L5294">5294
</span><span class="punctuation" id="L5295">5295
</span><span class="punctuation" id="L5296">5296
</span><span class="punctuation" id="L5297">5297
</span><span class="punctuation" id="L5298">5298
</span><span class="punctuation" id="L5299">5299
</span><span class="punctuation" id="L5300">5300
</span><span class="punctuation" id="L5301">5301
</span><span class="punctuation" id="L5302">5302
</span><span class="punctuation" id="L5303">5303
</span><span class="punctuation" id="L5304">5304
</span><span class="punctuation" id="L5305">5305
</span><span class="punctuation" id="L5306">5306
</span><span class="punctuation" id="L5307">5307
</span><span class="punctuation" id="L5308">5308
</span><span class="punctuation" id="L5309">5309
</span><span class="punctuation" id="L5310">5310
</span><span class="punctuation" id="L5311">5311
</span><span class="punctuation" id="L5312">5312
</span><span class="punctuation" id="L5313">5313
</span><span class="punctuation" id="L5314">5314
</span><span class="punctuation" id="L5315">5315
</span><span class="punctuation" id="L5316">5316
</span><span class="punctuation" id="L5317">5317
</span><span class="punctuation" id="L5318">5318
</span><span class="punctuation" id="L5319">5319
</span><span class="punctuation" id="L5320">5320
</span><span class="punctuation" id="L5321">5321
</span><span class="punctuation" id="L5322">5322
</span><span class="punctuation" id="L5323">5323
</span><span class="punctuation" id="L5324">5324
</span><span class="punctuation" id="L5325">5325
</span><span class="punctuation" id="L5326">5326
</span><span class="punctuation" id="L5327">5327
</span><span class="punctuation" id="L5328">5328
</span><span class="punctuation" id="L5329">5329
</span><span class="punctuation" id="L5330">5330
</span><span class="punctuation" id="L5331">5331
</span><span class="punctuation" id="L5332">5332
</span><span class="punctuation" id="L5333">5333
</span><span class="punctuation" id="L5334">5334
</span><span class="punctuation" id="L5335">5335
</span><span class="punctuation" id="L5336">5336
</span><span class="punctuation" id="L5337">5337
</span><span class="punctuation" id="L5338">5338
</span><span class="punctuation" id="L5339">5339
</span><span class="punctuation" id="L5340">5340
</span><span class="punctuation" id="L5341">5341
</span><span class="punctuation" id="L5342">5342
</span><span class="punctuation" id="L5343">5343
</span><span class="punctuation" id="L5344">5344
</span><span class="punctuation" id="L5345">5345
</span><span class="punctuation" id="L5346">5346
</span><span class="punctuation" id="L5347">5347
</span><span class="punctuation" id="L5348">5348
</span><span class="punctuation" id="L5349">5349
</span><span class="punctuation" id="L5350">5350
</span><span class="punctuation" id="L5351">5351
</span><span class="punctuation" id="L5352">5352
</span><span class="punctuation" id="L5353">5353
</span><span class="punctuation" id="L5354">5354
</span><span class="punctuation" id="L5355">5355
</span><span class="punctuation" id="L5356">5356
</span><span class="punctuation" id="L5357">5357
</span><span class="punctuation" id="L5358">5358
</span><span class="punctuation" id="L5359">5359
</span><span class="punctuation" id="L5360">5360
</span><span class="punctuation" id="L5361">5361
</span><span class="punctuation" id="L5362">5362
</span><span class="punctuation" id="L5363">5363
</span><span class="punctuation" id="L5364">5364
</span><span class="punctuation" id="L5365">5365
</span><span class="punctuation" id="L5366">5366
</span><span class="punctuation" id="L5367">5367
</span><span class="punctuation" id="L5368">5368
</span><span class="punctuation" id="L5369">5369
</span><span class="punctuation" id="L5370">5370
</span><span class="punctuation" id="L5371">5371
</span><span class="punctuation" id="L5372">5372
</span><span class="punctuation" id="L5373">5373
</span><span class="punctuation" id="L5374">5374
</span><span class="punctuation" id="L5375">5375
</span><span class="punctuation" id="L5376">5376
</span><span class="punctuation" id="L5377">5377
</span><span class="punctuation" id="L5378">5378
</span><span class="punctuation" id="L5379">5379
</span><span class="punctuation" id="L5380">5380
</span><span class="punctuation" id="L5381">5381
</span><span class="punctuation" id="L5382">5382
</span><span class="punctuation" id="L5383">5383
</span><span class="punctuation" id="L5384">5384
</span><span class="punctuation" id="L5385">5385
</span><span class="punctuation" id="L5386">5386
</span><span class="punctuation" id="L5387">5387
</span><span class="punctuation" id="L5388">5388
</span><span class="punctuation" id="L5389">5389
</span><span class="punctuation" id="L5390">5390
</span><span class="punctuation" id="L5391">5391
</span><span class="punctuation" id="L5392">5392
</span><span class="punctuation" id="L5393">5393
</span><span class="punctuation" id="L5394">5394
</span><span class="punctuation" id="L5395">5395
</span><span class="punctuation" id="L5396">5396
</span><span class="punctuation" id="L5397">5397
</span><span class="punctuation" id="L5398">5398
</span><span class="punctuation" id="L5399">5399
</span><span class="punctuation" id="L5400">5400
</span><span class="punctuation" id="L5401">5401
</span><span class="punctuation" id="L5402">5402
</span><span class="punctuation" id="L5403">5403
</span><span class="punctuation" id="L5404">5404
</span><span class="punctuation" id="L5405">5405
</span><span class="punctuation" id="L5406">5406
</span><span class="punctuation" id="L5407">5407
</span><span class="punctuation" id="L5408">5408
</span><span class="punctuation" id="L5409">5409
</span><span class="punctuation" id="L5410">5410
</span><span class="punctuation" id="L5411">5411
</span><span class="punctuation" id="L5412">5412
</span><span class="punctuation" id="L5413">5413
</span><span class="punctuation" id="L5414">5414
</span><span class="punctuation" id="L5415">5415
</span><span class="punctuation" id="L5416">5416
</span><span class="punctuation" id="L5417">5417
</span><span class="punctuation" id="L5418">5418
</span><span class="punctuation" id="L5419">5419
</span><span class="punctuation" id="L5420">5420
</span><span class="punctuation" id="L5421">5421
</span><span class="punctuation" id="L5422">5422
</span><span class="punctuation" id="L5423">5423
</span><span class="punctuation" id="L5424">5424
</span><span class="punctuation" id="L5425">5425
</span><span class="punctuation" id="L5426">5426
</span><span class="punctuation" id="L5427">5427
</span><span class="punctuation" id="L5428">5428
</span><span class="punctuation" id="L5429">5429
</span><span class="punctuation" id="L5430">5430
</span><span class="punctuation" id="L5431">5431
</span><span class="punctuation" id="L5432">5432
</span><span class="punctuation" id="L5433">5433
</span><span class="punctuation" id="L5434">5434
</span><span class="punctuation" id="L5435">5435
</span><span class="punctuation" id="L5436">5436
</span><span class="punctuation" id="L5437">5437
</span><span class="punctuation" id="L5438">5438
</span><span class="punctuation" id="L5439">5439
</span><span class="punctuation" id="L5440">5440
</span><span class="punctuation" id="L5441">5441
</span><span class="punctuation" id="L5442">5442
</span><span class="punctuation" id="L5443">5443
</span><span class="punctuation" id="L5444">5444
</span><span class="punctuation" id="L5445">5445
</span><span class="punctuation" id="L5446">5446
</span><span class="punctuation" id="L5447">5447
</span><span class="punctuation" id="L5448">5448
</span><span class="punctuation" id="L5449">5449
</span><span class="punctuation" id="L5450">5450
</span><span class="punctuation" id="L5451">5451
</span><span class="punctuation" id="L5452">5452
</span><span class="punctuation" id="L5453">5453
</span><span class="punctuation" id="L5454">5454
</span><span class="punctuation" id="L5455">5455
</span><span class="punctuation" id="L5456">5456
</span><span class="punctuation" id="L5457">5457
</span><span class="punctuation" id="L5458">5458
</span><span class="punctuation" id="L5459">5459
</span><span class="punctuation" id="L5460">5460
</span><span class="punctuation" id="L5461">5461
</span><span class="punctuation" id="L5462">5462
</span><span class="punctuation" id="L5463">5463
</span><span class="punctuation" id="L5464">5464
</span><span class="punctuation" id="L5465">5465
</span><span class="punctuation" id="L5466">5466
</span><span class="punctuation" id="L5467">5467
</span><span class="punctuation" id="L5468">5468
</span><span class="punctuation" id="L5469">5469
</span><span class="punctuation" id="L5470">5470
</span><span class="punctuation" id="L5471">5471
</span><span class="punctuation" id="L5472">5472
</span><span class="punctuation" id="L5473">5473
</span><span class="punctuation" id="L5474">5474
</span><span class="punctuation" id="L5475">5475
</span><span class="punctuation" id="L5476">5476
</span><span class="punctuation" id="L5477">5477
</span><span class="punctuation" id="L5478">5478
</span><span class="punctuation" id="L5479">5479
</span><span class="punctuation" id="L5480">5480
</span><span class="punctuation" id="L5481">5481
</span><span class="punctuation" id="L5482">5482
</span><span class="punctuation" id="L5483">5483
</span><span class="punctuation" id="L5484">5484
</span><span class="punctuation" id="L5485">5485
</span><span class="punctuation" id="L5486">5486
</span><span class="punctuation" id="L5487">5487
</span><span class="punctuation" id="L5488">5488
</span><span class="punctuation" id="L5489">5489
</span><span class="punctuation" id="L5490">5490
</span><span class="punctuation" id="L5491">5491
</span><span class="punctuation" id="L5492">5492
</span><span class="punctuation" id="L5493">5493
</span><span class="punctuation" id="L5494">5494
</span><span class="punctuation" id="L5495">5495
</span><span class="punctuation" id="L5496">5496
</span><span class="punctuation" id="L5497">5497
</span><span class="punctuation" id="L5498">5498
</span><span class="punctuation" id="L5499">5499
</span><span class="punctuation" id="L5500">5500
</span><span class="punctuation" id="L5501">5501
</span><span class="punctuation" id="L5502">5502
</span><span class="punctuation" id="L5503">5503
</span><span class="punctuation" id="L5504">5504
</span><span class="punctuation" id="L5505">5505
</span><span class="punctuation" id="L5506">5506
</span><span class="punctuation" id="L5507">5507
</span><span class="punctuation" id="L5508">5508
</span><span class="punctuation" id="L5509">5509
</span><span class="punctuation" id="L5510">5510
</span><span class="punctuation" id="L5511">5511
</span><span class="punctuation" id="L5512">5512
</span><span class="punctuation" id="L5513">5513
</span><span class="punctuation" id="L5514">5514
</span><span class="punctuation" id="L5515">5515
</span><span class="punctuation" id="L5516">5516
</span><span class="punctuation" id="L5517">5517
</span><span class="punctuation" id="L5518">5518
</span><span class="punctuation" id="L5519">5519
</span><span class="punctuation" id="L5520">5520
</span><span class="punctuation" id="L5521">5521
</span><span class="punctuation" id="L5522">5522
</span><span class="punctuation" id="L5523">5523
</span><span class="punctuation" id="L5524">5524
</span><span class="punctuation" id="L5525">5525
</span><span class="punctuation" id="L5526">5526
</span><span class="punctuation" id="L5527">5527
</span><span class="punctuation" id="L5528">5528
</span><span class="punctuation" id="L5529">5529
</span><span class="punctuation" id="L5530">5530
</span><span class="punctuation" id="L5531">5531
</span><span class="punctuation" id="L5532">5532
</span><span class="punctuation" id="L5533">5533
</span><span class="punctuation" id="L5534">5534
</span><span class="punctuation" id="L5535">5535
</span><span class="punctuation" id="L5536">5536
</span><span class="punctuation" id="L5537">5537
</span><span class="punctuation" id="L5538">5538
</span><span class="punctuation" id="L5539">5539
</span><span class="punctuation" id="L5540">5540
</span><span class="punctuation" id="L5541">5541
</span><span class="punctuation" id="L5542">5542
</span><span class="punctuation" id="L5543">5543
</span><span class="punctuation" id="L5544">5544
</span><span class="punctuation" id="L5545">5545
</span><span class="punctuation" id="L5546">5546
</span><span class="punctuation" id="L5547">5547
</span><span class="punctuation" id="L5548">5548
</span><span class="punctuation" id="L5549">5549
</span><span class="punctuation" id="L5550">5550
</span><span class="punctuation" id="L5551">5551
</span><span class="punctuation" id="L5552">5552
</span><span class="punctuation" id="L5553">5553
</span><span class="punctuation" id="L5554">5554
</span><span class="punctuation" id="L5555">5555
</span><span class="punctuation" id="L5556">5556
</span><span class="punctuation" id="L5557">5557
</span><span class="punctuation" id="L5558">5558
</span><span class="punctuation" id="L5559">5559
</span><span class="punctuation" id="L5560">5560
</span><span class="punctuation" id="L5561">5561
</span><span class="punctuation" id="L5562">5562
</span><span class="punctuation" id="L5563">5563
</span><span class="punctuation" id="L5564">5564
</span><span class="punctuation" id="L5565">5565
</span><span class="punctuation" id="L5566">5566
</span><span class="punctuation" id="L5567">5567
</span><span class="punctuation" id="L5568">5568
</span><span class="punctuation" id="L5569">5569
</span><span class="punctuation" id="L5570">5570
</span><span class="punctuation" id="L5571">5571
</span><span class="punctuation" id="L5572">5572
</span><span class="punctuation" id="L5573">5573
</span><span class="punctuation" id="L5574">5574
</span><span class="punctuation" id="L5575">5575
</span><span class="punctuation" id="L5576">5576
</span><span class="punctuation" id="L5577">5577
</span><span class="punctuation" id="L5578">5578
</span><span class="punctuation" id="L5579">5579
</span><span class="punctuation" id="L5580">5580
</span><span class="punctuation" id="L5581">5581
</span><span class="punctuation" id="L5582">5582
</span><span class="punctuation" id="L5583">5583
</span><span class="punctuation" id="L5584">5584
</span><span class="punctuation" id="L5585">5585
</span><span class="punctuation" id="L5586">5586
</span><span class="punctuation" id="L5587">5587
</span><span class="punctuation" id="L5588">5588
</span><span class="punctuation" id="L5589">5589
</span><span class="punctuation" id="L5590">5590
</span><span class="punctuation" id="L5591">5591
</span><span class="punctuation" id="L5592">5592
</span><span class="punctuation" id="L5593">5593
</span><span class="punctuation" id="L5594">5594
</span><span class="punctuation" id="L5595">5595
</span><span class="punctuation" id="L5596">5596
</span><span class="punctuation" id="L5597">5597
</span><span class="punctuation" id="L5598">5598
</span><span class="punctuation" id="L5599">5599
</span><span class="punctuation" id="L5600">5600
</span><span class="punctuation" id="L5601">5601
</span><span class="punctuation" id="L5602">5602
</span><span class="punctuation" id="L5603">5603
</span><span class="punctuation" id="L5604">5604
</span><span class="punctuation" id="L5605">5605
</span><span class="punctuation" id="L5606">5606
</span><span class="punctuation" id="L5607">5607
</span><span class="punctuation" id="L5608">5608
</span><span class="punctuation" id="L5609">5609
</span><span class="punctuation" id="L5610">5610
</span><span class="punctuation" id="L5611">5611
</span><span class="punctuation" id="L5612">5612
</span><span class="punctuation" id="L5613">5613
</span><span class="punctuation" id="L5614">5614
</span><span class="punctuation" id="L5615">5615
</span><span class="punctuation" id="L5616">5616
</span><span class="punctuation" id="L5617">5617
</span><span class="punctuation" id="L5618">5618
</span><span class="punctuation" id="L5619">5619
</span><span class="punctuation" id="L5620">5620
</span><span class="punctuation" id="L5621">5621
</span><span class="punctuation" id="L5622">5622
</span><span class="punctuation" id="L5623">5623
</span><span class="punctuation" id="L5624">5624
</span><span class="punctuation" id="L5625">5625
</span><span class="punctuation" id="L5626">5626
</span><span class="punctuation" id="L5627">5627
</span><span class="punctuation" id="L5628">5628
</span><span class="punctuation" id="L5629">5629
</span><span class="punctuation" id="L5630">5630
</span><span class="punctuation" id="L5631">5631
</span><span class="punctuation" id="L5632">5632
</span><span class="punctuation" id="L5633">5633
</span><span class="punctuation" id="L5634">5634
</span><span class="punctuation" id="L5635">5635
</span><span class="punctuation" id="L5636">5636
</span><span class="punctuation" id="L5637">5637
</span><span class="punctuation" id="L5638">5638
</span><span class="punctuation" id="L5639">5639
</span><span class="punctuation" id="L5640">5640
</span><span class="punctuation" id="L5641">5641
</span><span class="punctuation" id="L5642">5642
</span><span class="punctuation" id="L5643">5643
</span><span class="punctuation" id="L5644">5644
</span><span class="punctuation" id="L5645">5645
</span><span class="punctuation" id="L5646">5646
</span><span class="punctuation" id="L5647">5647
</span><span class="punctuation" id="L5648">5648
</span><span class="punctuation" id="L5649">5649
</span><span class="punctuation" id="L5650">5650
</span><span class="punctuation" id="L5651">5651
</span><span class="punctuation" id="L5652">5652
</span><span class="punctuation" id="L5653">5653
</span><span class="punctuation" id="L5654">5654
</span><span class="punctuation" id="L5655">5655
</span><span class="punctuation" id="L5656">5656
</span><span class="punctuation" id="L5657">5657
</span><span class="punctuation" id="L5658">5658
</span><span class="punctuation" id="L5659">5659
</span><span class="punctuation" id="L5660">5660
</span><span class="punctuation" id="L5661">5661
</span><span class="punctuation" id="L5662">5662
</span><span class="punctuation" id="L5663">5663
</span><span class="punctuation" id="L5664">5664
</span><span class="punctuation" id="L5665">5665
</span><span class="punctuation" id="L5666">5666
</span><span class="punctuation" id="L5667">5667
</span><span class="punctuation" id="L5668">5668
</span><span class="punctuation" id="L5669">5669
</span><span class="punctuation" id="L5670">5670
</span><span class="punctuation" id="L5671">5671
</span><span class="punctuation" id="L5672">5672
</span><span class="punctuation" id="L5673">5673
</span><span class="punctuation" id="L5674">5674
</span><span class="punctuation" id="L5675">5675
</span><span class="punctuation" id="L5676">5676
</span><span class="punctuation" id="L5677">5677
</span><span class="punctuation" id="L5678">5678
</span><span class="punctuation" id="L5679">5679
</span><span class="punctuation" id="L5680">5680
</span><span class="punctuation" id="L5681">5681
</span><span class="punctuation" id="L5682">5682
</span><span class="punctuation" id="L5683">5683
</span><span class="punctuation" id="L5684">5684
</span><span class="punctuation" id="L5685">5685
</span><span class="punctuation" id="L5686">5686
</span><span class="punctuation" id="L5687">5687
</span><span class="punctuation" id="L5688">5688
</span><span class="punctuation" id="L5689">5689
</span><span class="punctuation" id="L5690">5690
</span><span class="punctuation" id="L5691">5691
</span><span class="punctuation" id="L5692">5692
</span><span class="punctuation" id="L5693">5693
</span><span class="punctuation" id="L5694">5694
</span><span class="punctuation" id="L5695">5695
</span><span class="punctuation" id="L5696">5696
</span><span class="punctuation" id="L5697">5697
</span><span class="punctuation" id="L5698">5698
</span><span class="punctuation" id="L5699">5699
</span><span class="punctuation" id="L5700">5700
</span><span class="punctuation" id="L5701">5701
</span><span class="punctuation" id="L5702">5702
</span><span class="punctuation" id="L5703">5703
</span><span class="punctuation" id="L5704">5704
</span><span class="punctuation" id="L5705">5705
</span><span class="punctuation" id="L5706">5706
</span><span class="punctuation" id="L5707">5707
</span><span class="punctuation" id="L5708">5708
</span><span class="punctuation" id="L5709">5709
</span><span class="punctuation" id="L5710">5710
</span><span class="punctuation" id="L5711">5711
</span><span class="punctuation" id="L5712">5712
</span><span class="punctuation" id="L5713">5713
</span><span class="punctuation" id="L5714">5714
</span><span class="punctuation" id="L5715">5715
</span><span class="punctuation" id="L5716">5716
</span><span class="punctuation" id="L5717">5717
</span><span class="punctuation" id="L5718">5718
</span><span class="punctuation" id="L5719">5719
</span><span class="punctuation" id="L5720">5720
</span><span class="punctuation" id="L5721">5721
</span><span class="punctuation" id="L5722">5722
</span><span class="punctuation" id="L5723">5723
</span><span class="punctuation" id="L5724">5724
</span><span class="punctuation" id="L5725">5725
</span><span class="punctuation" id="L5726">5726
</span><span class="punctuation" id="L5727">5727
</span><span class="punctuation" id="L5728">5728
</span><span class="punctuation" id="L5729">5729
</span><span class="punctuation" id="L5730">5730
</span><span class="punctuation" id="L5731">5731
</span><span class="punctuation" id="L5732">5732
</span><span class="punctuation" id="L5733">5733
</span><span class="punctuation" id="L5734">5734
</span><span class="punctuation" id="L5735">5735
</span><span class="punctuation" id="L5736">5736
</span><span class="punctuation" id="L5737">5737
</span><span class="punctuation" id="L5738">5738
</span><span class="punctuation" id="L5739">5739
</span><span class="punctuation" id="L5740">5740
</span><span class="punctuation" id="L5741">5741
</span><span class="punctuation" id="L5742">5742
</span><span class="punctuation" id="L5743">5743
</span><span class="punctuation" id="L5744">5744
</span><span class="punctuation" id="L5745">5745
</span><span class="punctuation" id="L5746">5746
</span><span class="punctuation" id="L5747">5747
</span><span class="punctuation" id="L5748">5748
</span><span class="punctuation" id="L5749">5749
</span><span class="punctuation" id="L5750">5750
</span><span class="punctuation" id="L5751">5751
</span><span class="punctuation" id="L5752">5752
</span><span class="punctuation" id="L5753">5753
</span><span class="punctuation" id="L5754">5754
</span><span class="punctuation" id="L5755">5755
</span><span class="punctuation" id="L5756">5756
</span><span class="punctuation" id="L5757">5757
</span><span class="punctuation" id="L5758">5758
</span><span class="punctuation" id="L5759">5759
</span><span class="punctuation" id="L5760">5760
</span><span class="punctuation" id="L5761">5761
</span><span class="punctuation" id="L5762">5762
</span><span class="punctuation" id="L5763">5763
</span><span class="punctuation" id="L5764">5764
</span><span class="punctuation" id="L5765">5765
</span><span class="punctuation" id="L5766">5766
</span><span class="punctuation" id="L5767">5767
</span><span class="punctuation" id="L5768">5768
</span><span class="punctuation" id="L5769">5769
</span><span class="punctuation" id="L5770">5770
</span><span class="punctuation" id="L5771">5771
</span><span class="punctuation" id="L5772">5772
</span><span class="punctuation" id="L5773">5773
</span><span class="punctuation" id="L5774">5774
</span><span class="punctuation" id="L5775">5775
</span><span class="punctuation" id="L5776">5776
</span><span class="punctuation" id="L5777">5777
</span><span class="punctuation" id="L5778">5778
</span><span class="punctuation" id="L5779">5779
</span><span class="punctuation" id="L5780">5780
</span><span class="punctuation" id="L5781">5781
</span><span class="punctuation" id="L5782">5782
</span><span class="punctuation" id="L5783">5783
</span><span class="punctuation" id="L5784">5784
</span><span class="punctuation" id="L5785">5785
</span><span class="punctuation" id="L5786">5786
</span><span class="punctuation" id="L5787">5787
</span><span class="punctuation" id="L5788">5788
</span><span class="punctuation" id="L5789">5789
</span><span class="punctuation" id="L5790">5790
</span><span class="punctuation" id="L5791">5791
</span><span class="punctuation" id="L5792">5792
</span><span class="punctuation" id="L5793">5793
</span><span class="punctuation" id="L5794">5794
</span><span class="punctuation" id="L5795">5795
</span><span class="punctuation" id="L5796">5796
</span><span class="punctuation" id="L5797">5797
</span><span class="punctuation" id="L5798">5798
</span><span class="punctuation" id="L5799">5799
</span><span class="punctuation" id="L5800">5800
</span><span class="punctuation" id="L5801">5801
</span><span class="punctuation" id="L5802">5802
</span><span class="punctuation" id="L5803">5803
</span><span class="punctuation" id="L5804">5804
</span><span class="punctuation" id="L5805">5805
</span><span class="punctuation" id="L5806">5806
</span><span class="punctuation" id="L5807">5807
</span><span class="punctuation" id="L5808">5808
</span><span class="punctuation" id="L5809">5809
</span><span class="punctuation" id="L5810">5810
</span><span class="punctuation" id="L5811">5811
</span><span class="punctuation" id="L5812">5812
</span><span class="punctuation" id="L5813">5813
</span><span class="punctuation" id="L5814">5814
</span><span class="punctuation" id="L5815">5815
</span><span class="punctuation" id="L5816">5816
</span><span class="punctuation" id="L5817">5817
</span><span class="punctuation" id="L5818">5818
</span><span class="punctuation" id="L5819">5819
</span><span class="punctuation" id="L5820">5820
</span><span class="punctuation" id="L5821">5821
</span><span class="punctuation" id="L5822">5822
</span><span class="punctuation" id="L5823">5823
</span><span class="punctuation" id="L5824">5824
</span><span class="punctuation" id="L5825">5825
</span><span class="punctuation" id="L5826">5826
</span><span class="punctuation" id="L5827">5827
</span><span class="punctuation" id="L5828">5828
</span><span class="punctuation" id="L5829">5829
</span><span class="punctuation" id="L5830">5830
</span><span class="punctuation" id="L5831">5831
</span><span class="punctuation" id="L5832">5832
</span><span class="punctuation" id="L5833">5833
</span><span class="punctuation" id="L5834">5834
</span><span class="punctuation" id="L5835">5835
</span><span class="punctuation" id="L5836">5836
</span><span class="punctuation" id="L5837">5837
</span><span class="punctuation" id="L5838">5838
</span><span class="punctuation" id="L5839">5839
</span><span class="punctuation" id="L5840">5840
</span><span class="punctuation" id="L5841">5841
</span><span class="punctuation" id="L5842">5842
</span><span class="punctuation" id="L5843">5843
</span><span class="punctuation" id="L5844">5844
</span><span class="punctuation" id="L5845">5845
</span><span class="punctuation" id="L5846">5846
</span><span class="punctuation" id="L5847">5847
</span><span class="punctuation" id="L5848">5848
</span><span class="punctuation" id="L5849">5849
</span><span class="punctuation" id="L5850">5850
</span><span class="punctuation" id="L5851">5851
</span><span class="punctuation" id="L5852">5852
</span><span class="punctuation" id="L5853">5853
</span><span class="punctuation" id="L5854">5854
</span><span class="punctuation" id="L5855">5855
</span><span class="punctuation" id="L5856">5856
</span><span class="punctuation" id="L5857">5857
</span><span class="punctuation" id="L5858">5858
</span><span class="punctuation" id="L5859">5859
</span><span class="punctuation" id="L5860">5860
</span><span class="punctuation" id="L5861">5861
</span><span class="punctuation" id="L5862">5862
</span><span class="punctuation" id="L5863">5863
</span><span class="punctuation" id="L5864">5864
</span><span class="punctuation" id="L5865">5865
</span><span class="punctuation" id="L5866">5866
</span><span class="punctuation" id="L5867">5867
</span><span class="punctuation" id="L5868">5868
</span><span class="punctuation" id="L5869">5869
</span><span class="punctuation" id="L5870">5870
</span><span class="punctuation" id="L5871">5871
</span><span class="punctuation" id="L5872">5872
</span><span class="punctuation" id="L5873">5873
</span><span class="punctuation" id="L5874">5874
</span><span class="punctuation" id="L5875">5875
</span><span class="punctuation" id="L5876">5876
</span><span class="punctuation" id="L5877">5877
</span><span class="punctuation" id="L5878">5878
</span><span class="punctuation" id="L5879">5879
</span><span class="punctuation" id="L5880">5880
</span><span class="punctuation" id="L5881">5881
</span><span class="punctuation" id="L5882">5882
</span><span class="punctuation" id="L5883">5883
</span><span class="punctuation" id="L5884">5884
</span><span class="punctuation" id="L5885">5885
</span><span class="punctuation" id="L5886">5886
</span><span class="punctuation" id="L5887">5887
</span><span class="punctuation" id="L5888">5888
</span><span class="punctuation" id="L5889">5889
</span><span class="punctuation" id="L5890">5890
</span><span class="punctuation" id="L5891">5891
</span><span class="punctuation" id="L5892">5892
</span><span class="punctuation" id="L5893">5893
</span><span class="punctuation" id="L5894">5894
</span><span class="punctuation" id="L5895">5895
</span><span class="punctuation" id="L5896">5896
</span><span class="punctuation" id="L5897">5897
</span><span class="punctuation" id="L5898">5898
</span><span class="punctuation" id="L5899">5899
</span><span class="punctuation" id="L5900">5900
</span><span class="punctuation" id="L5901">5901
</span><span class="punctuation" id="L5902">5902
</span><span class="punctuation" id="L5903">5903
</span><span class="punctuation" id="L5904">5904
</span><span class="punctuation" id="L5905">5905
</span><span class="punctuation" id="L5906">5906
</span><span class="punctuation" id="L5907">5907
</span><span class="punctuation" id="L5908">5908
</span><span class="punctuation" id="L5909">5909
</span><span class="punctuation" id="L5910">5910
</span><span class="punctuation" id="L5911">5911
</span><span class="punctuation" id="L5912">5912
</span><span class="punctuation" id="L5913">5913
</span><span class="punctuation" id="L5914">5914
</span><span class="punctuation" id="L5915">5915
</span><span class="punctuation" id="L5916">5916
</span><span class="punctuation" id="L5917">5917
</span><span class="punctuation" id="L5918">5918
</span><span class="punctuation" id="L5919">5919
</span><span class="punctuation" id="L5920">5920
</span><span class="punctuation" id="L5921">5921
</span><span class="punctuation" id="L5922">5922
</span><span class="punctuation" id="L5923">5923
</span><span class="punctuation" id="L5924">5924
</span><span class="punctuation" id="L5925">5925
</span><span class="punctuation" id="L5926">5926
</span><span class="punctuation" id="L5927">5927
</span><span class="punctuation" id="L5928">5928
</span><span class="punctuation" id="L5929">5929
</span><span class="punctuation" id="L5930">5930
</span><span class="punctuation" id="L5931">5931
</span><span class="punctuation" id="L5932">5932
</span><span class="punctuation" id="L5933">5933
</span><span class="punctuation" id="L5934">5934
</span><span class="punctuation" id="L5935">5935
</span><span class="punctuation" id="L5936">5936
</span><span class="punctuation" id="L5937">5937
</span><span class="punctuation" id="L5938">5938
</span><span class="punctuation" id="L5939">5939
</span><span class="punctuation" id="L5940">5940
</span><span class="punctuation" id="L5941">5941
</span><span class="punctuation" id="L5942">5942
</span><span class="punctuation" id="L5943">5943
</span><span class="punctuation" id="L5944">5944
</span><span class="punctuation" id="L5945">5945
</span><span class="punctuation" id="L5946">5946
</span><span class="punctuation" id="L5947">5947
</span><span class="punctuation" id="L5948">5948
</span><span class="punctuation" id="L5949">5949
</span><span class="punctuation" id="L5950">5950
</span><span class="punctuation" id="L5951">5951
</span><span class="punctuation" id="L5952">5952
</span><span class="punctuation" id="L5953">5953
</span><span class="punctuation" id="L5954">5954
</span><span class="punctuation" id="L5955">5955
</span><span class="punctuation" id="L5956">5956
</span><span class="punctuation" id="L5957">5957
</span><span class="punctuation" id="L5958">5958
</span><span class="punctuation" id="L5959">5959
</span><span class="punctuation" id="L5960">5960
</span><span class="punctuation" id="L5961">5961
</span><span class="punctuation" id="L5962">5962
</span><span class="punctuation" id="L5963">5963
</span><span class="punctuation" id="L5964">5964
</span><span class="punctuation" id="L5965">5965
</span><span class="punctuation" id="L5966">5966
</span><span class="punctuation" id="L5967">5967
</span><span class="punctuation" id="L5968">5968
</span><span class="punctuation" id="L5969">5969
</span><span class="punctuation" id="L5970">5970
</span><span class="punctuation" id="L5971">5971
</span><span class="punctuation" id="L5972">5972
</span><span class="punctuation" id="L5973">5973
</span><span class="punctuation" id="L5974">5974
</span><span class="punctuation" id="L5975">5975
</span><span class="punctuation" id="L5976">5976
</span><span class="punctuation" id="L5977">5977
</span><span class="punctuation" id="L5978">5978
</span><span class="punctuation" id="L5979">5979
</span><span class="punctuation" id="L5980">5980
</span><span class="punctuation" id="L5981">5981
</span><span class="punctuation" id="L5982">5982
</span><span class="punctuation" id="L5983">5983
</span><span class="punctuation" id="L5984">5984
</span><span class="punctuation" id="L5985">5985
</span><span class="punctuation" id="L5986">5986
</span><span class="punctuation" id="L5987">5987
</span><span class="punctuation" id="L5988">5988
</span><span class="punctuation" id="L5989">5989
</span><span class="punctuation" id="L5990">5990
</span><span class="punctuation" id="L5991">5991
</span><span class="punctuation" id="L5992">5992
</span><span class="punctuation" id="L5993">5993
</span><span class="punctuation" id="L5994">5994
</span><span class="punctuation" id="L5995">5995
</span><span class="punctuation" id="L5996">5996
</span><span class="punctuation" id="L5997">5997
</span><span class="punctuation" id="L5998">5998
</span><span class="punctuation" id="L5999">5999
</span><span class="punctuation" id="L6000">6000
</span><span class="punctuation" id="L6001">6001
</span><span class="punctuation" id="L6002">6002
</span><span class="punctuation" id="L6003">6003
</span><span class="punctuation" id="L6004">6004
</span><span class="punctuation" id="L6005">6005
</span><span class="punctuation" id="L6006">6006
</span><span class="punctuation" id="L6007">6007
</span><span class="punctuation" id="L6008">6008
</span><span class="punctuation" id="L6009">6009
</span><span class="punctuation" id="L6010">6010
</span><span class="punctuation" id="L6011">6011
</span><span class="punctuation" id="L6012">6012
</span><span class="punctuation" id="L6013">6013
</span><span class="punctuation" id="L6014">6014
</span><span class="punctuation" id="L6015">6015
</span><span class="punctuation" id="L6016">6016
</span><span class="punctuation" id="L6017">6017
</span><span class="punctuation" id="L6018">6018
</span><span class="punctuation" id="L6019">6019
</span><span class="punctuation" id="L6020">6020
</span><span class="punctuation" id="L6021">6021
</span><span class="punctuation" id="L6022">6022
</span><span class="punctuation" id="L6023">6023
</span><span class="punctuation" id="L6024">6024
</span><span class="punctuation" id="L6025">6025
</span><span class="punctuation" id="L6026">6026
</span><span class="punctuation" id="L6027">6027
</span><span class="punctuation" id="L6028">6028
</span><span class="punctuation" id="L6029">6029
</span><span class="punctuation" id="L6030">6030
</span><span class="punctuation" id="L6031">6031
</span><span class="punctuation" id="L6032">6032
</span><span class="punctuation" id="L6033">6033
</span><span class="punctuation" id="L6034">6034
</span><span class="punctuation" id="L6035">6035
</span><span class="punctuation" id="L6036">6036
</span><span class="punctuation" id="L6037">6037
</span><span class="punctuation" id="L6038">6038
</span><span class="punctuation" id="L6039">6039
</span><span class="punctuation" id="L6040">6040
</span><span class="punctuation" id="L6041">6041
</span><span class="punctuation" id="L6042">6042
</span><span class="punctuation" id="L6043">6043
</span><span class="punctuation" id="L6044">6044
</span><span class="punctuation" id="L6045">6045
</span><span class="punctuation" id="L6046">6046
</span><span class="punctuation" id="L6047">6047
</span><span class="punctuation" id="L6048">6048
</span><span class="punctuation" id="L6049">6049
</span><span class="punctuation" id="L6050">6050
</span><span class="punctuation" id="L6051">6051
</span><span class="punctuation" id="L6052">6052
</span><span class="punctuation" id="L6053">6053
</span><span class="punctuation" id="L6054">6054
</span><span class="punctuation" id="L6055">6055
</span><span class="punctuation" id="L6056">6056
</span><span class="punctuation" id="L6057">6057
</span><span class="punctuation" id="L6058">6058
</span><span class="punctuation" id="L6059">6059
</span><span class="punctuation" id="L6060">6060
</span><span class="punctuation" id="L6061">6061
</span><span class="punctuation" id="L6062">6062
</span><span class="punctuation" id="L6063">6063
</span><span class="punctuation" id="L6064">6064
</span><span class="punctuation" id="L6065">6065
</span><span class="punctuation" id="L6066">6066
</span><span class="punctuation" id="L6067">6067
</span><span class="punctuation" id="L6068">6068
</span><span class="punctuation" id="L6069">6069
</span><span class="punctuation" id="L6070">6070
</span><span class="punctuation" id="L6071">6071
</span><span class="punctuation" id="L6072">6072
</span><span class="punctuation" id="L6073">6073
</span><span class="punctuation" id="L6074">6074
</span><span class="punctuation" id="L6075">6075
</span><span class="punctuation" id="L6076">6076
</span><span class="punctuation" id="L6077">6077
</span><span class="punctuation" id="L6078">6078
</span><span class="punctuation" id="L6079">6079
</span><span class="punctuation" id="L6080">6080
</span><span class="punctuation" id="L6081">6081
</span><span class="punctuation" id="L6082">6082
</span><span class="punctuation" id="L6083">6083
</span><span class="punctuation" id="L6084">6084
</span><span class="punctuation" id="L6085">6085
</span><span class="punctuation" id="L6086">6086
</span><span class="punctuation" id="L6087">6087
</span><span class="punctuation" id="L6088">6088
</span><span class="punctuation" id="L6089">6089
</span><span class="punctuation" id="L6090">6090
</span><span class="punctuation" id="L6091">6091
</span><span class="punctuation" id="L6092">6092
</span><span class="punctuation" id="L6093">6093
</span><span class="punctuation" id="L6094">6094
</span><span class="punctuation" id="L6095">6095
</span><span class="punctuation" id="L6096">6096
</span><span class="punctuation" id="L6097">6097
</span><span class="punctuation" id="L6098">6098
</span><span class="punctuation" id="L6099">6099
</span><span class="punctuation" id="L6100">6100
</span><span class="punctuation" id="L6101">6101
</span><span class="punctuation" id="L6102">6102
</span><span class="punctuation" id="L6103">6103
</span><span class="punctuation" id="L6104">6104
</span><span class="punctuation" id="L6105">6105
</span><span class="punctuation" id="L6106">6106
</span><span class="punctuation" id="L6107">6107
</span><span class="punctuation" id="L6108">6108
</span><span class="punctuation" id="L6109">6109
</span><span class="punctuation" id="L6110">6110
</span><span class="punctuation" id="L6111">6111
</span><span class="punctuation" id="L6112">6112
</span><span class="punctuation" id="L6113">6113
</span><span class="punctuation" id="L6114">6114
</span><span class="punctuation" id="L6115">6115
</span><span class="punctuation" id="L6116">6116
</span><span class="punctuation" id="L6117">6117
</span><span class="punctuation" id="L6118">6118
</span><span class="punctuation" id="L6119">6119
</span><span class="punctuation" id="L6120">6120
</span><span class="punctuation" id="L6121">6121
</span><span class="punctuation" id="L6122">6122
</span><span class="punctuation" id="L6123">6123
</span><span class="punctuation" id="L6124">6124
</span><span class="punctuation" id="L6125">6125
</span><span class="punctuation" id="L6126">6126
</span><span class="punctuation" id="L6127">6127
</span><span class="punctuation" id="L6128">6128
</span><span class="punctuation" id="L6129">6129
</span><span class="punctuation" id="L6130">6130
</span><span class="punctuation" id="L6131">6131
</span><span class="punctuation" id="L6132">6132
</span><span class="punctuation" id="L6133">6133
</span><span class="punctuation" id="L6134">6134
</span><span class="punctuation" id="L6135">6135
</span><span class="punctuation" id="L6136">6136
</span><span class="punctuation" id="L6137">6137
</span><span class="punctuation" id="L6138">6138
</span><span class="punctuation" id="L6139">6139
</span><span class="punctuation" id="L6140">6140
</span><span class="punctuation" id="L6141">6141
</span><span class="punctuation" id="L6142">6142
</span><span class="punctuation" id="L6143">6143
</span><span class="punctuation" id="L6144">6144
</span><span class="punctuation" id="L6145">6145
</span><span class="punctuation" id="L6146">6146
</span><span class="punctuation" id="L6147">6147
</span><span class="punctuation" id="L6148">6148
</span><span class="punctuation" id="L6149">6149
</span><span class="punctuation" id="L6150">6150
</span><span class="punctuation" id="L6151">6151
</span><span class="punctuation" id="L6152">6152
</span><span class="punctuation" id="L6153">6153
</span><span class="punctuation" id="L6154">6154
</span><span class="punctuation" id="L6155">6155
</span><span class="punctuation" id="L6156">6156
</span><span class="punctuation" id="L6157">6157
</span><span class="punctuation" id="L6158">6158
</span><span class="punctuation" id="L6159">6159
</span><span class="punctuation" id="L6160">6160
</span><span class="punctuation" id="L6161">6161
</span><span class="punctuation" id="L6162">6162
</span><span class="punctuation" id="L6163">6163
</span><span class="punctuation" id="L6164">6164
</span><span class="punctuation" id="L6165">6165
</span><span class="punctuation" id="L6166">6166
</span><span class="punctuation" id="L6167">6167
</span><span class="punctuation" id="L6168">6168
</span><span class="punctuation" id="L6169">6169
</span><span class="punctuation" id="L6170">6170
</span><span class="punctuation" id="L6171">6171
</span><span class="punctuation" id="L6172">6172
</span><span class="punctuation" id="L6173">6173
</span><span class="punctuation" id="L6174">6174
</span><span class="punctuation" id="L6175">6175
</span><span class="punctuation" id="L6176">6176
</span><span class="punctuation" id="L6177">6177
</span><span class="punctuation" id="L6178">6178
</span><span class="punctuation" id="L6179">6179
</span><span class="punctuation" id="L6180">6180
</span><span class="punctuation" id="L6181">6181
</span><span class="punctuation" id="L6182">6182
</span><span class="punctuation" id="L6183">6183
</span><span class="punctuation" id="L6184">6184
</span><span class="punctuation" id="L6185">6185
</span><span class="punctuation" id="L6186">6186
</span><span class="punctuation" id="L6187">6187
</span><span class="punctuation" id="L6188">6188
</span><span class="punctuation" id="L6189">6189
</span><span class="punctuation" id="L6190">6190
</span><span class="punctuation" id="L6191">6191
</span><span class="punctuation" id="L6192">6192
</span><span class="punctuation" id="L6193">6193
</span><span class="punctuation" id="L6194">6194
</span><span class="punctuation" id="L6195">6195
</span><span class="punctuation" id="L6196">6196
</span><span class="punctuation" id="L6197">6197
</span><span class="punctuation" id="L6198">6198
</span><span class="punctuation" id="L6199">6199
</span><span class="punctuation" id="L6200">6200
</span><span class="punctuation" id="L6201">6201
</span><span class="punctuation" id="L6202">6202
</span><span class="punctuation" id="L6203">6203
</span><span class="punctuation" id="L6204">6204
</span><span class="punctuation" id="L6205">6205
</span><span class="punctuation" id="L6206">6206
</span><span class="punctuation" id="L6207">6207
</span><span class="punctuation" id="L6208">6208
</span><span class="punctuation" id="L6209">6209
</span><span class="punctuation" id="L6210">6210
</span><span class="punctuation" id="L6211">6211
</span><span class="punctuation" id="L6212">6212
</span><span class="punctuation" id="L6213">6213
</span><span class="punctuation" id="L6214">6214
</span><span class="punctuation" id="L6215">6215
</span><span class="punctuation" id="L6216">6216
</span><span class="punctuation" id="L6217">6217
</span><span class="punctuation" id="L6218">6218
</span><span class="punctuation" id="L6219">6219
</span><span class="punctuation" id="L6220">6220
</span><span class="punctuation" id="L6221">6221
</span><span class="punctuation" id="L6222">6222
</span><span class="punctuation" id="L6223">6223
</span><span class="punctuation" id="L6224">6224
</span><span class="punctuation" id="L6225">6225
</span><span class="punctuation" id="L6226">6226
</span><span class="punctuation" id="L6227">6227
</span><span class="punctuation" id="L6228">6228
</span><span class="punctuation" id="L6229">6229
</span><span class="punctuation" id="L6230">6230
</span><span class="punctuation" id="L6231">6231
</span><span class="punctuation" id="L6232">6232
</span><span class="punctuation" id="L6233">6233
</span><span class="punctuation" id="L6234">6234
</span><span class="punctuation" id="L6235">6235
</span><span class="punctuation" id="L6236">6236
</span><span class="punctuation" id="L6237">6237
</span><span class="punctuation" id="L6238">6238
</span><span class="punctuation" id="L6239">6239
</span><span class="punctuation" id="L6240">6240
</span><span class="punctuation" id="L6241">6241
</span><span class="punctuation" id="L6242">6242
</span><span class="punctuation" id="L6243">6243
</span><span class="punctuation" id="L6244">6244
</span><span class="punctuation" id="L6245">6245
</span><span class="punctuation" id="L6246">6246
</span><span class="punctuation" id="L6247">6247
</span><span class="punctuation" id="L6248">6248
</span><span class="punctuation" id="L6249">6249
</span><span class="punctuation" id="L6250">6250
</span><span class="punctuation" id="L6251">6251
</span><span class="punctuation" id="L6252">6252
</span><span class="punctuation" id="L6253">6253
</span><span class="punctuation" id="L6254">6254
</span><span class="punctuation" id="L6255">6255
</span><span class="punctuation" id="L6256">6256
</span><span class="punctuation" id="L6257">6257
</span><span class="punctuation" id="L6258">6258
</span><span class="punctuation" id="L6259">6259
</span><span class="punctuation" id="L6260">6260
</span><span class="punctuation" id="L6261">6261
</span><span class="punctuation" id="L6262">6262
</span><span class="punctuation" id="L6263">6263
</span><span class="punctuation" id="L6264">6264
</span><span class="punctuation" id="L6265">6265
</span><span class="punctuation" id="L6266">6266
</span><span class="punctuation" id="L6267">6267
</span><span class="punctuation" id="L6268">6268
</span><span class="punctuation" id="L6269">6269
</span><span class="punctuation" id="L6270">6270
</span><span class="punctuation" id="L6271">6271
</span><span class="punctuation" id="L6272">6272
</span><span class="punctuation" id="L6273">6273
</span><span class="punctuation" id="L6274">6274
</span><span class="punctuation" id="L6275">6275
</span><span class="punctuation" id="L6276">6276
</span><span class="punctuation" id="L6277">6277
</span><span class="punctuation" id="L6278">6278
</span><span class="punctuation" id="L6279">6279
</span><span class="punctuation" id="L6280">6280
</span><span class="punctuation" id="L6281">6281
</span><span class="punctuation" id="L6282">6282
</span><span class="punctuation" id="L6283">6283
</span><span class="punctuation" id="L6284">6284
</span><span class="punctuation" id="L6285">6285
</span><span class="punctuation" id="L6286">6286
</span><span class="punctuation" id="L6287">6287
</span><span class="punctuation" id="L6288">6288
</span><span class="punctuation" id="L6289">6289
</span><span class="punctuation" id="L6290">6290
</span><span class="punctuation" id="L6291">6291
</span><span class="punctuation" id="L6292">6292
</span><span class="punctuation" id="L6293">6293
</span><span class="punctuation" id="L6294">6294
</span><span class="punctuation" id="L6295">6295
</span><span class="punctuation" id="L6296">6296
</span><span class="punctuation" id="L6297">6297
</span><span class="punctuation" id="L6298">6298
</span><span class="punctuation" id="L6299">6299
</span><span class="punctuation" id="L6300">6300
</span><span class="punctuation" id="L6301">6301
</span><span class="punctuation" id="L6302">6302
</span><span class="punctuation" id="L6303">6303
</span><span class="punctuation" id="L6304">6304
</span><span class="punctuation" id="L6305">6305
</span><span class="punctuation" id="L6306">6306
</span><span class="punctuation" id="L6307">6307
</span><span class="punctuation" id="L6308">6308
</span><span class="punctuation" id="L6309">6309
</span><span class="punctuation" id="L6310">6310
</span><span class="punctuation" id="L6311">6311
</span><span class="punctuation" id="L6312">6312
</span><span class="punctuation" id="L6313">6313
</span><span class="punctuation" id="L6314">6314
</span><span class="punctuation" id="L6315">6315
</span><span class="punctuation" id="L6316">6316
</span><span class="punctuation" id="L6317">6317
</span><span class="punctuation" id="L6318">6318
</span><span class="punctuation" id="L6319">6319
</span><span class="punctuation" id="L6320">6320
</span><span class="punctuation" id="L6321">6321
</span><span class="punctuation" id="L6322">6322
</span><span class="punctuation" id="L6323">6323
</span><span class="punctuation" id="L6324">6324
</span><span class="punctuation" id="L6325">6325
</span><span class="punctuation" id="L6326">6326
</span><span class="punctuation" id="L6327">6327
</span><span class="punctuation" id="L6328">6328
</span><span class="punctuation" id="L6329">6329
</span><span class="punctuation" id="L6330">6330
</span><span class="punctuation" id="L6331">6331
</span><span class="punctuation" id="L6332">6332
</span><span class="punctuation" id="L6333">6333
</span><span class="punctuation" id="L6334">6334
</span><span class="punctuation" id="L6335">6335
</span><span class="punctuation" id="L6336">6336
</span><span class="punctuation" id="L6337">6337
</span><span class="punctuation" id="L6338">6338
</span><span class="punctuation" id="L6339">6339
</span><span class="punctuation" id="L6340">6340
</span><span class="punctuation" id="L6341">6341
</span><span class="punctuation" id="L6342">6342
</span><span class="punctuation" id="L6343">6343
</span><span class="punctuation" id="L6344">6344
</span><span class="punctuation" id="L6345">6345
</span><span class="punctuation" id="L6346">6346
</span><span class="punctuation" id="L6347">6347
</span><span class="punctuation" id="L6348">6348
</span><span class="punctuation" id="L6349">6349
</span><span class="punctuation" id="L6350">6350
</span><span class="punctuation" id="L6351">6351
</span><span class="punctuation" id="L6352">6352
</span><span class="punctuation" id="L6353">6353
</span><span class="punctuation" id="L6354">6354
</span><span class="punctuation" id="L6355">6355
</span><span class="punctuation" id="L6356">6356
</span><span class="punctuation" id="L6357">6357
</span><span class="punctuation" id="L6358">6358
</span><span class="punctuation" id="L6359">6359
</span><span class="punctuation" id="L6360">6360
</span><span class="punctuation" id="L6361">6361
</span><span class="punctuation" id="L6362">6362
</span><span class="punctuation" id="L6363">6363
</span><span class="punctuation" id="L6364">6364
</span><span class="punctuation" id="L6365">6365
</span><span class="punctuation" id="L6366">6366
</span><span class="punctuation" id="L6367">6367
</span><span class="punctuation" id="L6368">6368
</span><span class="punctuation" id="L6369">6369
</span><span class="punctuation" id="L6370">6370
</span><span class="punctuation" id="L6371">6371
</span><span class="punctuation" id="L6372">6372
</span><span class="punctuation" id="L6373">6373
</span><span class="punctuation" id="L6374">6374
</span><span class="punctuation" id="L6375">6375
</span><span class="punctuation" id="L6376">6376
</span><span class="punctuation" id="L6377">6377
</span><span class="punctuation" id="L6378">6378
</span><span class="punctuation" id="L6379">6379
</span><span class="punctuation" id="L6380">6380
</span><span class="punctuation" id="L6381">6381
</span><span class="punctuation" id="L6382">6382
</span><span class="punctuation" id="L6383">6383
</span><span class="punctuation" id="L6384">6384
</span><span class="punctuation" id="L6385">6385
</span><span class="punctuation" id="L6386">6386
</span><span class="punctuation" id="L6387">6387
</span><span class="punctuation" id="L6388">6388
</span><span class="punctuation" id="L6389">6389
</span><span class="punctuation" id="L6390">6390
</span><span class="punctuation" id="L6391">6391
</span><span class="punctuation" id="L6392">6392
</span><span class="punctuation" id="L6393">6393
</span><span class="punctuation" id="L6394">6394
</span><span class="punctuation" id="L6395">6395
</span><span class="punctuation" id="L6396">6396
</span><span class="punctuation" id="L6397">6397
</span><span class="punctuation" id="L6398">6398
</span><span class="punctuation" id="L6399">6399
</span><span class="punctuation" id="L6400">6400
</span><span class="punctuation" id="L6401">6401
</span><span class="punctuation" id="L6402">6402
</span><span class="punctuation" id="L6403">6403
</span><span class="punctuation" id="L6404">6404
</span><span class="punctuation" id="L6405">6405
</span><span class="punctuation" id="L6406">6406
</span><span class="punctuation" id="L6407">6407
</span><span class="punctuation" id="L6408">6408
</span><span class="punctuation" id="L6409">6409
</span><span class="punctuation" id="L6410">6410
</span><span class="punctuation" id="L6411">6411
</span><span class="punctuation" id="L6412">6412
</span><span class="punctuation" id="L6413">6413
</span><span class="punctuation" id="L6414">6414
</span><span class="punctuation" id="L6415">6415
</span><span class="punctuation" id="L6416">6416
</span><span class="punctuation" id="L6417">6417
</span><span class="punctuation" id="L6418">6418
</span><span class="punctuation" id="L6419">6419
</span><span class="punctuation" id="L6420">6420
</span><span class="punctuation" id="L6421">6421
</span><span class="punctuation" id="L6422">6422
</span><span class="punctuation" id="L6423">6423
</span><span class="punctuation" id="L6424">6424
</span><span class="punctuation" id="L6425">6425
</span><span class="punctuation" id="L6426">6426
</span><span class="punctuation" id="L6427">6427
</span><span class="punctuation" id="L6428">6428
</span><span class="punctuation" id="L6429">6429
</span><span class="punctuation" id="L6430">6430
</span><span class="punctuation" id="L6431">6431
</span><span class="punctuation" id="L6432">6432
</span><span class="punctuation" id="L6433">6433
</span><span class="punctuation" id="L6434">6434
</span><span class="punctuation" id="L6435">6435
</span><span class="punctuation" id="L6436">6436
</span><span class="punctuation" id="L6437">6437
</span><span class="punctuation" id="L6438">6438
</span><span class="punctuation" id="L6439">6439
</span><span class="punctuation" id="L6440">6440
</span><span class="punctuation" id="L6441">6441
</span><span class="punctuation" id="L6442">6442
</span><span class="punctuation" id="L6443">6443
</span><span class="punctuation" id="L6444">6444
</span><span class="punctuation" id="L6445">6445
</span><span class="punctuation" id="L6446">6446
</span><span class="punctuation" id="L6447">6447
</span><span class="punctuation" id="L6448">6448
</span><span class="punctuation" id="L6449">6449
</span><span class="punctuation" id="L6450">6450
</span><span class="punctuation" id="L6451">6451
</span><span class="punctuation" id="L6452">6452
</span><span class="punctuation" id="L6453">6453
</span><span class="punctuation" id="L6454">6454
</span><span class="punctuation" id="L6455">6455
</span><span class="punctuation" id="L6456">6456
</span><span class="punctuation" id="L6457">6457
</span><span class="punctuation" id="L6458">6458
</span><span class="punctuation" id="L6459">6459
</span><span class="punctuation" id="L6460">6460
</span><span class="punctuation" id="L6461">6461
</span><span class="punctuation" id="L6462">6462
</span><span class="punctuation" id="L6463">6463
</span><span class="punctuation" id="L6464">6464
</span><span class="punctuation" id="L6465">6465
</span><span class="punctuation" id="L6466">6466
</span><span class="punctuation" id="L6467">6467
</span><span class="punctuation" id="L6468">6468
</span><span class="punctuation" id="L6469">6469
</span><span class="punctuation" id="L6470">6470
</span><span class="punctuation" id="L6471">6471
</span><span class="punctuation" id="L6472">6472
</span><span class="punctuation" id="L6473">6473
</span><span class="punctuation" id="L6474">6474
</span><span class="punctuation" id="L6475">6475
</span><span class="punctuation" id="L6476">6476
</span><span class="punctuation" id="L6477">6477
</span><span class="punctuation" id="L6478">6478
</span><span class="punctuation" id="L6479">6479
</span><span class="punctuation" id="L6480">6480
</span><span class="punctuation" id="L6481">6481
</span><span class="punctuation" id="L6482">6482
</span><span class="punctuation" id="L6483">6483
</span><span class="punctuation" id="L6484">6484
</span><span class="punctuation" id="L6485">6485
</span><span class="punctuation" id="L6486">6486
</span><span class="punctuation" id="L6487">6487
</span><span class="punctuation" id="L6488">6488
</span><span class="punctuation" id="L6489">6489
</span><span class="punctuation" id="L6490">6490
</span><span class="punctuation" id="L6491">6491
</span><span class="punctuation" id="L6492">6492
</span><span class="punctuation" id="L6493">6493
</span><span class="punctuation" id="L6494">6494
</span><span class="punctuation" id="L6495">6495
</span><span class="punctuation" id="L6496">6496
</span><span class="punctuation" id="L6497">6497
</span><span class="punctuation" id="L6498">6498
</span><span class="punctuation" id="L6499">6499
</span><span class="punctuation" id="L6500">6500
</span><span class="punctuation" id="L6501">6501
</span><span class="punctuation" id="L6502">6502
</span><span class="punctuation" id="L6503">6503
</span><span class="punctuation" id="L6504">6504
</span><span class="punctuation" id="L6505">6505
</span><span class="punctuation" id="L6506">6506
</span><span class="punctuation" id="L6507">6507
</span><span class="punctuation" id="L6508">6508
</span><span class="punctuation" id="L6509">6509
</span><span class="punctuation" id="L6510">6510
</span><span class="punctuation" id="L6511">6511
</span><span class="punctuation" id="L6512">6512
</span><span class="punctuation" id="L6513">6513
</span><span class="punctuation" id="L6514">6514
</span><span class="punctuation" id="L6515">6515
</span><span class="punctuation" id="L6516">6516
</span><span class="punctuation" id="L6517">6517
</span><span class="punctuation" id="L6518">6518
</span><span class="punctuation" id="L6519">6519
</span><span class="punctuation" id="L6520">6520
</span><span class="punctuation" id="L6521">6521
</span><span class="punctuation" id="L6522">6522
</span><span class="punctuation" id="L6523">6523
</span><span class="punctuation" id="L6524">6524
</span><span class="punctuation" id="L6525">6525
</span><span class="punctuation" id="L6526">6526
</span><span class="punctuation" id="L6527">6527
</span><span class="punctuation" id="L6528">6528
</span><span class="punctuation" id="L6529">6529
</span><span class="punctuation" id="L6530">6530
</span><span class="punctuation" id="L6531">6531
</span><span class="punctuation" id="L6532">6532
</span><span class="punctuation" id="L6533">6533
</span><span class="punctuation" id="L6534">6534
</span><span class="punctuation" id="L6535">6535
</span><span class="punctuation" id="L6536">6536
</span><span class="punctuation" id="L6537">6537
</span><span class="punctuation" id="L6538">6538
</span><span class="punctuation" id="L6539">6539
</span><span class="punctuation" id="L6540">6540
</span><span class="punctuation" id="L6541">6541
</span><span class="punctuation" id="L6542">6542
</span><span class="punctuation" id="L6543">6543
</span><span class="punctuation" id="L6544">6544
</span><span class="punctuation" id="L6545">6545
</span><span class="punctuation" id="L6546">6546
</span><span class="punctuation" id="L6547">6547
</span><span class="punctuation" id="L6548">6548
</span><span class="punctuation" id="L6549">6549
</span><span class="punctuation" id="L6550">6550
</span><span class="punctuation" id="L6551">6551
</span><span class="punctuation" id="L6552">6552
</span><span class="punctuation" id="L6553">6553
</span><span class="punctuation" id="L6554">6554
</span><span class="punctuation" id="L6555">6555
</span><span class="punctuation" id="L6556">6556
</span><span class="punctuation" id="L6557">6557
</span><span class="punctuation" id="L6558">6558
</span><span class="punctuation" id="L6559">6559
</span><span class="punctuation" id="L6560">6560
</span><span class="punctuation" id="L6561">6561
</span><span class="punctuation" id="L6562">6562
</span><span class="punctuation" id="L6563">6563
</span><span class="punctuation" id="L6564">6564
</span><span class="punctuation" id="L6565">6565
</span><span class="punctuation" id="L6566">6566
</span><span class="punctuation" id="L6567">6567
</span><span class="punctuation" id="L6568">6568
</span><span class="punctuation" id="L6569">6569
</span><span class="punctuation" id="L6570">6570
</span><span class="punctuation" id="L6571">6571
</span><span class="punctuation" id="L6572">6572
</span><span class="punctuation" id="L6573">6573
</span><span class="punctuation" id="L6574">6574
</span><span class="punctuation" id="L6575">6575
</span><span class="punctuation" id="L6576">6576
</span><span class="punctuation" id="L6577">6577
</span><span class="punctuation" id="L6578">6578
</span><span class="punctuation" id="L6579">6579
</span><span class="punctuation" id="L6580">6580
</span><span class="punctuation" id="L6581">6581
</span><span class="punctuation" id="L6582">6582
</span><span class="punctuation" id="L6583">6583
</span><span class="punctuation" id="L6584">6584
</span><span class="punctuation" id="L6585">6585
</span><span class="punctuation" id="L6586">6586
</span><span class="punctuation" id="L6587">6587
</span><span class="punctuation" id="L6588">6588
</span><span class="punctuation" id="L6589">6589
</span><span class="punctuation" id="L6590">6590
</span><span class="punctuation" id="L6591">6591
</span><span class="punctuation" id="L6592">6592
</span><span class="punctuation" id="L6593">6593
</span><span class="punctuation" id="L6594">6594
</span><span class="punctuation" id="L6595">6595
</span><span class="punctuation" id="L6596">6596
</span><span class="punctuation" id="L6597">6597
</span><span class="punctuation" id="L6598">6598
</span><span class="punctuation" id="L6599">6599
</span><span class="punctuation" id="L6600">6600
</span><span class="punctuation" id="L6601">6601
</span><span class="punctuation" id="L6602">6602
</span><span class="punctuation" id="L6603">6603
</span><span class="punctuation" id="L6604">6604
</span><span class="punctuation" id="L6605">6605
</span><span class="punctuation" id="L6606">6606
</span><span class="punctuation" id="L6607">6607
</span><span class="punctuation" id="L6608">6608
</span><span class="punctuation" id="L6609">6609
</span><span class="punctuation" id="L6610">6610
</span><span class="punctuation" id="L6611">6611
</span><span class="punctuation" id="L6612">6612
</span><span class="punctuation" id="L6613">6613
</span><span class="punctuation" id="L6614">6614
</span><span class="punctuation" id="L6615">6615
</span><span class="punctuation" id="L6616">6616
</span><span class="punctuation" id="L6617">6617
</span><span class="punctuation" id="L6618">6618
</span><span class="punctuation" id="L6619">6619
</span><span class="punctuation" id="L6620">6620
</span><span class="punctuation" id="L6621">6621
</span><span class="punctuation" id="L6622">6622
</span><span class="punctuation" id="L6623">6623
</span><span class="punctuation" id="L6624">6624
</span><span class="punctuation" id="L6625">6625
</span><span class="punctuation" id="L6626">6626
</span><span class="punctuation" id="L6627">6627
</span><span class="punctuation" id="L6628">6628
</span><span class="punctuation" id="L6629">6629
</span><span class="punctuation" id="L6630">6630
</span><span class="punctuation" id="L6631">6631
</span><span class="punctuation" id="L6632">6632
</span><span class="punctuation" id="L6633">6633
</span><span class="punctuation" id="L6634">6634
</span><span class="punctuation" id="L6635">6635
</span><span class="punctuation" id="L6636">6636
</span><span class="punctuation" id="L6637">6637
</span><span class="punctuation" id="L6638">6638
</span><span class="punctuation" id="L6639">6639
</span><span class="punctuation" id="L6640">6640
</span><span class="punctuation" id="L6641">6641
</span><span class="punctuation" id="L6642">6642
</span><span class="punctuation" id="L6643">6643
</span><span class="punctuation" id="L6644">6644
</span><span class="punctuation" id="L6645">6645
</span><span class="punctuation" id="L6646">6646
</span><span class="punctuation" id="L6647">6647
</span><span class="punctuation" id="L6648">6648
</span><span class="punctuation" id="L6649">6649
</span><span class="punctuation" id="L6650">6650
</span><span class="punctuation" id="L6651">6651
</span><span class="punctuation" id="L6652">6652
</span><span class="punctuation" id="L6653">6653
</span><span class="punctuation" id="L6654">6654
</span><span class="punctuation" id="L6655">6655
</span><span class="punctuation" id="L6656">6656
</span><span class="punctuation" id="L6657">6657
</span><span class="punctuation" id="L6658">6658
</span><span class="punctuation" id="L6659">6659
</span><span class="punctuation" id="L6660">6660
</span><span class="punctuation" id="L6661">6661
</span><span class="punctuation" id="L6662">6662
</span><span class="punctuation" id="L6663">6663
</span><span class="punctuation" id="L6664">6664
</span><span class="punctuation" id="L6665">6665
</span><span class="punctuation" id="L6666">6666
</span><span class="punctuation" id="L6667">6667
</span><span class="punctuation" id="L6668">6668
</span><span class="punctuation" id="L6669">6669
</span><span class="punctuation" id="L6670">6670
</span><span class="punctuation" id="L6671">6671
</span><span class="punctuation" id="L6672">6672
</span><span class="punctuation" id="L6673">6673
</span><span class="punctuation" id="L6674">6674
</span><span class="punctuation" id="L6675">6675
</span><span class="punctuation" id="L6676">6676
</span><span class="punctuation" id="L6677">6677
</span><span class="punctuation" id="L6678">6678
</span><span class="punctuation" id="L6679">6679
</span><span class="punctuation" id="L6680">6680
</span><span class="punctuation" id="L6681">6681
</span><span class="punctuation" id="L6682">6682
</span><span class="punctuation" id="L6683">6683
</span><span class="punctuation" id="L6684">6684
</span><span class="punctuation" id="L6685">6685
</span><span class="punctuation" id="L6686">6686
</span><span class="punctuation" id="L6687">6687
</span><span class="punctuation" id="L6688">6688
</span><span class="punctuation" id="L6689">6689
</span><span class="punctuation" id="L6690">6690
</span><span class="punctuation" id="L6691">6691
</span><span class="punctuation" id="L6692">6692
</span><span class="punctuation" id="L6693">6693
</span><span class="punctuation" id="L6694">6694
</span><span class="punctuation" id="L6695">6695
</span><span class="punctuation" id="L6696">6696
</span><span class="punctuation" id="L6697">6697
</span><span class="punctuation" id="L6698">6698
</span><span class="punctuation" id="L6699">6699
</span><span class="punctuation" id="L6700">6700
</span><span class="punctuation" id="L6701">6701
</span><span class="punctuation" id="L6702">6702
</span><span class="punctuation" id="L6703">6703
</span><span class="punctuation" id="L6704">6704
</span><span class="punctuation" id="L6705">6705
</span><span class="punctuation" id="L6706">6706
</span><span class="punctuation" id="L6707">6707
</span><span class="punctuation" id="L6708">6708
</span><span class="punctuation" id="L6709">6709
</span><span class="punctuation" id="L6710">6710
</span><span class="punctuation" id="L6711">6711
</span><span class="punctuation" id="L6712">6712
</span><span class="punctuation" id="L6713">6713
</span><span class="punctuation" id="L6714">6714
</span><span class="punctuation" id="L6715">6715
</span><span class="punctuation" id="L6716">6716
</span><span class="punctuation" id="L6717">6717
</span><span class="punctuation" id="L6718">6718
</span><span class="punctuation" id="L6719">6719
</span><span class="punctuation" id="L6720">6720
</span><span class="punctuation" id="L6721">6721
</span><span class="punctuation" id="L6722">6722
</span><span class="punctuation" id="L6723">6723
</span><span class="punctuation" id="L6724">6724
</span><span class="punctuation" id="L6725">6725
</span><span class="punctuation" id="L6726">6726
</span><span class="punctuation" id="L6727">6727
</span><span class="punctuation" id="L6728">6728
</span><span class="punctuation" id="L6729">6729
</span><span class="punctuation" id="L6730">6730
</span><span class="punctuation" id="L6731">6731
</span><span class="punctuation" id="L6732">6732
</span><span class="punctuation" id="L6733">6733
</span><span class="punctuation" id="L6734">6734
</span><span class="punctuation" id="L6735">6735
</span><span class="punctuation" id="L6736">6736
</span><span class="punctuation" id="L6737">6737
</span><span class="punctuation" id="L6738">6738
</span><span class="punctuation" id="L6739">6739
</span><span class="punctuation" id="L6740">6740
</span><span class="punctuation" id="L6741">6741
</span><span class="punctuation" id="L6742">6742
</span><span class="punctuation" id="L6743">6743
</span><span class="punctuation" id="L6744">6744
</span><span class="punctuation" id="L6745">6745
</span><span class="punctuation" id="L6746">6746
</span><span class="punctuation" id="L6747">6747
</span><span class="punctuation" id="L6748">6748
</span><span class="punctuation" id="L6749">6749
</span><span class="punctuation" id="L6750">6750
</span><span class="punctuation" id="L6751">6751
</span><span class="punctuation" id="L6752">6752
</span><span class="punctuation" id="L6753">6753
</span><span class="punctuation" id="L6754">6754
</span><span class="punctuation" id="L6755">6755
</span><span class="punctuation" id="L6756">6756
</span><span class="punctuation" id="L6757">6757
</span><span class="punctuation" id="L6758">6758
</span><span class="punctuation" id="L6759">6759
</span><span class="punctuation" id="L6760">6760
</span><span class="punctuation" id="L6761">6761
</span><span class="punctuation" id="L6762">6762
</span><span class="punctuation" id="L6763">6763
</span><span class="punctuation" id="L6764">6764
</span><span class="punctuation" id="L6765">6765
</span><span class="punctuation" id="L6766">6766
</span><span class="punctuation" id="L6767">6767
</span><span class="punctuation" id="L6768">6768
</span><span class="punctuation" id="L6769">6769
</span><span class="punctuation" id="L6770">6770
</span><span class="punctuation" id="L6771">6771
</span><span class="punctuation" id="L6772">6772
</span><span class="punctuation" id="L6773">6773
</span><span class="punctuation" id="L6774">6774
</span><span class="punctuation" id="L6775">6775
</span><span class="punctuation" id="L6776">6776
</span><span class="punctuation" id="L6777">6777
</span><span class="punctuation" id="L6778">6778
</span><span class="punctuation" id="L6779">6779
</span><span class="punctuation" id="L6780">6780
</span><span class="punctuation" id="L6781">6781
</span><span class="punctuation" id="L6782">6782
</span><span class="punctuation" id="L6783">6783
</span><span class="punctuation" id="L6784">6784
</span><span class="punctuation" id="L6785">6785
</span><span class="punctuation" id="L6786">6786
</span><span class="punctuation" id="L6787">6787
</span><span class="punctuation" id="L6788">6788
</span><span class="punctuation" id="L6789">6789
</span><span class="punctuation" id="L6790">6790
</span><span class="punctuation" id="L6791">6791
</span><span class="punctuation" id="L6792">6792
</span><span class="punctuation" id="L6793">6793
</span><span class="punctuation" id="L6794">6794
</span><span class="punctuation" id="L6795">6795
</span><span class="punctuation" id="L6796">6796
</span><span class="punctuation" id="L6797">6797
</span><span class="punctuation" id="L6798">6798
</span><span class="punctuation" id="L6799">6799
</span><span class="punctuation" id="L6800">6800
</span><span class="punctuation" id="L6801">6801
</span><span class="punctuation" id="L6802">6802
</span><span class="punctuation" id="L6803">6803
</span><span class="punctuation" id="L6804">6804
</span><span class="punctuation" id="L6805">6805
</span><span class="punctuation" id="L6806">6806
</span><span class="punctuation" id="L6807">6807
</span><span class="punctuation" id="L6808">6808
</span><span class="punctuation" id="L6809">6809
</span><span class="punctuation" id="L6810">6810
</span><span class="punctuation" id="L6811">6811
</span><span class="punctuation" id="L6812">6812
</span><span class="punctuation" id="L6813">6813
</span><span class="punctuation" id="L6814">6814
</span><span class="punctuation" id="L6815">6815
</span><span class="punctuation" id="L6816">6816
</span><span class="punctuation" id="L6817">6817
</span><span class="punctuation" id="L6818">6818
</span><span class="punctuation" id="L6819">6819
</span><span class="punctuation" id="L6820">6820
</span><span class="punctuation" id="L6821">6821
</span><span class="punctuation" id="L6822">6822
</span><span class="punctuation" id="L6823">6823
</span><span class="punctuation" id="L6824">6824
</span><span class="punctuation" id="L6825">6825
</span><span class="punctuation" id="L6826">6826
</span><span class="punctuation" id="L6827">6827
</span><span class="punctuation" id="L6828">6828
</span><span class="punctuation" id="L6829">6829
</span><span class="punctuation" id="L6830">6830
</span><span class="punctuation" id="L6831">6831
</span><span class="punctuation" id="L6832">6832
</span><span class="punctuation" id="L6833">6833
</span><span class="punctuation" id="L6834">6834
</span><span class="punctuation" id="L6835">6835
</span><span class="punctuation" id="L6836">6836
</span><span class="punctuation" id="L6837">6837
</span><span class="punctuation" id="L6838">6838
</span><span class="punctuation" id="L6839">6839
</span><span class="punctuation" id="L6840">6840
</span><span class="punctuation" id="L6841">6841
</span><span class="punctuation" id="L6842">6842
</span><span class="punctuation" id="L6843">6843
</span><span class="punctuation" id="L6844">6844
</span><span class="punctuation" id="L6845">6845
</span><span class="punctuation" id="L6846">6846
</span><span class="punctuation" id="L6847">6847
</span><span class="punctuation" id="L6848">6848
</span><span class="punctuation" id="L6849">6849
</span><span class="punctuation" id="L6850">6850
</span><span class="punctuation" id="L6851">6851
</span><span class="punctuation" id="L6852">6852
</span><span class="punctuation" id="L6853">6853
</span><span class="punctuation" id="L6854">6854
</span><span class="punctuation" id="L6855">6855
</span><span class="punctuation" id="L6856">6856
</span><span class="punctuation" id="L6857">6857
</span><span class="punctuation" id="L6858">6858
</span><span class="punctuation" id="L6859">6859
</span><span class="punctuation" id="L6860">6860
</span><span class="punctuation" id="L6861">6861
</span><span class="punctuation" id="L6862">6862
</span><span class="punctuation" id="L6863">6863
</span><span class="punctuation" id="L6864">6864
</span><span class="punctuation" id="L6865">6865
</span><span class="punctuation" id="L6866">6866
</span><span class="punctuation" id="L6867">6867
</span><span class="punctuation" id="L6868">6868
</span><span class="punctuation" id="L6869">6869
</span><span class="punctuation" id="L6870">6870
</span><span class="punctuation" id="L6871">6871
</span><span class="punctuation" id="L6872">6872
</span><span class="punctuation" id="L6873">6873
</span><span class="punctuation" id="L6874">6874
</span><span class="punctuation" id="L6875">6875
</span><span class="punctuation" id="L6876">6876
</span><span class="punctuation" id="L6877">6877
</span><span class="punctuation" id="L6878">6878
</span><span class="punctuation" id="L6879">6879
</span><span class="punctuation" id="L6880">6880
</span><span class="punctuation" id="L6881">6881
</span><span class="punctuation" id="L6882">6882
</span><span class="punctuation" id="L6883">6883
</span><span class="punctuation" id="L6884">6884
</span><span class="punctuation" id="L6885">6885
</span><span class="punctuation" id="L6886">6886
</span><span class="punctuation" id="L6887">6887
</span><span class="punctuation" id="L6888">6888
</span><span class="punctuation" id="L6889">6889
</span><span class="punctuation" id="L6890">6890
</span><span class="punctuation" id="L6891">6891
</span><span class="punctuation" id="L6892">6892
</span><span class="punctuation" id="L6893">6893
</span><span class="punctuation" id="L6894">6894
</span><span class="punctuation" id="L6895">6895
</span><span class="punctuation" id="L6896">6896
</span><span class="punctuation" id="L6897">6897
</span><span class="punctuation" id="L6898">6898
</span><span class="punctuation" id="L6899">6899
</span><span class="punctuation" id="L6900">6900
</span><span class="punctuation" id="L6901">6901
</span><span class="punctuation" id="L6902">6902
</span><span class="punctuation" id="L6903">6903
</span><span class="punctuation" id="L6904">6904
</span><span class="punctuation" id="L6905">6905
</span><span class="punctuation" id="L6906">6906
</span><span class="punctuation" id="L6907">6907
</span><span class="punctuation" id="L6908">6908
</span><span class="punctuation" id="L6909">6909
</span><span class="punctuation" id="L6910">6910
</span><span class="punctuation" id="L6911">6911
</span><span class="punctuation" id="L6912">6912
</span><span class="punctuation" id="L6913">6913
</span><span class="punctuation" id="L6914">6914
</span><span class="punctuation" id="L6915">6915
</span><span class="punctuation" id="L6916">6916
</span><span class="punctuation" id="L6917">6917
</span><span class="punctuation" id="L6918">6918
</span><span class="punctuation" id="L6919">6919
</span><span class="punctuation" id="L6920">6920
</span><span class="punctuation" id="L6921">6921
</span><span class="punctuation" id="L6922">6922
</span><span class="punctuation" id="L6923">6923
</span><span class="punctuation" id="L6924">6924
</span><span class="punctuation" id="L6925">6925
</span><span class="punctuation" id="L6926">6926
</span><span class="punctuation" id="L6927">6927
</span><span class="punctuation" id="L6928">6928
</span><span class="punctuation" id="L6929">6929
</span><span class="punctuation" id="L6930">6930
</span><span class="punctuation" id="L6931">6931
</span><span class="punctuation" id="L6932">6932
</span><span class="punctuation" id="L6933">6933
</span><span class="punctuation" id="L6934">6934
</span><span class="punctuation" id="L6935">6935
</span><span class="punctuation" id="L6936">6936
</span><span class="punctuation" id="L6937">6937
</span><span class="punctuation" id="L6938">6938
</span><span class="punctuation" id="L6939">6939
</span><span class="punctuation" id="L6940">6940
</span><span class="punctuation" id="L6941">6941
</span><span class="punctuation" id="L6942">6942
</span><span class="punctuation" id="L6943">6943
</span><span class="punctuation" id="L6944">6944
</span><span class="punctuation" id="L6945">6945
</span><span class="punctuation" id="L6946">6946
</span><span class="punctuation" id="L6947">6947
</span><span class="punctuation" id="L6948">6948
</span><span class="punctuation" id="L6949">6949
</span><span class="punctuation" id="L6950">6950
</span><span class="punctuation" id="L6951">6951
</span><span class="punctuation" id="L6952">6952
</span><span class="punctuation" id="L6953">6953
</span><span class="punctuation" id="L6954">6954
</span><span class="punctuation" id="L6955">6955
</span><span class="punctuation" id="L6956">6956
</span><span class="punctuation" id="L6957">6957
</span><span class="punctuation" id="L6958">6958
</span><span class="punctuation" id="L6959">6959
</span><span class="punctuation" id="L6960">6960
</span><span class="punctuation" id="L6961">6961
</span><span class="punctuation" id="L6962">6962
</span><span class="punctuation" id="L6963">6963
</span><span class="punctuation" id="L6964">6964
</span><span class="punctuation" id="L6965">6965
</span><span class="punctuation" id="L6966">6966
</span><span class="punctuation" id="L6967">6967
</span><span class="punctuation" id="L6968">6968
</span><span class="punctuation" id="L6969">6969
</span><span class="punctuation" id="L6970">6970
</span><span class="punctuation" id="L6971">6971
</span><span class="punctuation" id="L6972">6972
</span><span class="punctuation" id="L6973">6973
</span><span class="punctuation" id="L6974">6974
</span><span class="punctuation" id="L6975">6975
</span><span class="punctuation" id="L6976">6976
</span><span class="punctuation" id="L6977">6977
</span><span class="punctuation" id="L6978">6978
</span><span class="punctuation" id="L6979">6979
</span><span class="punctuation" id="L6980">6980
</span><span class="punctuation" id="L6981">6981
</span><span class="punctuation" id="L6982">6982
</span><span class="punctuation" id="L6983">6983
</span><span class="punctuation" id="L6984">6984
</span><span class="punctuation" id="L6985">6985
</span><span class="punctuation" id="L6986">6986
</span><span class="punctuation" id="L6987">6987
</span><span class="punctuation" id="L6988">6988
</span><span class="punctuation" id="L6989">6989
</span><span class="punctuation" id="L6990">6990
</span><span class="punctuation" id="L6991">6991
</span><span class="punctuation" id="L6992">6992
</span><span class="punctuation" id="L6993">6993
</span><span class="punctuation" id="L6994">6994
</span><span class="punctuation" id="L6995">6995
</span><span class="punctuation" id="L6996">6996
</span><span class="punctuation" id="L6997">6997
</span><span class="punctuation" id="L6998">6998
</span><span class="punctuation" id="L6999">6999
</span><span class="punctuation" id="L7000">7000
</span><span class="punctuation" id="L7001">7001
</span><span class="punctuation" id="L7002">7002
</span><span class="punctuation" id="L7003">7003
</span><span class="punctuation" id="L7004">7004
</span><span class="punctuation" id="L7005">7005
</span><span class="punctuation" id="L7006">7006
</span><span class="punctuation" id="L7007">7007
</span><span class="punctuation" id="L7008">7008
</span><span class="punctuation" id="L7009">7009
</span><span class="punctuation" id="L7010">7010
</span><span class="punctuation" id="L7011">7011
</span><span class="punctuation" id="L7012">7012
</span><span class="punctuation" id="L7013">7013
</span><span class="punctuation" id="L7014">7014
</span><span class="punctuation" id="L7015">7015
</span><span class="punctuation" id="L7016">7016
</span><span class="punctuation" id="L7017">7017
</span><span class="punctuation" id="L7018">7018
</span><span class="punctuation" id="L7019">7019
</span><span class="punctuation" id="L7020">7020
</span><span class="punctuation" id="L7021">7021
</span><span class="punctuation" id="L7022">7022
</span><span class="punctuation" id="L7023">7023
</span><span class="punctuation" id="L7024">7024
</span><span class="punctuation" id="L7025">7025
</span><span class="punctuation" id="L7026">7026
</span><span class="punctuation" id="L7027">7027
</span><span class="punctuation" id="L7028">7028
</span><span class="punctuation" id="L7029">7029
</span><span class="punctuation" id="L7030">7030
</span><span class="punctuation" id="L7031">7031
</span><span class="punctuation" id="L7032">7032
</span><span class="punctuation" id="L7033">7033
</span><span class="punctuation" id="L7034">7034
</span><span class="punctuation" id="L7035">7035
</span><span class="punctuation" id="L7036">7036
</span><span class="punctuation" id="L7037">7037
</span><span class="punctuation" id="L7038">7038
</span><span class="punctuation" id="L7039">7039
</span><span class="punctuation" id="L7040">7040
</span><span class="punctuation" id="L7041">7041
</span><span class="punctuation" id="L7042">7042
</span><span class="punctuation" id="L7043">7043
</span><span class="punctuation" id="L7044">7044
</span><span class="punctuation" id="L7045">7045
</span><span class="punctuation" id="L7046">7046
</span><span class="punctuation" id="L7047">7047
</span><span class="punctuation" id="L7048">7048
</span><span class="punctuation" id="L7049">7049
</span><span class="punctuation" id="L7050">7050
</span><span class="punctuation" id="L7051">7051
</span><span class="punctuation" id="L7052">7052
</span><span class="punctuation" id="L7053">7053
</span><span class="punctuation" id="L7054">7054
</span><span class="punctuation" id="L7055">7055
</span><span class="punctuation" id="L7056">7056
</span><span class="punctuation" id="L7057">7057
</span><span class="punctuation" id="L7058">7058
</span><span class="punctuation" id="L7059">7059
</span><span class="punctuation" id="L7060">7060
</span><span class="punctuation" id="L7061">7061
</span><span class="punctuation" id="L7062">7062
</span><span class="punctuation" id="L7063">7063
</span><span class="punctuation" id="L7064">7064
</span><span class="punctuation" id="L7065">7065
</span><span class="punctuation" id="L7066">7066
</span><span class="punctuation" id="L7067">7067
</span><span class="punctuation" id="L7068">7068
</span><span class="punctuation" id="L7069">7069
</span><span class="punctuation" id="L7070">7070
</span><span class="punctuation" id="L7071">7071
</span><span class="punctuation" id="L7072">7072
</span><span class="punctuation" id="L7073">7073
</span><span class="punctuation" id="L7074">7074
</span><span class="punctuation" id="L7075">7075
</span><span class="punctuation" id="L7076">7076
</span><span class="punctuation" id="L7077">7077
</span><span class="punctuation" id="L7078">7078
</span><span class="punctuation" id="L7079">7079
</span><span class="punctuation" id="L7080">7080
</span><span class="punctuation" id="L7081">7081
</span><span class="punctuation" id="L7082">7082
</span><span class="punctuation" id="L7083">7083
</span><span class="punctuation" id="L7084">7084
</span><span class="punctuation" id="L7085">7085
</span><span class="punctuation" id="L7086">7086
</span><span class="punctuation" id="L7087">7087
</span><span class="punctuation" id="L7088">7088
</span><span class="punctuation" id="L7089">7089
</span><span class="punctuation" id="L7090">7090
</span><span class="punctuation" id="L7091">7091
</span><span class="punctuation" id="L7092">7092
</span><span class="punctuation" id="L7093">7093
</span><span class="punctuation" id="L7094">7094
</span><span class="punctuation" id="L7095">7095
</span><span class="punctuation" id="L7096">7096
</span><span class="punctuation" id="L7097">7097
</span><span class="punctuation" id="L7098">7098
</span><span class="punctuation" id="L7099">7099
</span><span class="punctuation" id="L7100">7100
</span><span class="punctuation" id="L7101">7101
</span><span class="punctuation" id="L7102">7102
</span><span class="punctuation" id="L7103">7103
</span><span class="punctuation" id="L7104">7104
</span><span class="punctuation" id="L7105">7105
</span><span class="punctuation" id="L7106">7106
</span><span class="punctuation" id="L7107">7107
</span><span class="punctuation" id="L7108">7108
</span><span class="punctuation" id="L7109">7109
</span><span class="punctuation" id="L7110">7110
</span><span class="punctuation" id="L7111">7111
</span><span class="punctuation" id="L7112">7112
</span><span class="punctuation" id="L7113">7113
</span><span class="punctuation" id="L7114">7114
</span><span class="punctuation" id="L7115">7115
</span><span class="punctuation" id="L7116">7116
</span><span class="punctuation" id="L7117">7117
</span><span class="punctuation" id="L7118">7118
</span><span class="punctuation" id="L7119">7119
</span><span class="punctuation" id="L7120">7120
</span><span class="punctuation" id="L7121">7121
</span><span class="punctuation" id="L7122">7122
</span><span class="punctuation" id="L7123">7123
</span><span class="punctuation" id="L7124">7124
</span><span class="punctuation" id="L7125">7125
</span><span class="punctuation" id="L7126">7126
</span><span class="punctuation" id="L7127">7127
</span><span class="punctuation" id="L7128">7128
</span><span class="punctuation" id="L7129">7129
</span><span class="punctuation" id="L7130">7130
</span><span class="punctuation" id="L7131">7131
</span><span class="punctuation" id="L7132">7132
</span><span class="punctuation" id="L7133">7133
</span><span class="punctuation" id="L7134">7134
</span><span class="punctuation" id="L7135">7135
</span><span class="punctuation" id="L7136">7136
</span><span class="punctuation" id="L7137">7137
</span><span class="punctuation" id="L7138">7138
</span><span class="punctuation" id="L7139">7139
</span><span class="punctuation" id="L7140">7140
</span><span class="punctuation" id="L7141">7141
</span><span class="punctuation" id="L7142">7142
</span><span class="punctuation" id="L7143">7143
</span><span class="punctuation" id="L7144">7144
</span><span class="punctuation" id="L7145">7145
</span><span class="punctuation" id="L7146">7146
</span><span class="punctuation" id="L7147">7147
</span><span class="punctuation" id="L7148">7148
</span><span class="punctuation" id="L7149">7149
</span><span class="punctuation" id="L7150">7150
</span><span class="punctuation" id="L7151">7151
</span><span class="punctuation" id="L7152">7152
</span><span class="punctuation" id="L7153">7153
</span><span class="punctuation" id="L7154">7154
</span><span class="punctuation" id="L7155">7155
</span><span class="punctuation" id="L7156">7156
</span><span class="punctuation" id="L7157">7157
</span><span class="punctuation" id="L7158">7158
</span><span class="punctuation" id="L7159">7159
</span><span class="punctuation" id="L7160">7160
</span><span class="punctuation" id="L7161">7161
</span><span class="punctuation" id="L7162">7162
</span><span class="punctuation" id="L7163">7163
</span><span class="punctuation" id="L7164">7164
</span><span class="punctuation" id="L7165">7165
</span><span class="punctuation" id="L7166">7166
</span><span class="punctuation" id="L7167">7167
</span><span class="punctuation" id="L7168">7168
</span><span class="punctuation" id="L7169">7169
</span><span class="punctuation" id="L7170">7170
</span><span class="punctuation" id="L7171">7171
</span><span class="punctuation" id="L7172">7172
</span><span class="punctuation" id="L7173">7173
</span><span class="punctuation" id="L7174">7174
</span><span class="punctuation" id="L7175">7175
</span><span class="punctuation" id="L7176">7176
</span><span class="punctuation" id="L7177">7177
</span><span class="punctuation" id="L7178">7178
</span><span class="punctuation" id="L7179">7179
</span><span class="punctuation" id="L7180">7180
</span><span class="punctuation" id="L7181">7181
</span><span class="punctuation" id="L7182">7182
</span><span class="punctuation" id="L7183">7183
</span><span class="punctuation" id="L7184">7184
</span><span class="punctuation" id="L7185">7185
</span><span class="punctuation" id="L7186">7186
</span><span class="punctuation" id="L7187">7187
</span><span class="punctuation" id="L7188">7188
</span><span class="punctuation" id="L7189">7189
</span><span class="punctuation" id="L7190">7190
</span><span class="punctuation" id="L7191">7191
</span><span class="punctuation" id="L7192">7192
</span><span class="punctuation" id="L7193">7193
</span><span class="punctuation" id="L7194">7194
</span><span class="punctuation" id="L7195">7195
</span><span class="punctuation" id="L7196">7196
</span><span class="punctuation" id="L7197">7197
</span><span class="punctuation" id="L7198">7198
</span><span class="punctuation" id="L7199">7199
</span><span class="punctuation" id="L7200">7200
</span><span class="punctuation" id="L7201">7201
</span><span class="punctuation" id="L7202">7202
</span><span class="punctuation" id="L7203">7203
</span><span class="punctuation" id="L7204">7204
</span><span class="punctuation" id="L7205">7205
</span><span class="punctuation" id="L7206">7206
</span><span class="punctuation" id="L7207">7207
</span><span class="punctuation" id="L7208">7208
</span><span class="punctuation" id="L7209">7209
</span><span class="punctuation" id="L7210">7210
</span><span class="punctuation" id="L7211">7211
</span><span class="punctuation" id="L7212">7212
</span><span class="punctuation" id="L7213">7213
</span><span class="punctuation" id="L7214">7214
</span><span class="punctuation" id="L7215">7215
</span><span class="punctuation" id="L7216">7216
</span><span class="punctuation" id="L7217">7217
</span><span class="punctuation" id="L7218">7218
</span><span class="punctuation" id="L7219">7219
</span><span class="punctuation" id="L7220">7220
</span><span class="punctuation" id="L7221">7221
</span><span class="punctuation" id="L7222">7222
</span><span class="punctuation" id="L7223">7223
</span><span class="punctuation" id="L7224">7224
</span><span class="punctuation" id="L7225">7225
</span><span class="punctuation" id="L7226">7226
</span><span class="punctuation" id="L7227">7227
</span><span class="punctuation" id="L7228">7228
</span><span class="punctuation" id="L7229">7229
</span><span class="punctuation" id="L7230">7230
</span><span class="punctuation" id="L7231">7231
</span><span class="punctuation" id="L7232">7232
</span><span class="punctuation" id="L7233">7233
</span><span class="punctuation" id="L7234">7234
</span><span class="punctuation" id="L7235">7235
</span><span class="punctuation" id="L7236">7236
</span><span class="punctuation" id="L7237">7237
</span><span class="punctuation" id="L7238">7238
</span><span class="punctuation" id="L7239">7239
</span><span class="punctuation" id="L7240">7240
</span><span class="punctuation" id="L7241">7241
</span><span class="punctuation" id="L7242">7242
</span><span class="punctuation" id="L7243">7243
</span><span class="punctuation" id="L7244">7244
</span><span class="punctuation" id="L7245">7245
</span><span class="punctuation" id="L7246">7246
</span><span class="punctuation" id="L7247">7247
</span><span class="punctuation" id="L7248">7248
</span><span class="punctuation" id="L7249">7249
</span><span class="punctuation" id="L7250">7250
</span><span class="punctuation" id="L7251">7251
</span><span class="punctuation" id="L7252">7252
</span><span class="punctuation" id="L7253">7253
</span><span class="punctuation" id="L7254">7254
</span><span class="punctuation" id="L7255">7255
</span><span class="punctuation" id="L7256">7256
</span><span class="punctuation" id="L7257">7257
</span><span class="punctuation" id="L7258">7258
</span><span class="punctuation" id="L7259">7259
</span><span class="punctuation" id="L7260">7260
</span><span class="punctuation" id="L7261">7261
</span><span class="punctuation" id="L7262">7262
</span><span class="punctuation" id="L7263">7263
</span><span class="punctuation" id="L7264">7264
</span><span class="punctuation" id="L7265">7265
</span><span class="punctuation" id="L7266">7266
</span><span class="punctuation" id="L7267">7267
</span><span class="punctuation" id="L7268">7268
</span><span class="punctuation" id="L7269">7269
</span><span class="punctuation" id="L7270">7270
</span><span class="punctuation" id="L7271">7271
</span><span class="punctuation" id="L7272">7272
</span><span class="punctuation" id="L7273">7273
</span><span class="punctuation" id="L7274">7274
</span><span class="punctuation" id="L7275">7275
</span><span class="punctuation" id="L7276">7276
</span><span class="punctuation" id="L7277">7277
</span><span class="punctuation" id="L7278">7278
</span><span class="punctuation" id="L7279">7279
</span><span class="punctuation" id="L7280">7280
</span><span class="punctuation" id="L7281">7281
</span><span class="punctuation" id="L7282">7282
</span><span class="punctuation" id="L7283">7283
</span><span class="punctuation" id="L7284">7284
</span><span class="punctuation" id="L7285">7285
</span><span class="punctuation" id="L7286">7286
</span><span class="punctuation" id="L7287">7287
</span><span class="punctuation" id="L7288">7288
</span><span class="punctuation" id="L7289">7289
</span><span class="punctuation" id="L7290">7290
</span><span class="punctuation" id="L7291">7291
</span><span class="punctuation" id="L7292">7292
</span><span class="punctuation" id="L7293">7293
</span><span class="punctuation" id="L7294">7294
</span><span class="punctuation" id="L7295">7295
</span><span class="punctuation" id="L7296">7296
</span><span class="punctuation" id="L7297">7297
</span><span class="punctuation" id="L7298">7298
</span><span class="punctuation" id="L7299">7299
</span><span class="punctuation" id="L7300">7300
</span><span class="punctuation" id="L7301">7301
</span><span class="punctuation" id="L7302">7302
</span><span class="punctuation" id="L7303">7303
</span><span class="punctuation" id="L7304">7304
</span><span class="punctuation" id="L7305">7305
</span><span class="punctuation" id="L7306">7306
</span><span class="punctuation" id="L7307">7307
</span><span class="punctuation" id="L7308">7308
</span><span class="punctuation" id="L7309">7309
</span><span class="punctuation" id="L7310">7310
</span><span class="punctuation" id="L7311">7311
</span><span class="punctuation" id="L7312">7312
</span><span class="punctuation" id="L7313">7313
</span><span class="punctuation" id="L7314">7314
</span><span class="punctuation" id="L7315">7315
</span><span class="punctuation" id="L7316">7316
</span><span class="punctuation" id="L7317">7317
</span><span class="punctuation" id="L7318">7318
</span><span class="punctuation" id="L7319">7319
</span><span class="punctuation" id="L7320">7320
</span><span class="punctuation" id="L7321">7321
</span><span class="punctuation" id="L7322">7322
</span><span class="punctuation" id="L7323">7323
</span><span class="punctuation" id="L7324">7324
</span><span class="punctuation" id="L7325">7325
</span><span class="punctuation" id="L7326">7326
</span><span class="punctuation" id="L7327">7327
</span><span class="punctuation" id="L7328">7328
</span><span class="punctuation" id="L7329">7329
</span><span class="punctuation" id="L7330">7330
</span><span class="punctuation" id="L7331">7331
</span><span class="punctuation" id="L7332">7332
</span><span class="punctuation" id="L7333">7333
</span><span class="punctuation" id="L7334">7334
</span><span class="punctuation" id="L7335">7335
</span><span class="punctuation" id="L7336">7336
</span><span class="punctuation" id="L7337">7337
</span><span class="punctuation" id="L7338">7338
</span><span class="punctuation" id="L7339">7339
</span><span class="punctuation" id="L7340">7340
</span><span class="punctuation" id="L7341">7341
</span><span class="punctuation" id="L7342">7342
</span><span class="punctuation" id="L7343">7343
</span><span class="punctuation" id="L7344">7344
</span><span class="punctuation" id="L7345">7345
</span><span class="punctuation" id="L7346">7346
</span><span class="punctuation" id="L7347">7347
</span><span class="punctuation" id="L7348">7348
</span><span class="punctuation" id="L7349">7349
</span><span class="punctuation" id="L7350">7350
</span><span class="punctuation" id="L7351">7351
</span><span class="punctuation" id="L7352">7352
</span><span class="punctuation" id="L7353">7353
</span><span class="punctuation" id="L7354">7354
</span><span class="punctuation" id="L7355">7355
</span><span class="punctuation" id="L7356">7356
</span><span class="punctuation" id="L7357">7357
</span><span class="punctuation" id="L7358">7358
</span><span class="punctuation" id="L7359">7359
</span><span class="punctuation" id="L7360">7360
</span><span class="punctuation" id="L7361">7361
</span><span class="punctuation" id="L7362">7362
</span><span class="punctuation" id="L7363">7363
</span><span class="punctuation" id="L7364">7364
</span><span class="punctuation" id="L7365">7365
</span><span class="punctuation" id="L7366">7366
</span><span class="punctuation" id="L7367">7367
</span><span class="punctuation" id="L7368">7368
</span><span class="punctuation" id="L7369">7369
</span><span class="punctuation" id="L7370">7370
</span><span class="punctuation" id="L7371">7371
</span><span class="punctuation" id="L7372">7372
</span><span class="punctuation" id="L7373">7373
</span><span class="punctuation" id="L7374">7374
</span><span class="punctuation" id="L7375">7375
</span><span class="punctuation" id="L7376">7376
</span><span class="punctuation" id="L7377">7377
</span><span class="punctuation" id="L7378">7378
</span><span class="punctuation" id="L7379">7379
</span><span class="punctuation" id="L7380">7380
</span><span class="punctuation" id="L7381">7381
</span><span class="punctuation" id="L7382">7382
</span><span class="punctuation" id="L7383">7383
</span><span class="punctuation" id="L7384">7384
</span><span class="punctuation" id="L7385">7385
</span><span class="punctuation" id="L7386">7386
</span><span class="punctuation" id="L7387">7387
</span><span class="punctuation" id="L7388">7388
</span><span class="punctuation" id="L7389">7389
</span><span class="punctuation" id="L7390">7390
</span><span class="punctuation" id="L7391">7391
</span><span class="punctuation" id="L7392">7392
</span><span class="punctuation" id="L7393">7393
</span><span class="punctuation" id="L7394">7394
</span><span class="punctuation" id="L7395">7395
</span><span class="punctuation" id="L7396">7396
</span><span class="punctuation" id="L7397">7397
</span><span class="punctuation" id="L7398">7398
</span><span class="punctuation" id="L7399">7399
</span><span class="punctuation" id="L7400">7400
</span><span class="punctuation" id="L7401">7401
</span><span class="punctuation" id="L7402">7402
</span><span class="punctuation" id="L7403">7403
</span><span class="punctuation" id="L7404">7404
</span><span class="punctuation" id="L7405">7405
</span><span class="punctuation" id="L7406">7406
</span><span class="punctuation" id="L7407">7407
</span><span class="punctuation" id="L7408">7408
</span><span class="punctuation" id="L7409">7409
</span><span class="punctuation" id="L7410">7410
</span><span class="punctuation" id="L7411">7411
</span><span class="punctuation" id="L7412">7412
</span><span class="punctuation" id="L7413">7413
</span><span class="punctuation" id="L7414">7414
</span><span class="punctuation" id="L7415">7415
</span><span class="punctuation" id="L7416">7416
</span><span class="punctuation" id="L7417">7417
</span><span class="punctuation" id="L7418">7418
</span><span class="punctuation" id="L7419">7419
</span><span class="punctuation" id="L7420">7420
</span><span class="punctuation" id="L7421">7421
</span><span class="punctuation" id="L7422">7422
</span><span class="punctuation" id="L7423">7423
</span><span class="punctuation" id="L7424">7424
</span><span class="punctuation" id="L7425">7425
</span><span class="punctuation" id="L7426">7426
</span><span class="punctuation" id="L7427">7427
</span><span class="punctuation" id="L7428">7428
</span><span class="punctuation" id="L7429">7429
</span><span class="punctuation" id="L7430">7430
</span><span class="punctuation" id="L7431">7431
</span><span class="punctuation" id="L7432">7432
</span><span class="punctuation" id="L7433">7433
</span><span class="punctuation" id="L7434">7434
</span><span class="punctuation" id="L7435">7435
</span><span class="punctuation" id="L7436">7436
</span><span class="punctuation" id="L7437">7437
</span><span class="punctuation" id="L7438">7438
</span><span class="punctuation" id="L7439">7439
</span><span class="punctuation" id="L7440">7440
</span><span class="punctuation" id="L7441">7441
</span><span class="punctuation" id="L7442">7442
</span><span class="punctuation" id="L7443">7443
</span><span class="punctuation" id="L7444">7444
</span><span class="punctuation" id="L7445">7445
</span><span class="punctuation" id="L7446">7446
</span><span class="punctuation" id="L7447">7447
</span><span class="punctuation" id="L7448">7448
</span><span class="punctuation" id="L7449">7449
</span><span class="punctuation" id="L7450">7450
</span><span class="punctuation" id="L7451">7451
</span><span class="punctuation" id="L7452">7452
</span><span class="punctuation" id="L7453">7453
</span><span class="punctuation" id="L7454">7454
</span><span class="punctuation" id="L7455">7455
</span><span class="punctuation" id="L7456">7456
</span><span class="punctuation" id="L7457">7457
</span><span class="punctuation" id="L7458">7458
</span><span class="punctuation" id="L7459">7459
</span><span class="punctuation" id="L7460">7460
</span><span class="punctuation" id="L7461">7461
</span><span class="punctuation" id="L7462">7462
</span><span class="punctuation" id="L7463">7463
</span><span class="punctuation" id="L7464">7464
</span><span class="punctuation" id="L7465">7465
</span><span class="punctuation" id="L7466">7466
</span><span class="punctuation" id="L7467">7467
</span><span class="punctuation" id="L7468">7468
</span><span class="punctuation" id="L7469">7469
</span><span class="punctuation" id="L7470">7470
</span><span class="punctuation" id="L7471">7471
</span><span class="punctuation" id="L7472">7472
</span><span class="punctuation" id="L7473">7473
</span><span class="punctuation" id="L7474">7474
</span><span class="punctuation" id="L7475">7475
</span><span class="punctuation" id="L7476">7476
</span><span class="punctuation" id="L7477">7477
</span><span class="punctuation" id="L7478">7478
</span><span class="punctuation" id="L7479">7479
</span><span class="punctuation" id="L7480">7480
</span><span class="punctuation" id="L7481">7481
</span><span class="punctuation" id="L7482">7482
</span><span class="punctuation" id="L7483">7483
</span><span class="punctuation" id="L7484">7484
</span><span class="punctuation" id="L7485">7485
</span><span class="punctuation" id="L7486">7486
</span><span class="punctuation" id="L7487">7487
</span><span class="punctuation" id="L7488">7488
</span><span class="punctuation" id="L7489">7489
</span><span class="punctuation" id="L7490">7490
</span><span class="punctuation" id="L7491">7491
</span><span class="punctuation" id="L7492">7492
</span><span class="punctuation" id="L7493">7493
</span><span class="punctuation" id="L7494">7494
</span><span class="punctuation" id="L7495">7495
</span><span class="punctuation" id="L7496">7496
</span><span class="punctuation" id="L7497">7497
</span><span class="punctuation" id="L7498">7498
</span><span class="punctuation" id="L7499">7499
</span><span class="punctuation" id="L7500">7500
</span><span class="punctuation" id="L7501">7501
</span><span class="punctuation" id="L7502">7502
</span><span class="punctuation" id="L7503">7503
</span><span class="punctuation" id="L7504">7504
</span><span class="punctuation" id="L7505">7505
</span><span class="punctuation" id="L7506">7506
</span><span class="punctuation" id="L7507">7507
</span><span class="punctuation" id="L7508">7508
</span><span class="punctuation" id="L7509">7509
</span><span class="punctuation" id="L7510">7510
</span><span class="punctuation" id="L7511">7511
</span><span class="punctuation" id="L7512">7512
</span><span class="punctuation" id="L7513">7513
</span><span class="punctuation" id="L7514">7514
</span><span class="punctuation" id="L7515">7515
</span><span class="punctuation" id="L7516">7516
</span><span class="punctuation" id="L7517">7517
</span><span class="punctuation" id="L7518">7518
</span><span class="punctuation" id="L7519">7519
</span></code></pre><div style="width:1px;"></div><pre class="source"><code><span class="comment">;   Copyright (c) Rich Hickey. All rights reserved.</span><span class="whitespace">
</span><span class="comment">;   The use and distribution terms for this software are covered by the</span><span class="whitespace">
</span><span class="comment">;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)</span><span class="whitespace">
</span><span class="comment">;   which can be found in the file epl-v10.html at the root of this distribution.</span><span class="whitespace">
</span><span class="comment">;   By using this software in any fashion, you are agreeing to be bound by</span><span class="whitespace">
</span><span class="comment">;   the terms of this license.</span><span class="whitespace">
</span><span class="comment">;   You must not remove this notice, or any other, from this software.</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"The core Clojure language."</span><span class="whitespace">
</span><span class="whitespace">       </span><span class="keyword">:author</span><span class="whitespace"> </span><span class="string">"Rich Hickey"</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="symbol">clojure.core</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unquote">unquote</a></span>)</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unquote-splicing">unquote-splicing</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">items</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Creates a new list containing the items."</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.PersistentList</span><span class="whitespace"> </span><span class="symbol">creator</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Returns a new seq where x is the first element and seq is
    the rest."</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="symbol">fn*</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;during bootstrap we don't have destructuring let, loop or fn, will redefine later</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span>{<span class="keyword">:macro</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="macro">let</span><span class="whitespace"> </span><span>(<span class="symbol">fn*</span><span class="whitespace"> </span><span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">&form</span><span class="whitespace"> </span><span class="symbol">&env</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">decl</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>'<span class="symbol">let*</span></span><span class="whitespace"> </span><span class="symbol">decl</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:macro</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="macro">loop</span><span class="whitespace"> </span><span>(<span class="symbol">fn*</span><span class="whitespace"> </span><span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">&form</span><span class="whitespace"> </span><span class="symbol">&env</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">decl</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>'<span class="symbol">loop*</span></span><span class="whitespace"> </span><span class="symbol">decl</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:macro</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="macro">fn</span><span class="whitespace"> </span><span>(<span class="symbol">fn*</span><span class="whitespace"> </span><span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&form</span><span class="whitespace"> </span><span class="symbol">&env</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">decl</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="java-class">.withMeta</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.IObj</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>'<span class="symbol">fn*</span></span><span class="whitespace"> </span><span class="symbol">decl</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="java-class">.meta</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.IMeta</span></span><span class="whitespace"> </span><span class="symbol">&form</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">coll</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil."</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">coll</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">clojure.lang.ISeq</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil."</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">  </span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">coll</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">clojure.lang.ISeq</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Returns a possibly empty seq of the items after the first. Calls seq on its
  argument."</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">  </span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">more</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>[<span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">xs</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"conj[oin]. Returns a new collection with the xs
    'added'. (conj nil item) returns (item).  The 'addition' may
    happen at different 'places' depending on the concrete type."</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span>[]</span><span class="whitespace"> </span><span>[]</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span>[<span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">conj</span></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span>[<span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">xs</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">xs</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">conj</span></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">xs</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">xs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">conj</span></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Same as (first (next x))"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">x</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Same as (first (first x))"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">x</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ffirst" title="Same as (first (first x))">ffirst</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ffirst" title="Same as (first (first x))">ffirst</a></span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Same as (next (first x))"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">x</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nfirst" title="Same as (next (first x))">nfirst</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nfirst" title="Same as (next (first x))">nfirst</a></span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Same as (first (next x))"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">x</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/fnext" title="Same as (first (next x))">fnext</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/fnext" title="Same as (first (next x))">fnext</a></span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Same as (next (next x))"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">x</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nnext" title="Same as (next (next x))">nnext</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nnext" title="Same as (next (next x))">nnext</a></span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>^<span class="java-class">clojure.lang.ISeq</span></span><span class="whitespace"> </span><span>[<span class="symbol">coll</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object."</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">clojure.lang.ISeq</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.ISeq</span></span><span class="whitespace"> </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span>^<span class="java-class">Class</span></span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">x</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Evaluates x and tests if it is an instance of the class
    c. Returns true or false"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">Class</span></span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span>(<span class="symbol">isInstance</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">x</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Return true if x implements ISeq"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.ISeq</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">x</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Return true if x is a Character"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/char?" title="Return true if x is a Character">char?</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/char?" title="Return true if x is a Character">char?</a></span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Character</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">x</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Return true if x is a String"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">String</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">x</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Return true if x implements IPersistentMap"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IPersistentMap</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">x</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Return true if x implements IPersistentVector"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IPersistentVector</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>]</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">kvs</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be <= (count vector)."</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace">
</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">assoc</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">kvs</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">assoc</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">kvs</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">kvs</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">kvs</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">kvs</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nnext" title="Same as (next (next x))">nnext</a></span><span class="whitespace"> </span><span class="symbol">kvs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="string">"assoc expects even number of arguments after map/vector, found odd number"</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;;;;;;;; metadata ;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">obj</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Returns the metadata of obj, returns nil if there is no metadata."</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IMeta</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.IMeta</span></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span>^<span class="java-class">clojure.lang.IObj</span></span><span class="whitespace"> </span><span class="symbol">obj</span><span class="whitespace"> </span><span class="symbol">m</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Returns an object of the same type and value as obj, with
    map m as its metadata."</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.IObj</span></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">m</span>]</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="symbol">withMeta</span><span class="whitespace"> </span><span class="symbol">m</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace"> </span><span class="keyword">:dynamic</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="symbol">assert-valid-fdecl</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">fdecl</span>]</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="symbol">sigs</span><span class="whitespace">
</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">fdecl</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="symbol">assert-valid-fdecl</span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">asig</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">fdecl</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">arglist</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span class="comment">;elide implicit macro args</span><span class="whitespace">
</span><span class="whitespace">                 </span><span class="symbol">arglist</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Util/<span class="symbol">equals</span></span><span class="whitespace"> </span><span>'<span class="symbol">&form</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">arglist</span>)</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">subvec</span></span><span class="whitespace"> </span><span class="symbol">arglist</span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">count</span></span><span class="whitespace"> </span><span class="symbol">arglist</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">arglist</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span class="symbol">body</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">body</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">body</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span class="symbol">arglist</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">arglist</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">arglist</span>)</span><span class="whitespace"> </span><span>{}</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">body</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span class="symbol">arglist</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span class="symbol">arglist</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">resolve-tag</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">argvec</span>]</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">argvec</span>)</span><span class="whitespace">
</span><span class="whitespace">                              </span><span>^<span class="java-class">clojure.lang.Symbol</span></span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span>(<span class="keyword">:tag</span><span class="whitespace"> </span><span class="symbol">m</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                          </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Symbol</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Util/<span class="symbol">equiv</span></span><span class="whitespace"> </span><span>(<span class="java-class">.indexOf</span><span class="whitespace"> </span><span>(<span class="java-class">.getName</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span><span class="whitespace"> </span><span class="string">"."</span>)</span><span class="whitespace"> </span><span class="unknown">-1</span>)</span><span class="whitespace">
</span><span class="whitespace">                              </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Util/<span class="symbol">equals</span></span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Compiler$HostExpr/<span class="symbol">maybeSpecialTag</span></span><span class="whitespace"> </span><span class="symbol">tag</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">c</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Compiler$HostExpr/<span class="symbol">maybeClass</span></span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span class="unknown">false</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                                  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace">
</span><span class="whitespace">                                    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span class="symbol">argvec</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="keyword">:tag</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Symbol/<span class="symbol">intern</span></span><span class="whitespace"> </span><span>(<span class="java-class">.getName</span><span class="whitespace"> </span><span class="symbol">c</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                    </span><span class="symbol">argvec</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span class="symbol">argvec</span>)</span><span class="whitespace">
</span><span class="whitespace">                              </span><span class="symbol">argvec</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span class="symbol">argvec</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="symbol">fdecls</span><span class="whitespace"> </span><span class="symbol">fdecl</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">fdecls</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="symbol">resolve-tag</span><span class="whitespace"> </span><span>(<span class="symbol">asig</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fdecls</span>)</span>)</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">fdecls</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">ret</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>(<span class="symbol">resolve-tag</span><span class="whitespace"> </span><span>(<span class="symbol">asig</span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">coll</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Return the last item in coll, in linear time"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/last" title="Return the last item in coll, in linear time">last</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/last" title="Return the last item in coll, in linear time">last</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">coll</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Return a seq of all but the last item in coll, in linear time"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/butlast" title="Return a seq of all but the last item in coll, in linear time">butlast</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/butlast" title="Return a seq of all but the last item in coll, in linear time">butlast</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions."</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">doc-string?</span><span class="whitespace"> </span><span class="symbol">attr-map?</span><span class="whitespace"> </span><span>[<span class="symbol">params*</span>]</span><span class="whitespace"> </span><span class="symbol">prepost-map?</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">doc-string?</span><span class="whitespace"> </span><span class="symbol">attr-map?</span><span class="whitespace"> </span><span>(<span>[<span class="symbol">params*</span>]</span><span class="whitespace"> </span><span class="symbol">prepost-map?</span><span class="whitespace"> </span><span class="symbol">body</span>)</span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace"> </span><span class="symbol">attr-map?</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>[<span class="symbol">&form</span><span class="whitespace"> </span><span class="symbol">&env</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">fdecl</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="comment">;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Symbol</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="unparsed">nil</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace"> </span><span class="string">"First argument to defn must be a symbol"</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>}</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>{}</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">fdecl</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span class="symbol">fdecl</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="symbol">m</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">fdecl</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span class="symbol">fdecl</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">fdecl</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span class="symbol">fdecl</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/last" title="Return the last item in coll, in linear time">last</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/last" title="Return the last item in coll, in linear time">last</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="symbol">m</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">fdecl</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/last" title="Return the last item in coll, in linear time">last</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/butlast" title="Return a seq of all but the last item in coll, in linear time">butlast</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span class="symbol">fdecl</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="macro">quote</span></span><span class="whitespace"> </span><span>(<span class="symbol">sigs</span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span>}</span><span class="whitespace"> </span><span class="symbol">m</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">inline</span><span class="whitespace"> </span><span>(<span class="keyword">:inline</span><span class="whitespace"> </span><span class="symbol">m</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span class="symbol">ifn</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">inline</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span class="symbol">iname</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">inline</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="comment">;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Util/<span class="symbol">equiv</span></span><span class="whitespace"> </span><span>'<span class="macro">fn</span></span><span class="whitespace"> </span><span class="symbol">ifn</span>)</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Symbol</span><span class="whitespace"> </span><span class="symbol">iname</span>)</span><span class="whitespace"> </span><span class="unknown">false</span><span class="whitespace"> </span><span class="unknown">true</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span class="comment">;; inserts the same fn name to the inline fn if it does not have one</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">ifn</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Symbol/<span class="symbol">intern</span></span><span class="whitespace"> </span><span>(<span class="java-class">.concat</span><span class="whitespace"> </span><span>(<span class="java-class">.getName</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Symbol</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span class="string">"__inliner"</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">inline</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span class="symbol">m</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span>{}</span>)</span><span class="whitespace"> </span><span class="symbol">m</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="macro">def</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">m</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span class="comment">;;todo - restore propagation of fn name</span><span class="whitespace">
</span><span class="whitespace">                </span><span class="comment">;;must figure out how to convey primitive hints to self calls first</span><span class="whitespace">
</span><span class="whitespace">								</span><span class="comment">;;(cons `fn fdecl)</span><span class="whitespace">
</span><span class="whitespace">								</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span>`<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span><span class="whitespace"> </span><span>{<span class="keyword">:rettag</span><span class="whitespace"> </span><span>(<span class="keyword">:tag</span><span class="whitespace"> </span><span class="symbol">m</span>)</span>}</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span>(<span class="macro">var</span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span>)</span><span class="whitespace"> </span><span>(<span class="symbol">setMacro</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/to-array" title="Returns an array of Objects containing the contents of coll, which
  can be any Collection.  Maps to java.util.Collection.toArray().">to-array</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns an array of Objects containing the contents of coll, which
  can be any Collection.  Maps to java.util.Collection.toArray()."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="string">"[Ljava.lang.Object;"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">toArray</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cast" title="Throws a ClassCastException if x is not a c, else returns x.">cast</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Throws a ClassCastException if x is not a c, else returns x."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Class</span></span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cast" title="Throws a ClassCastException if x is not a c, else returns x.">cast</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace"> </span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector" title="Creates a new vector containing the args.">vector</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates a new vector containing the args."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span>[]</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">a</span>]</span><span class="whitespace"> </span><span>[<span class="symbol">a</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span>]</span><span class="whitespace"> </span><span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span>]</span><span class="whitespace"> </span><span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">d</span>]</span><span class="whitespace"> </span><span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">d</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">	</span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span class="symbol">e</span>]</span><span class="whitespace"> </span><span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span class="symbol">e</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">	</span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span class="symbol">e</span><span class="whitespace"> </span><span class="symbol">f</span>]</span><span class="whitespace"> </span><span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span class="symbol">e</span><span class="whitespace"> </span><span class="symbol">f</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span class="symbol">e</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.LazilyPersistentVector</span><span class="whitespace"> </span><span>(<span class="symbol">create</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">e</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vec" title="Creates a new vector containing the contents of coll. Java arrays
  will be aliased and should not be modified.">vec</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates a new vector containing the contents of coll. Java arrays
  will be aliased and should not be modified."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IObj</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="java-class">clojure.lang.LazilyPersistentVector/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">clojure.lang.LazilyPersistentVector/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash-map" title="keyval =&gt; key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.">hash-map</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"keyval => key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span>{}</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">keyvals</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.PersistentHashMap</span><span class="whitespace"> </span><span>(<span class="symbol">create</span><span class="whitespace"> </span><span class="symbol">keyvals</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash-set" title="Returns a new hash set with supplied keys.  Any equal keys are
  handled as if by repeated uses of conj.">hash-set</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a new hash set with supplied keys.  Any equal keys are
  handled as if by repeated uses of conj."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span>#{}</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">clojure.lang.PersistentHashSet/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sorted-map" title="keyval =&gt; key val
  Returns a new sorted map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.">sorted-map</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"keyval => key val
  Returns a new sorted map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">keyvals</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">clojure.lang.PersistentTreeMap/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">keyvals</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sorted-map-by" title="keyval =&gt; key val
  Returns a new sorted map with supplied mappings, using the supplied
  comparator.  If any keys are equal, they are handled as if by
  repeated uses of assoc.">sorted-map-by</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"keyval => key val
  Returns a new sorted map with supplied mappings, using the supplied
  comparator.  If any keys are equal, they are handled as if by
  repeated uses of assoc."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comparator" title="Returns an implementation of java.util.Comparator based upon pred.">comparator</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">keyvals</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">clojure.lang.PersistentTreeMap/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comparator" title="Returns an implementation of java.util.Comparator based upon pred.">comparator</a></span><span class="whitespace"> </span><span class="symbol">keyvals</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sorted-set" title="Returns a new sorted set with supplied keys.  Any equal keys are
  handled as if by repeated uses of conj.">sorted-set</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a new sorted set with supplied keys.  Any equal keys are
  handled as if by repeated uses of conj."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">clojure.lang.PersistentTreeSet/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sorted-set-by" title="Returns a new sorted set with supplied keys, using the supplied
  comparator.  Any equal keys are handled as if by repeated uses of
  conj.">sorted-set-by</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a new sorted set with supplied keys, using the supplied
  comparator.  Any equal keys are handled as if by repeated uses of
  conj."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comparator" title="Returns an implementation of java.util.Comparator based upon pred.">comparator</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">clojure.lang.PersistentTreeSet/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comparator" title="Returns an implementation of java.util.Comparator based upon pred.">comparator</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x is nil, false otherwise."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">Boolean</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="java-class">clojure.lang.Util/<span class="symbol">identical</span></span></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span>)</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Util/<span class="symbol">identical</span></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called."</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">doc-string?</span><span class="whitespace"> </span><span class="symbol">attr-map?</span><span class="whitespace"> </span><span>[<span class="symbol">params*</span>]</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">doc-string?</span><span class="whitespace"> </span><span class="symbol">attr-map?</span><span class="whitespace"> </span><span>(<span>[<span class="symbol">params*</span>]</span><span class="whitespace"> </span><span class="symbol">body</span>)</span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace"> </span><span class="symbol">attr-map?</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&form</span><span class="whitespace"> </span><span class="symbol">&env</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">prefix</span><span class="whitespace"> </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">p</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span class="symbol">args</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">args</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                              </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span><span class="whitespace"> </span><span class="symbol">f</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">p</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span class="symbol">f</span>)</span><span class="whitespace">
</span><span class="whitespace">                                  </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">p</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                  </span><span class="symbol">p</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">fdecl</span><span class="whitespace"> </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">fd</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fd</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">fd</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fd</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                               </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">fd</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                               </span><span class="symbol">fd</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">fdecl</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">fdecl</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">add-implicit-args</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">fd</span>]</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">args</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fd</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                               </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vec" title="Creates a new vector containing the contents of coll. Java arrays
  will be aliased and should not be modified.">vec</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>'<span class="symbol">&form</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>'<span class="symbol">&env</span></span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">fd</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">add-args</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">acc</span><span class="whitespace"> </span><span class="symbol">ds</span>]</span><span class="whitespace">
</span><span class="whitespace">                              </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">ds</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span class="symbol">acc</span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">d</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ds</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                                  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span class="symbol">d</span>)</span><span class="whitespace">
</span><span class="whitespace">                                    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">acc</span><span class="whitespace"> </span><span class="symbol">d</span>)</span><span class="whitespace">
</span><span class="whitespace">                                    </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">acc</span><span class="whitespace"> </span><span>(<span class="symbol">add-implicit-args</span><span class="whitespace"> </span><span class="symbol">d</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ds</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">fdecl</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span>(<span class="symbol">add-args</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">decl</span><span class="whitespace"> </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">prefix</span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span class="symbol">fdecl</span>]</span><span class="whitespace">
</span><span class="whitespace">                          </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">p</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">p</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">p</span>)</span><span class="whitespace"> </span><span class="symbol">d</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span class="symbol">d</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="macro">do</span></span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span>`<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="symbol">decl</span>)</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="java-class">.</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="macro">var</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span>'<span>(<span class="symbol">setMacro</span>)</span></span>)</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="macro">var</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span>(<span class="macro">var</span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span>)</span><span class="whitespace"> </span><span>(<span class="symbol">setMacro</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Evaluates test. If logical true, evaluates body in an implicit do."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="macro">if</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>'<span class="macro">do</span></span><span class="whitespace"> </span><span class="symbol">body</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Evaluates test. If logical false, evaluates body in an implicit do."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="macro">if</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>'<span class="macro">do</span></span><span class="whitespace"> </span><span class="symbol">body</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/false?" title="Returns true if x is the value false, false otherwise.">false?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x is the value false, false otherwise."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">Boolean</span><span class="whitespace">,</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Util/<span class="symbol">identical</span></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="unknown">false</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/true?" title="Returns true if x is the value true, false otherwise.">true?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x is the value true, false otherwise."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">Boolean</span><span class="whitespace">,</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Util/<span class="symbol">identical</span></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="unknown">true</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x is logical false, false otherwise."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">Boolean</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="unknown">false</span><span class="whitespace"> </span><span class="unknown">true</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some?" title="Returns true if x is not nil, false otherwise.">some?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x is not nil, false otherwise."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">Boolean</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.6"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">String</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="string">""</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">Object</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="string">""</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="symbol">toString</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">ys</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">StringBuilder</span></span><span class="whitespace"> </span><span class="symbol">sb</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">more</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">sb</span><span class="whitespace">  </span><span>(<span class="symbol">append</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="symbol">sb</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">StringBuilder</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">ys</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Return true if x is a Symbol"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Symbol</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Return true if x is a Keyword"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Keyword</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol" title="Returns a Symbol with the given namespace and name.">symbol</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a Symbol with the given namespace and name."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Symbol</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>]</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Symbol/<span class="symbol">intern</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Symbol/<span class="symbol">intern</span></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is 'G__'."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"G__"</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">prefix-string</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Symbol</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/intern" title="Finds or creates a var named by the symbol name in the namespace
  ns (which can be a symbol or a namespace), setting its root binding
  to val if supplied. The namespace must exist. The var will adopt any
  metadata from the name symbol.  Returns the var.">intern</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="symbol">prefix-string</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">nextID</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn't evaluate any of the
  other tests or exprs. (cond) returns nil."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">clauses</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">clauses</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="macro">if</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">clauses</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">clauses</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">clauses</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace">
</span><span class="whitespace">                         </span><span class="string">"cond requires an even number of forms"</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>'<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">clojure.core/cond</a></span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">clauses</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword" title="Returns a Keyword with the given namespace and name.  Do not use :
  in the keyword strings, it will be added automatically.">keyword</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a Keyword with the given namespace and name.  Do not use :
  in the keyword strings, it will be added automatically."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Keyword</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Keyword/<span class="symbol">intern</span></span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Symbol</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Keyword/<span class="symbol">intern</span></span><span class="whitespace"> </span><span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Keyword/<span class="symbol">intern</span></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find-keyword" title="Returns a Keyword with the given namespace and name if one already
  exists.  This function will not intern a new keyword. If the keyword
  has not already been interned, it will return nil.  Do not use :
  in the keyword strings, it will be added automatically.">find-keyword</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a Keyword with the given namespace and name if one already
  exists.  This function will not intern a new keyword. If the keyword
  has not already been interned, it will return nil.  Do not use :
  in the keyword strings, it will be added automatically."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Keyword</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Keyword/<span class="symbol">find</span></span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Symbol</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Keyword/<span class="symbol">find</span></span><span class="whitespace"> </span><span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Keyword/<span class="symbol">find</span></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="symbol">spread</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">arglist</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">arglist</span>)</span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">arglist</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">arglist</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:else</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">arglist</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">spread</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">arglist</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list*" title="Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.">list*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span>(<span class="symbol">spread</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Applies fn f to the argument list formed by prepending intervening arguments to args."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.IFn</span></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">applyTo</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.IFn</span></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">applyTo</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list*" title="Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.">list*</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.IFn</span></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">applyTo</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list*" title="Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.">list*</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.IFn</span></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">applyTo</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list*" title="Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.">list*</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.IFn</span></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">applyTo</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span>(<span class="symbol">spread</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vary-meta" title="Returns an object of the same type and value as obj, with
  (apply f (meta obj) args) as its metadata.">vary-meta</a></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="string">"Returns an object of the same type and value as obj, with
  (apply f (meta obj) args) as its metadata."</span><span class="whitespace">
</span><span class="whitespace"> </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace"> </span><span>[<span class="symbol">obj</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span class="symbol">obj</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">obj</span>)</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="symbol">new</span></span><span class="whitespace"> </span><span>'<span class="java-class">clojure.lang.LazySeq</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list*" title="Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.">list*</a></span><span class="whitespace"> </span><span>'<span>^<span>{<span class="keyword">:once</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span></span><span class="whitespace"> </span><span class="symbol">fn*</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="symbol">body</span>)</span>)</span>)</span><span class="whitespace">    </span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.ChunkBuffer</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-buffer">chunk-buffer</a></span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.ChunkBuffer</span></span><span class="whitespace"> </span><span>[<span class="symbol">capacity</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">clojure.lang.ChunkBuffer.</span><span class="whitespace"> </span><span class="symbol">capacity</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-append">chunk-append</a></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.ChunkBuffer</span></span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.add</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.IChunk</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk">chunk</a></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.ChunkBuffer</span></span><span class="whitespace"> </span><span class="symbol">b</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.chunk</span><span class="whitespace"> </span><span class="symbol">b</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace">  </span><span>^<span class="java-class">clojure.lang.IChunk</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-first">chunk-first</a></span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.IChunk</span></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.IChunkedSeq</span></span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.chunkedFirst</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.ISeq</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-rest">chunk-rest</a></span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.ISeq</span></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.IChunkedSeq</span></span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.chunkedMore</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.ISeq</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-next">chunk-next</a></span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.ISeq</span></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.IChunkedSeq</span></span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.chunkedNext</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-cons">chunk-cons</a></span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk">chunk</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Numbers/<span class="symbol">isZero</span></span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">count</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk">chunk</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">clojure.lang.ChunkedCons.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk">chunk</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunked-seq?">chunked-seq?</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IChunkedSeq</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/concat" title="Returns a lazy seq representing the concatenation of the elements in the supplied colls.">concat</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy seq representing the concatenation of the elements in the supplied colls."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunked-seq?">chunked-seq?</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-cons">chunk-cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-first">chunk-first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/concat" title="Returns a lazy seq representing the concatenation of the elements in the supplied colls.">concat</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-rest">chunk-rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/concat" title="Returns a lazy seq representing the concatenation of the elements in the supplied colls.">concat</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">y</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">zs</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cat" title="A transducer which concatenates the contents of each input, which must be a
  collection, into the reduction.">cat</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cat" title="A transducer which concatenates the contents of each input, which must be a
  collection, into the reduction.">cat</a></span><span class="whitespace"> </span><span>[<span class="symbol">xys</span><span class="whitespace"> </span><span class="symbol">zs</span>]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">xys</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">xys</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">xys</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunked-seq?">chunked-seq?</a></span><span class="whitespace"> </span><span class="symbol">xys</span>)</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-cons">chunk-cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-first">chunk-first</a></span><span class="whitespace"> </span><span class="symbol">xys</span>)</span><span class="whitespace">
</span><span class="whitespace">                                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cat" title="A transducer which concatenates the contents of each input, which must be a
  collection, into the reduction.">cat</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-rest">chunk-rest</a></span><span class="whitespace"> </span><span class="symbol">xys</span>)</span><span class="whitespace"> </span><span class="symbol">zs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">xys</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cat" title="A transducer which concatenates the contents of each input, which must be a
  collection, into the reduction.">cat</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">xys</span>)</span><span class="whitespace"> </span><span class="symbol">zs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">zs</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cat" title="A transducer which concatenates the contents of each input, which must be a
  collection, into the reduction.">cat</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">zs</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">zs</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cat" title="A transducer which concatenates the contents of each input, which must be a
  collection, into the reduction.">cat</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/concat" title="Returns a lazy seq representing the concatenation of the elements in the supplied colls.">concat</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">zs</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;;;;;;;at this point all the support for syntax-quote exists;;;;;;;;;;;;;;;;;;;;;;</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/delay" title="Takes a body of expressions and yields a Delay object that will
  invoke the body only the first time it is forced (with force or deref/@), and
  will cache the result and return it on all subsequent force
  calls. See also - realized?">delay</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a body of expressions and yields a Delay object that will
  invoke the body only the first time it is forced (with force or deref/@), and
  will cache the result and return it on all subsequent force
  calls. See also - realized?"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="symbol">new</span></span><span class="whitespace"> </span><span>'<span class="java-class">clojure.lang.Delay</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list*" title="Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.">list*</a></span><span class="whitespace"> </span>`<span>^<span>{<span class="keyword">:once</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace"> </span><span class="symbol">fn*</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="symbol">body</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/delay?" title="returns true if x is a Delay created with delay">delay?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"returns true if x is a Delay created with delay"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Delay</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/force" title="If x is a Delay, returns the (possibly cached) value of its expression, else returns x">force</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"If x is a Delay, returns the (possibly cached) value of its expression, else returns x"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Delay</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/force" title="If x is a Delay, returns the (possibly cached) value of its expression, else returns x">force</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-not" title="Evaluates test. If logical false, evaluates and returns then expr, 
  otherwise else expr, if supplied, else nil.">if-not</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Evaluates test. If logical false, evaluates and returns then expr, 
  otherwise else expr, if supplied, else nil."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="symbol">then</span>]</span><span class="whitespace"> </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-not" title="Evaluates test. If logical false, evaluates and returns then expr, 
  otherwise else expr, if supplied, else nil.">if-not</a></span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span>~<span class="symbol">then</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="symbol">then</span><span class="whitespace"> </span><span class="symbol">else</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span>`<span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span>)</span><span class="whitespace"> </span>~<span class="symbol">then</span><span class="whitespace"> </span>~<span class="symbol">else</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identical?" title="Tests if 2 arguments are the same object">identical?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Tests if 2 arguments are the same object"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Util</span><span class="whitespace"> </span><span class="symbol">identical</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Util/<span class="symbol">identical</span></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;equiv-based</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure's immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Util</span><span class="whitespace"> </span><span class="symbol">equiv</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Util/<span class="symbol">equiv</span></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Util/<span class="symbol">equiv</span></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="java-class">clojure.lang.Util/<span class="symbol">equiv</span></span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="unknown">false</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;equals-based</span><span class="whitespace">
</span><span class="metadata">#_</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Equality. Returns true if x equals y, false if not. Same as Java
  x.equals(y) except it also works for nil. Boxed numbers must have
  same type. Clojure's immutable data structures define equals() (and
  thus =) as a value, not an identity, comparison."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Util</span><span class="whitespace"> </span><span class="symbol">equals</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Util/<span class="symbol">equals</span></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="unknown">false</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not=" title="Same as (not (= obj1 obj2))">not=</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Same as (not (= obj1 obj2))"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">Boolean</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="unknown">false</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/compare" title="Comparator. Returns a negative number, zero, or a positive number
  when x is logically &apos;less than&apos;, &apos;equal to&apos;, or &apos;greater than&apos;
  y. Same as Java x.compareTo(y) except it also works for nil, and
  compares numbers and collections in a type-independent manner. x
  must implement Comparable">compare</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Comparator. Returns a negative number, zero, or a positive number
  when x is logically 'less than', 'equal to', or 'greater than'
  y. Same as Java x.compareTo(y) except it also works for nil, and
  compares numbers and collections in a type-independent manner. x
  must implement Comparable"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Util</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/compare" title="Comparator. Returns a negative number, zero, or a positive number
  when x is logically &apos;less than&apos;, &apos;equal to&apos;, or &apos;greater than&apos;
  y. Same as Java x.compareTo(y) except it also works for nil, and
  compares numbers and collections in a type-independent manner. x
  must implement Comparable">compare</a></span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Util</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/compare" title="Comparator. Returns a negative number, zero, or a positive number
  when x is logically &apos;less than&apos;, &apos;equal to&apos;, or &apos;greater than&apos;
  y. Same as Java x.compareTo(y) except it also works for nil, and
  compares numbers and collections in a type-independent manner. x
  must implement Comparable">compare</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn't evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span>]</span><span class="whitespace">
</span><span class="whitespace">   </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">and#</span><span class="whitespace"> </span>~<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">and#</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span>~<span class="unknown">@next</span>)</span><span class="whitespace"> </span><span class="symbol">and#</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn't
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span>]</span><span class="whitespace">
</span><span class="whitespace">      </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">or#</span><span class="whitespace"> </span>~<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">or#</span><span class="whitespace"> </span><span class="symbol">or#</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span>~<span class="unknown">@next</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;;;;;;;;;; sequence fns  ;;;;;;;;;;;;;;;;;;;;;;;</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/zero?" title="Returns true if num is zero, else false">zero?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if num is zero, else false"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">isZero</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">isZero</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">count</span></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to int"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(~<span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*unchecked-math*" title="While bound to true, compilations of +, -, *, inc, dec and the
  coercions will be done without overflow checks. While bound
  to :warn-on-boxed, same behavior as true, and a warning is emitted
  when compilation uses boxed math. Default: false.">*unchecked-math*</a></span><span class="whitespace"> </span><span>'<span class="symbol">uncheckedIntCast</span></span><span class="whitespace"> </span><span>'<span class="symbol">intCast</span></span>)</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">intCast</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nth" title="Returns the value at the index. get returns nil if index out of
  bounds, nth throws an exception unless not-found is supplied.  nth
  also works for strings, Java arrays, regex Matchers and Lists, and,
  in O(n) time, for sequences.">nth</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the value at the index. get returns nil if index out of
  bounds, nth throws an exception unless not-found is supplied.  nth
  also works for strings, Java arrays, regex Matchers and Lists, and,
  in O(n) time, for sequences."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">i</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">nf</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nth" title="Returns the value at the index. get returns nil if index out of
  bounds, nth throws an exception unless not-found is supplied.  nth
  also works for strings, Java arrays, regex Matchers and Lists, and,
  in O(n) time, for sequences.">nth</a></span><span class="whitespace"> </span>~<span class="symbol">c</span><span class="whitespace"> </span>~<span class="symbol">i</span><span class="whitespace"> </span>~<span class="unknown">@nf</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">2</span><span class="whitespace"> </span><span class="unknown">3</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">index</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nth" title="Returns the value at the index. get returns nil if index out of
  bounds, nth throws an exception unless not-found is supplied.  nth
  also works for strings, Java arrays, regex Matchers and Lists, and,
  in O(n) time, for sequences.">nth</a></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">index</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">index</span><span class="whitespace"> </span><span class="symbol">not-found</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nth" title="Returns the value at the index. get returns nil if index out of
  bounds, nth throws an exception unless not-found is supplied.  nth
  also works for strings, Java arrays, regex Matchers and Lists, and,
  in O(n) time, for sequences.">nth</a></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">index</span><span class="whitespace"> </span><span class="symbol">not-found</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns non-nil if nums are in monotonically increasing order,
  otherwise false."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">lt</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">lt</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="unknown">false</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc&apos;" title="Returns a number one greater than num. Supports arbitrary precision.
  See also: inc">inc'</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a number one greater than num. Supports arbitrary precision.
  See also: inc"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">incP</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">incP</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc'"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(~<span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*unchecked-math*" title="While bound to true, compilations of +, -, *, inc, dec and the
  coercions will be done without overflow checks. While bound
  to :warn-on-boxed, same behavior as true, and a warning is emitted
  when compilation uses boxed math. Default: false.">*unchecked-math*</a></span><span class="whitespace"> </span><span>'<span class="symbol">unchecked_inc</span></span><span class="whitespace"> </span><span>'<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span></span>)</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;; reduce is defined again later after InternalReduce loads</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:private</span></span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="symbol">reduce1</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="symbol">f</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunked-seq?">chunked-seq?</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="java-class">.reduce</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-first">chunk-first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-next">chunk-next</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reverse" title="Returns a seq of the items in coll in reverse order. Not lazy.">reverse</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a seq of the items in coll in reverse order. Not lazy."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>()</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;math stuff</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:private</span></span><span class="whitespace"> </span><span class="symbol">nary-inline</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">op</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">nary-inline</span><span class="whitespace"> </span><span class="symbol">op</span><span class="whitespace"> </span><span class="symbol">op</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">op</span><span class="whitespace"> </span><span class="symbol">unchecked-op</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">op</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*unchecked-math*" title="While bound to true, compilations of +, -, *, inc, dec and the
  coercions will be done without overflow checks. While bound
  to :warn-on-boxed, same behavior as true, and a warning is emitted
  when compilation uses boxed math. Default: false.">*unchecked-math*</a></span><span class="whitespace"> </span><span class="symbol">unchecked-op</span><span class="whitespace"> </span><span class="symbol">op</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(~<span class="symbol">op</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">op</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*unchecked-math*" title="While bound to true, compilations of +, -, *, inc, dec and the
  coercions will be done without overflow checks. While bound
  to :warn-on-boxed, same behavior as true, and a warning is emitted
  when compilation uses boxed math. Default: false.">*unchecked-math*</a></span><span class="whitespace"> </span><span class="symbol">unchecked-op</span><span class="whitespace"> </span><span class="symbol">op</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(~<span class="symbol">op</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">op</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*unchecked-math*" title="While bound to true, compilations of +, -, *, inc, dec and the
  coercions will be done without overflow checks. While bound
  to :warn-on-boxed, same behavior as true, and a warning is emitted
  when compilation uses boxed math. Default: false.">*unchecked-math*</a></span><span class="whitespace"> </span><span class="symbol">unchecked-op</span><span class="whitespace"> </span><span class="symbol">op</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="symbol">reduce1</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(~<span class="symbol">op</span><span class="whitespace"> </span>~<span class="symbol">a</span><span class="whitespace"> </span>~<span class="symbol">b</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">             </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(~<span class="symbol">op</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:private</span></span><span class="whitespace"> </span><span class="symbol">>1?</span><span class="whitespace"> </span><span>[<span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Numbers/<span class="symbol">gt</span></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="unknown">1</span>)</span>)</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:private</span></span><span class="whitespace"> </span><span class="symbol">>0?</span><span class="whitespace"> </span><span>[<span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Numbers/<span class="symbol">gt</span></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="unknown">0</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+&apos;" title="Returns the sum of nums. (+&apos;) returns 0. Supports arbitrary precision.
  See also: +">+'</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the sum of nums. (+') returns 0. Supports arbitrary precision.
  See also: +"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="symbol">nary-inline</span><span class="whitespace"> </span><span>'<span class="symbol">addP</span></span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span class="symbol">>1?</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unknown">0</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cast" title="Throws a ClassCastException if x is not a c, else returns x.">cast</a></span><span class="whitespace"> </span><span class="java-class">Number</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">addP</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+&apos;" title="Returns the sum of nums. (+&apos;) returns 0. Supports arbitrary precision.
  See also: +">+'</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+&apos;" title="Returns the sum of nums. (+&apos;) returns 0. Supports arbitrary precision.
  See also: +">+'</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +'"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="symbol">nary-inline</span><span class="whitespace"> </span><span>'<span class="symbol">add</span></span><span class="whitespace"> </span><span>'<span class="symbol">unchecked_add</span></span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span class="symbol">>1?</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unknown">0</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cast" title="Throws a ClassCastException if x is not a c, else returns x.">cast</a></span><span class="whitespace"> </span><span class="java-class">Number</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">add</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*&apos;" title="Returns the product of nums. (*&apos;) returns 1. Supports arbitrary precision.
  See also: *">*'</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the product of nums. (*') returns 1. Supports arbitrary precision.
  See also: *"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="symbol">nary-inline</span><span class="whitespace"> </span><span>'<span class="symbol">multiplyP</span></span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span class="symbol">>1?</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unknown">1</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cast" title="Throws a ClassCastException if x is not a c, else returns x.">cast</a></span><span class="whitespace"> </span><span class="java-class">Number</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">multiplyP</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*&apos;" title="Returns the product of nums. (*&apos;) returns 1. Supports arbitrary precision.
  See also: *">*'</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*&apos;" title="Returns the product of nums. (*&apos;) returns 1. Supports arbitrary precision.
  See also: *">*'</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*" title="Returns the product of nums. (*) returns 1. Does not auto-promote
  longs, will throw on overflow. See also: *&apos;">*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the product of nums. (*) returns 1. Does not auto-promote
  longs, will throw on overflow. See also: *'"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="symbol">nary-inline</span><span class="whitespace"> </span><span>'<span class="symbol">multiply</span></span><span class="whitespace"> </span><span>'<span class="symbol">unchecked_multiply</span></span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span class="symbol">>1?</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unknown">1</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cast" title="Throws a ClassCastException if x is not a c, else returns x.">cast</a></span><span class="whitespace"> </span><span class="java-class">Number</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">multiply</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*" title="Returns the product of nums. (*) returns 1. Does not auto-promote
  longs, will throw on overflow. See also: *&apos;">*</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*" title="Returns the product of nums. (*) returns 1. Does not auto-promote
  longs, will throw on overflow. See also: *&apos;">*</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core//" title="If no denominators are supplied, returns 1/numerator,
  else returns numerator divided by all of the denominators.">/</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"If no denominators are supplied, returns 1/numerator,
  else returns numerator divided by all of the denominators."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="symbol">nary-inline</span><span class="whitespace"> </span><span>'<span class="symbol">divide</span></span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span class="symbol">>1?</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core//" title="If no denominators are supplied, returns 1/numerator,
  else returns numerator divided by all of the denominators.">/</a></span><span class="whitespace"> </span><span class="unknown">1</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">divide</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core//" title="If no denominators are supplied, returns 1/numerator,
  else returns numerator divided by all of the denominators.">/</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core//" title="If no denominators are supplied, returns 1/numerator,
  else returns numerator divided by all of the denominators.">/</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/-&apos;" title="If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Supports arbitrary precision.
  See also: -">-'</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Supports arbitrary precision.
  See also: -"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="symbol">nary-inline</span><span class="whitespace"> </span><span>'<span class="symbol">minusP</span></span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span class="symbol">>0?</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">minusP</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">minusP</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/-&apos;" title="If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Supports arbitrary precision.
  See also: -">-'</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/-&apos;" title="If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Supports arbitrary precision.
  See also: -">-'</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/-" title="If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Does not auto-promote
  longs, will throw on overflow. See also: -&apos;">-</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Does not auto-promote
  longs, will throw on overflow. See also: -'"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="symbol">nary-inline</span><span class="whitespace"> </span><span>'<span class="symbol">minus</span></span><span class="whitespace"> </span><span>'<span class="symbol">unchecked_minus</span></span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span class="symbol">>0?</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">minus</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">minus</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/-" title="If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Does not auto-promote
  longs, will throw on overflow. See also: -&apos;">-</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/-" title="If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Does not auto-promote
  longs, will throw on overflow. See also: -&apos;">-</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;=" title="Returns non-nil if nums are in monotonically non-decreasing order,
  otherwise false."><=</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns non-nil if nums are in monotonically non-decreasing order,
  otherwise false."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">lte</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">lte</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;=" title="Returns non-nil if nums are in monotonically non-decreasing order,
  otherwise false."><=</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;=" title="Returns non-nil if nums are in monotonically non-decreasing order,
  otherwise false."><=</a></span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="unknown">false</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&gt;" title="Returns non-nil if nums are in monotonically decreasing order,
  otherwise false.">></a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns non-nil if nums are in monotonically decreasing order,
  otherwise false."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">gt</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">gt</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&gt;" title="Returns non-nil if nums are in monotonically decreasing order,
  otherwise false.">></a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&gt;" title="Returns non-nil if nums are in monotonically decreasing order,
  otherwise false.">></a></span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="unknown">false</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&gt;=" title="Returns non-nil if nums are in monotonically non-increasing order,
  otherwise false.">>=</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns non-nil if nums are in monotonically non-increasing order,
  otherwise false."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">gte</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">gte</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&gt;=" title="Returns non-nil if nums are in monotonically non-increasing order,
  otherwise false.">>=</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&gt;=" title="Returns non-nil if nums are in monotonically non-increasing order,
  otherwise false.">>=</a></span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="unknown">false</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/==" title="Returns non-nil if nums all have the equivalent
  value (type-independent), otherwise false">==</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns non-nil if nums all have the equivalent
  value (type-independent), otherwise false"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">equiv</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">equiv</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/==" title="Returns non-nil if nums all have the equivalent
  value (type-independent), otherwise false">==</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/==" title="Returns non-nil if nums all have the equivalent
  value (type-independent), otherwise false">==</a></span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="unknown">false</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/max" title="Returns the greatest of the nums.">max</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the greatest of the nums."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span class="symbol">>1?</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="symbol">nary-inline</span><span class="whitespace"> </span><span>'<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/max" title="Returns the greatest of the nums.">max</a></span></span>)</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/max" title="Returns the greatest of the nums.">max</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/max" title="Returns the greatest of the nums.">max</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/max" title="Returns the greatest of the nums.">max</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/min" title="Returns the least of the nums.">min</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the least of the nums."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span class="symbol">>1?</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="symbol">nary-inline</span><span class="whitespace"> </span><span>'<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/min" title="Returns the least of the nums.">min</a></span></span>)</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/min" title="Returns the least of the nums.">min</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/min" title="Returns the least of the nums.">min</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/min" title="Returns the least of the nums.">min</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dec&apos;" title="Returns a number one less than num. Supports arbitrary precision.
  See also: dec">dec'</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a number one less than num. Supports arbitrary precision.
  See also: dec"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">decP</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">decP</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dec" title="Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec&apos;">dec</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec'"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(~<span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*unchecked-math*" title="While bound to true, compilations of +, -, *, inc, dec and the
  coercions will be done without overflow checks. While bound
  to :warn-on-boxed, same behavior as true, and a warning is emitted
  when compilation uses boxed math. Default: false.">*unchecked-math*</a></span><span class="whitespace"> </span><span>'<span class="symbol">unchecked_dec</span></span><span class="whitespace"> </span><span>'<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dec" title="Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec&apos;">dec</a></span></span>)</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dec" title="Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec&apos;">dec</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-inc-int" title="Returns a number one greater than x, an int.
  Note - uses a primitive operator subject to overflow.">unchecked-inc-int</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a number one greater than x, an int.
  Note - uses a primitive operator subject to overflow."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_inc</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_inc</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-inc" title="Returns a number one greater than x, a long.
  Note - uses a primitive operator subject to overflow.">unchecked-inc</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a number one greater than x, a long.
  Note - uses a primitive operator subject to overflow."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_inc</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_inc</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-dec-int" title="Returns a number one less than x, an int.
  Note - uses a primitive operator subject to overflow.">unchecked-dec-int</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a number one less than x, an int.
  Note - uses a primitive operator subject to overflow."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_dec</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_dec</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-dec" title="Returns a number one less than x, a long.
  Note - uses a primitive operator subject to overflow.">unchecked-dec</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a number one less than x, a long.
  Note - uses a primitive operator subject to overflow."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_dec</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_dec</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-negate-int" title="Returns the negation of x, an int.
  Note - uses a primitive operator subject to overflow.">unchecked-negate-int</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the negation of x, an int.
  Note - uses a primitive operator subject to overflow."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_negate</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_negate</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-negate" title="Returns the negation of x, a long.
  Note - uses a primitive operator subject to overflow.">unchecked-negate</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the negation of x, a long.
  Note - uses a primitive operator subject to overflow."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_minus</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_minus</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-add-int" title="Returns the sum of x and y, both int.
  Note - uses a primitive operator subject to overflow.">unchecked-add-int</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the sum of x and y, both int.
  Note - uses a primitive operator subject to overflow."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_add</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_add</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-add" title="Returns the sum of x and y, both long.
  Note - uses a primitive operator subject to overflow.">unchecked-add</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the sum of x and y, both long.
  Note - uses a primitive operator subject to overflow."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_add</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_add</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-subtract-int" title="Returns the difference of x and y, both int.
  Note - uses a primitive operator subject to overflow.">unchecked-subtract-int</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the difference of x and y, both int.
  Note - uses a primitive operator subject to overflow."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_subtract</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_subtract</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-subtract" title="Returns the difference of x and y, both long.
  Note - uses a primitive operator subject to overflow.">unchecked-subtract</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the difference of x and y, both long.
  Note - uses a primitive operator subject to overflow."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_minus</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_minus</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-multiply-int" title="Returns the product of x and y, both int.
  Note - uses a primitive operator subject to overflow.">unchecked-multiply-int</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the product of x and y, both int.
  Note - uses a primitive operator subject to overflow."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_multiply</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_multiply</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-multiply" title="Returns the product of x and y, both long.
  Note - uses a primitive operator subject to overflow.">unchecked-multiply</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the product of x and y, both long.
  Note - uses a primitive operator subject to overflow."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_multiply</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_multiply</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-divide-int" title="Returns the division of x by y, both int.
  Note - uses a primitive operator subject to truncation.">unchecked-divide-int</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the division of x by y, both int.
  Note - uses a primitive operator subject to truncation."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_divide</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_divide</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-remainder-int" title="Returns the remainder of division of x by y, both int.
  Note - uses a primitive operator subject to truncation.">unchecked-remainder-int</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the remainder of division of x by y, both int.
  Note - uses a primitive operator subject to truncation."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_remainder</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unchecked_int_remainder</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if num is greater than zero, else false"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">isPos</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">isPos</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/neg?" title="Returns true if num is less than zero, else false">neg?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if num is less than zero, else false"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">isNeg</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">isNeg</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/quot" title="quot[ient] of dividing numerator by denominator.">quot</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"quot[ient] of dividing numerator by denominator."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">quotient</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/num" title="Coerce to Number">num</a></span><span class="whitespace"> </span><span class="symbol">div</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">quotient</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/num" title="Coerce to Number">num</a></span><span class="whitespace"> </span><span class="symbol">div</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rem" title="remainder of dividing numerator by denominator.">rem</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"remainder of dividing numerator by denominator."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">remainder</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">y</span>)</span>)</span>)</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/num" title="Coerce to Number">num</a></span><span class="whitespace"> </span><span class="symbol">div</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">remainder</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/num" title="Coerce to Number">num</a></span><span class="whitespace"> </span><span class="symbol">div</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rationalize" title="returns the rational value of num">rationalize</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"returns the rational value of num"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/num" title="Coerce to Number">num</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rationalize" title="returns the rational value of num">rationalize</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/num" title="Coerce to Number">num</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;Bit ops</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-not" title="Bitwise complement">bit-not</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Bitwise complement"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-and" title="Bitwise and">bit-and</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Bitwise and"</span><span class="whitespace">
</span><span class="whitespace">   </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="symbol">nary-inline</span><span class="whitespace"> </span><span>'<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span></span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span class="symbol">>1?</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-and" title="Bitwise and">bit-and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-and" title="Bitwise and">bit-and</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-or" title="Bitwise or">bit-or</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Bitwise or"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="symbol">nary-inline</span><span class="whitespace"> </span><span>'<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span></span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span class="symbol">>1?</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-or" title="Bitwise or">bit-or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-or" title="Bitwise or">bit-or</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-xor" title="Bitwise exclusive or">bit-xor</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Bitwise exclusive or"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="symbol">nary-inline</span><span class="whitespace"> </span><span>'<span class="symbol">xor</span></span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span class="symbol">>1?</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">xor</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-xor" title="Bitwise exclusive or">bit-xor</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-xor" title="Bitwise exclusive or">bit-xor</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-and-not" title="Bitwise and with complement">bit-and-not</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Bitwise and with complement"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="symbol">nary-inline</span><span class="whitespace"> </span><span>'<span class="symbol">andNot</span></span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span class="symbol">>1?</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">andNot</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-and-not" title="Bitwise and with complement">bit-and-not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-and-not" title="Bitwise and with complement">bit-and-not</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-clear" title="Clear bit at index n">bit-clear</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Clear bit at index n"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">clearBit</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-set" title="Set bit at index n">bit-set</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Set bit at index n"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">setBit</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-flip" title="Flip bit at index n">bit-flip</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Flip bit at index n"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">flipBit</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-test" title="Test bit at index n">bit-test</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Test bit at index n"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">testBit</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-shift-left" title="Bitwise shift left">bit-shift-left</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Bitwise shift left"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">shiftLeft</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">n</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">shiftLeft</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-shift-right" title="Bitwise shift right">bit-shift-right</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Bitwise shift right"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">shiftRight</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">n</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">shiftRight</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unsigned-bit-shift-right" title="Bitwise shift right, without sign-extension.">unsigned-bit-shift-right</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Bitwise shift right, without sign-extension."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="symbol">unsignedShiftRight</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">n</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.6"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">unsignedShiftRight</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/integer?" title="Returns true if n is an integer">integer?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if n is an integer"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">n</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Integer</span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Long</span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.BigInt</span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">BigInteger</span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Short</span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Byte</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/even?" title="Returns true if n is even, throws an exception if n is not an integer">even?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if n is even, throws an exception if n is not an integer"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span>[<span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/integer?" title="Returns true if n is an integer">integer?</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/zero?" title="Returns true if num is zero, else false">zero?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-and" title="Bitwise and">bit-and</a></span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">uncheckedLongCast</span></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace"> </span><span class="unknown">1</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Argument must be an integer: "</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/odd?" title="Returns true if n is odd, throws an exception if n is not an integer">odd?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if n is odd, throws an exception if n is not an integer"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/even?" title="Returns true if n is even, throws an exception if n is not an integer">even?</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/complement" title="Takes a fn f and returns a fn that takes the same arguments as f,
  has the same effects, if any, and returns the opposite truth value.">complement</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a fn f and returns a fn that takes the same arguments as f,
  has the same effects, if any, and returns the opposite truth value."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">f</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="symbol">f</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">zs</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">zs</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/constantly" title="Returns a function that takes any number of arguments and returns x.">constantly</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a function that takes any number of arguments and returns x."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identity" title="Returns its argument.">identity</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns its argument."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;Collection stuff</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;list stuff</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/peek" title="For a list or queue, same as first, for a vector, same as, but much
  more efficient than, last. If the collection is empty, returns nil.">peek</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"For a list or queue, same as first, for a vector, same as, but much
  more efficient than, last. If the collection is empty, returns nil."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/peek" title="For a list or queue, same as first, for a vector, same as, but much
  more efficient than, last. If the collection is empty, returns nil.">peek</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pop" title="For a list or queue, returns a new list/queue without the first
  item, for a vector, returns a new vector without the last item. If
  the collection is empty, throws an exception.  Note - not the same
  as next/butlast.">pop</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"For a list or queue, returns a new list/queue without the first
  item, for a vector, returns a new vector without the last item. If
  the collection is empty, throws an exception.  Note - not the same
  as next/butlast."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pop" title="For a list or queue, returns a new list/queue without the first
  item, for a vector, returns a new vector without the last item. If
  the collection is empty, throws an exception.  Note - not the same
  as next/butlast.">pop</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;map stuff</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map-entry?" title="Return true if x is a map entry">map-entry?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Return true if x is a map entry"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.8"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">	</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">java.util.Map$Entry</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. 'contains?' operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also 'some'."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">contains</span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the value mapped to key, not-found or nil if key not present."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">nf</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span>~<span class="symbol">m</span><span class="whitespace"> </span>~<span class="symbol">k</span><span class="whitespace"> </span>~<span class="unknown">@nf</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">2</span><span class="whitespace"> </span><span class="unknown">3</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="symbol">not-found</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="symbol">not-found</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dissoc" title="dissoc[iate]. Returns a new map of the same (hashed/sorted) type,
  that does not contain a mapping for key(s).">dissoc</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"dissoc[iate]. Returns a new map of the same (hashed/sorted) type,
  that does not contain a mapping for key(s)."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span>]</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dissoc" title="dissoc[iate]. Returns a new map of the same (hashed/sorted) type,
  that does not contain a mapping for key(s).">dissoc</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">ks</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dissoc" title="dissoc[iate]. Returns a new map of the same (hashed/sorted) type,
  that does not contain a mapping for key(s).">dissoc</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">ks</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/disj" title="disj[oin]. Returns a new set of the same (hashed/sorted) type, that
  does not contain key(s).">disj</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"disj[oin]. Returns a new set of the same (hashed/sorted) type, that
  does not contain key(s)."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span>]</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.IPersistentSet</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span>(<span class="symbol">disjoin</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">ks</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/disj" title="disj[oin]. Returns a new set of the same (hashed/sorted) type, that
  does not contain key(s).">disj</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">ks</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find" title="Returns the map entry for key, or nil if key not present.">find</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the map entry for key, or nil if key not present."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find" title="Returns the map entry for key, or nil if key not present.">find</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/select-keys" title="Returns a map containing only those entries in map whose key is in keys">select-keys</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a map containing only those entries in map whose key is in keys"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">keyseq</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>{}</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">keyseq</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">entry</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find" title="Returns the map entry for key, or nil if key not present.">find</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">recur</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">entry</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">entry</span>)</span><span class="whitespace">
</span><span class="whitespace">             </span><span class="symbol">ret</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a sequence of the map's keys, in the same order as (seq map)."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vals" title="Returns a sequence of the map&apos;s values, in the same order as (seq map).">vals</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a sequence of the map's values, in the same order as (seq map)."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vals" title="Returns a sequence of the map&apos;s values, in the same order as (seq map).">vals</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the key of the map entry."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">java.util.Map$Entry</span></span><span class="whitespace"> </span><span class="symbol">e</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">e</span><span class="whitespace"> </span><span>(<span class="symbol">getKey</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the value in the map entry."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">java.util.Map$Entry</span></span><span class="whitespace"> </span><span class="symbol">e</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">e</span><span class="whitespace"> </span><span>(<span class="symbol">getValue</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rseq" title="Returns, in constant time, a seq of the items in rev (which
  can be a vector or sorted-map), in reverse order. If rev is empty returns nil">rseq</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns, in constant time, a seq of the items in rev (which
  can be a vector or sorted-map), in reverse order. If rev is empty returns nil"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Reversible</span></span><span class="whitespace"> </span><span class="symbol">rev</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">rev</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rseq" title="Returns, in constant time, a seq of the items in rev (which
  can be a vector or sorted-map), in reverse order. If rev is empty returns nil">rseq</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the name String of a string, symbol or keyword."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">String</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Named</span></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="symbol">getName</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/namespace" title="Returns the namespace String of a symbol or keyword, or nil if not present.">namespace</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the namespace String of a symbol or keyword, or nil if not present."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">String</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Named</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="symbol">getNamespace</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/locking" title="Executes exprs in an implicit do, while holding the monitor of x.
  Will release the monitor of x in all circumstances.">locking</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Executes exprs in an implicit do, while holding the monitor of x.
  Will release the monitor of x in all circumstances."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">lockee#</span><span class="whitespace"> </span>~<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">try</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">monitor-enter</span><span class="whitespace"> </span><span class="symbol">lockee#</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span>~<span class="unknown">@body</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">finally</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="symbol">monitor-exit</span><span class="whitespace"> </span><span class="symbol">lockee#</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="java-class">..</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"form => fieldName-symbol or (instanceMethodName-symbol args*)

  Expands into a member access (.) of the first member on the first
  argument, followed by the next member on the result, etc. For
  instance:

  (.. System (getProperties) (get \"os.name\"))

  expands to:

  (. (. System (getProperties)) (get \"os.name\"))

  but is easier to write, read, and understand."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">form</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">form</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">form</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">..</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="symbol">form</span>)</span><span class="whitespace"> </span>~<span class="unknown">@more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">forms</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace">, </span><span class="symbol">forms</span><span class="whitespace"> </span><span class="symbol">forms</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">forms</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">form</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">forms</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">threaded</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span class="symbol">form</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span>`<span>(~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">form</span>)</span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">form</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">form</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span class="symbol">form</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">threaded</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">forms</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;&gt;" title="Threads the expr through the forms. Inserts x as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  last item in second form, etc.">->></a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Threads the expr through the forms. Inserts x as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  last item in second form, etc."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">forms</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace">, </span><span class="symbol">forms</span><span class="whitespace"> </span><span class="symbol">forms</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">forms</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">form</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">forms</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">threaded</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span class="symbol">form</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span>`<span>(~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">form</span>)</span><span class="whitespace"> </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">form</span>)</span><span class="whitespace">  </span>~<span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">form</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span class="symbol">form</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">threaded</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">forms</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:private</span></span><span class="whitespace"> </span><span class="symbol">check-valid-options</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Throws an exception if the given option map contains keys not listed
  as valid, else returns nil."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">options</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">valid-keys</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/disj" title="disj[oin]. Returns a new set of the same (hashed/sorted) type, that
  does not contain key(s).">disj</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash-set" title="Returns a new hash set with supplied keys.  Any equal keys are
  handled as if by repeated uses of conj.">hash-set</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">valid-keys</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">throw</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Only these options are valid: "</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">valid-keys</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">", "</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">valid-keys</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;multimethods</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span class="symbol">global-hierarchy</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmulti" title="Creates a new multimethod with the associated dispatch function.
  The docstring and attr-map are optional.

  Options are key-value pairs and may be one of:

  :default

  The default dispatch value, defaults to :default

  :hierarchy

  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)

  Hierarchies are type-like relationships that do not depend upon type
  inheritance. By default Clojure&apos;s multimethods dispatch off of a
  global hierarchy map.  However, a hierarchy relationship can be
  created with the derive function used to augment the root ancestor
  created with make-hierarchy.

  Multimethods expect the value of the hierarchy option to be supplied as
  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #&apos;
  or the var special form).">defmulti</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates a new multimethod with the associated dispatch function.
  The docstring and attr-map are optional.

  Options are key-value pairs and may be one of:

  :default

  The default dispatch value, defaults to :default

  :hierarchy

  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)

  Hierarchies are type-like relationships that do not depend upon type
  inheritance. By default Clojure's multimethods dispatch off of a
  global hierarchy map.  However, a hierarchy relationship can be
  created with the derive function used to augment the root ancestor
  created with make-hierarchy.

  Multimethods expect the value of the hierarchy option to be supplied as
  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #'
  or the var special form)."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">docstring?</span><span class="whitespace"> </span><span class="symbol">attr-map?</span><span class="whitespace"> </span><span class="symbol">dispatch-fn</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">options</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">mm-name</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">options</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">docstring</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">options</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span class="symbol">options</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">m</span><span class="whitespace">           </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>{}</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">options</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span class="symbol">options</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">dispatch-fn</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">options</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">m</span><span class="whitespace">           </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">docstring</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="symbol">docstring</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span class="symbol">m</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">m</span><span class="whitespace">           </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">mm-name</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">mm-name</span>)</span><span class="whitespace"> </span><span class="symbol">m</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span class="symbol">m</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span><span class="whitespace"> </span><span class="unknown">1</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">Exception.</span><span class="whitespace"> </span><span class="string">"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)"</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">options</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash-map" title="keyval =&gt; key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.">hash-map</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">default</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">options</span><span class="whitespace"> </span><span class="keyword">:default</span><span class="whitespace"> </span><span class="keyword">:default</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">hierarchy</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">options</span><span class="whitespace"> </span><span class="keyword">:hierarchy</span><span class="whitespace"> </span><span>#'<span class="var-ref">global-hierarchy</span></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">check-valid-options</span><span class="whitespace"> </span><span class="symbol">options</span><span class="whitespace"> </span><span class="keyword">:default</span><span class="whitespace"> </span><span class="keyword">:hierarchy</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">v#</span><span class="whitespace"> </span><span>(<span class="macro">def</span><span class="whitespace"> </span>~<span class="symbol">mm-name</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="java-class">.hasRoot</span><span class="whitespace"> </span><span class="symbol">v#</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.MultiFn</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/deref" title="Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,
  returns the in-transaction-value of ref, else returns the
  most-recently-committed value of ref. When applied to a var, agent
  or atom, returns its current state. When applied to a delay, forces
  it if not already forced. When applied to a future, will block if
  computation not complete. When applied to a promise, will block
  until a value is delivered.  The variant taking a timeout can be
  used for blocking references (futures and promises), and will return
  timeout-val if the timeout (in milliseconds) is reached before a
  value is available. See also - realized?.">deref</a></span><span class="whitespace"> </span><span class="symbol">v#</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">def</span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span class="symbol">mm-name</span><span class="whitespace"> </span><span class="symbol">m</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">clojure.lang.MultiFn</span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">mm-name</span>)</span><span class="whitespace"> </span>~<span class="symbol">dispatch-fn</span><span class="whitespace"> </span>~<span class="symbol">default</span><span class="whitespace"> </span>~<span class="symbol">hierarchy</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmethod" title="Creates and installs a new method of multimethod associated with dispatch-value. ">defmethod</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates and installs a new method of multimethod associated with dispatch-value. "</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">multifn</span><span class="whitespace"> </span><span class="symbol">dispatch-val</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">fn-tail</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span class="symbol">multifn</span><span class="whitespace"> </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span>'<span class="java-class">clojure.lang.MultiFn</span></span>}</span>)</span><span class="whitespace"> </span><span class="symbol">addMethod</span><span class="whitespace"> </span>~<span class="symbol">dispatch-val</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span>~<span class="unknown">@fn-tail</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/remove-all-methods" title="Removes all of the methods of multimethod.">remove-all-methods</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Removes all of the methods of multimethod."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.MultiFn</span></span><span class="whitespace"> </span><span class="symbol">multifn</span>]</span><span class="whitespace">
</span><span class="whitespace"> </span><span>(<span class="java-class">.reset</span><span class="whitespace"> </span><span class="symbol">multifn</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/remove-method" title="Removes the method of multimethod associated with dispatch-value.">remove-method</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Removes the method of multimethod associated with dispatch-value."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.MultiFn</span></span><span class="whitespace"> </span><span class="symbol">multifn</span><span class="whitespace"> </span><span class="symbol">dispatch-val</span>]</span><span class="whitespace">
</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">multifn</span><span class="whitespace"> </span><span class="symbol">removeMethod</span><span class="whitespace"> </span><span class="symbol">dispatch-val</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/prefer-method" title="Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y 
   when there is a conflict">prefer-method</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y 
   when there is a conflict"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.MultiFn</span></span><span class="whitespace"> </span><span class="symbol">multifn</span><span class="whitespace"> </span><span class="symbol">dispatch-val-x</span><span class="whitespace"> </span><span class="symbol">dispatch-val-y</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">multifn</span><span class="whitespace"> </span><span class="symbol">preferMethod</span><span class="whitespace"> </span><span class="symbol">dispatch-val-x</span><span class="whitespace"> </span><span class="symbol">dispatch-val-y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/methods" title="Given a multimethod, returns a map of dispatch values -&gt; dispatch fns">methods</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Given a multimethod, returns a map of dispatch values -> dispatch fns"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.MultiFn</span></span><span class="whitespace"> </span><span class="symbol">multifn</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.getMethodTable</span><span class="whitespace"> </span><span class="symbol">multifn</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get-method" title="Given a multimethod and a dispatch value, returns the dispatch fn
  that would apply to that value, or nil if none apply and no default">get-method</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Given a multimethod and a dispatch value, returns the dispatch fn
  that would apply to that value, or nil if none apply and no default"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.MultiFn</span></span><span class="whitespace"> </span><span class="symbol">multifn</span><span class="whitespace"> </span><span class="symbol">dispatch-val</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.getMethod</span><span class="whitespace"> </span><span class="symbol">multifn</span><span class="whitespace"> </span><span class="symbol">dispatch-val</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/prefers" title="Given a multimethod, returns a map of preferred value -&gt; set of other values">prefers</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Given a multimethod, returns a map of preferred value -> set of other values"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.MultiFn</span></span><span class="whitespace"> </span><span class="symbol">multifn</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.getPreferTable</span><span class="whitespace"> </span><span class="symbol">multifn</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;; var stuff</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace"> </span><span class="symbol">assert-args</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">pairs</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="macro">do</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">pairs</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span>~<span>'<span class="symbol">&form</span></span>)</span><span class="whitespace"> </span><span class="string">" requires "</span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">pairs</span>)</span><span class="whitespace"> </span><span class="string">" in "</span><span class="whitespace"> </span>~<span>'<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*ns*" title="A clojure.lang.Namespace object representing the current namespace.">*ns*</a></span></span><span class="whitespace"> </span><span class="string">":"</span><span class="whitespace"> </span><span>(<span class="keyword">:line</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span>~<span>'<span class="symbol">&form</span></span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span>~<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">more</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nnext" title="Same as (next (next x))">nnext</a></span><span class="whitespace"> </span><span class="symbol">pairs</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">more</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list*" title="Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.">list*</a></span><span class="whitespace"> </span>`<span class="symbol">assert-args</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"bindings => binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">then</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace"> </span>~<span class="symbol">bindings</span><span class="whitespace"> </span>~<span class="symbol">then</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">then</span><span class="whitespace"> </span><span class="symbol">else</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">oldform</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="symbol">assert-args</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace"> </span><span class="string">"a vector for its binding"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">oldform</span>)</span><span class="whitespace"> </span><span class="string">"1 or 2 forms after binding vector"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span><span class="whitespace"> </span><span class="string">"exactly 2 forms in binding vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">form</span><span class="whitespace"> </span><span>(<span class="symbol">bindings</span><span class="whitespace"> </span><span class="unknown">0</span>)</span><span class="whitespace"> </span><span class="symbol">tst</span><span class="whitespace"> </span><span>(<span class="symbol">bindings</span><span class="whitespace"> </span><span class="unknown">1</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">temp#</span><span class="whitespace"> </span>~<span class="symbol">tst</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">temp#</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">form</span><span class="whitespace"> </span><span class="symbol">temp#</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span>~<span class="symbol">then</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span>~<span class="symbol">else</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"bindings => binding-form test

  When test is true, evaluates body with binding-form bound to the value of test"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">assert-args</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace"> </span><span class="string">"a vector for its binding"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span><span class="whitespace"> </span><span class="string">"exactly 2 forms in binding vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">form</span><span class="whitespace"> </span><span>(<span class="symbol">bindings</span><span class="whitespace"> </span><span class="unknown">0</span>)</span><span class="whitespace"> </span><span class="symbol">tst</span><span class="whitespace"> </span><span>(<span class="symbol">bindings</span><span class="whitespace"> </span><span class="unknown">1</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">temp#</span><span class="whitespace"> </span>~<span class="symbol">tst</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">temp#</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">form</span><span class="whitespace"> </span><span class="symbol">temp#</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span>~<span class="unknown">@body</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-some" title="bindings =&gt; binding-form test

   If test is not nil, evaluates then with binding-form bound to the
   value of test, if not, yields else">if-some</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"bindings => binding-form test

   If test is not nil, evaluates then with binding-form bound to the
   value of test, if not, yields else"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.6"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">then</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-some" title="bindings =&gt; binding-form test

   If test is not nil, evaluates then with binding-form bound to the
   value of test, if not, yields else">if-some</a></span><span class="whitespace"> </span>~<span class="symbol">bindings</span><span class="whitespace"> </span>~<span class="symbol">then</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">then</span><span class="whitespace"> </span><span class="symbol">else</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">oldform</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="symbol">assert-args</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace"> </span><span class="string">"a vector for its binding"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">oldform</span>)</span><span class="whitespace"> </span><span class="string">"1 or 2 forms after binding vector"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span><span class="whitespace"> </span><span class="string">"exactly 2 forms in binding vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">form</span><span class="whitespace"> </span><span>(<span class="symbol">bindings</span><span class="whitespace"> </span><span class="unknown">0</span>)</span><span class="whitespace"> </span><span class="symbol">tst</span><span class="whitespace"> </span><span>(<span class="symbol">bindings</span><span class="whitespace"> </span><span class="unknown">1</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">temp#</span><span class="whitespace"> </span>~<span class="symbol">tst</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">temp#</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span>~<span class="symbol">else</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">form</span><span class="whitespace"> </span><span class="symbol">temp#</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span>~<span class="symbol">then</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-some" title="bindings =&gt; binding-form test

   When test is not nil, evaluates body with binding-form bound to the
   value of test">when-some</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"bindings => binding-form test

   When test is not nil, evaluates body with binding-form bound to the
   value of test"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.6"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">assert-args</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace"> </span><span class="string">"a vector for its binding"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span><span class="whitespace"> </span><span class="string">"exactly 2 forms in binding vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">form</span><span class="whitespace"> </span><span>(<span class="symbol">bindings</span><span class="whitespace"> </span><span class="unknown">0</span>)</span><span class="whitespace"> </span><span class="symbol">tst</span><span class="whitespace"> </span><span>(<span class="symbol">bindings</span><span class="whitespace"> </span><span class="unknown">1</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">temp#</span><span class="whitespace"> </span>~<span class="symbol">tst</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">temp#</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="unparsed">nil</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">form</span><span class="whitespace"> </span><span class="symbol">temp#</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span>~<span class="unknown">@body</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/push-thread-bindings" title="WARNING: This is a low-level function. Prefer high-level macros like
  binding where ever possible.

  Takes a map of Var/value pairs. Binds each Var to the associated value for
  the current thread. Each call *MUST* be accompanied by a matching call to
  pop-thread-bindings wrapped in a try-finally!
  
      (push-thread-bindings bindings)
      (try
        ...
        (finally
          (pop-thread-bindings)))">push-thread-bindings</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"WARNING: This is a low-level function. Prefer high-level macros like
  binding where ever possible.

  Takes a map of Var/value pairs. Binds each Var to the associated value for
  the current thread. Each call *MUST* be accompanied by a matching call to
  pop-thread-bindings wrapped in a try-finally!
  
      (push-thread-bindings bindings)
      (try
        ...
        (finally
          (pop-thread-bindings)))"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">bindings</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">clojure.lang.Var/<span class="symbol">pushThreadBindings</span></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pop-thread-bindings" title="Pop one set of bindings pushed with push-binding before. It is an error to
  pop bindings without pushing before.">pop-thread-bindings</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Pop one set of bindings pushed with push-binding before. It is an error to
  pop bindings without pushing before."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">clojure.lang.Var/<span class="symbol">popThreadBindings</span></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get-thread-bindings" title="Get a map with the Var/value pairs which is currently in effect for the
  current thread.">get-thread-bindings</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Get a map with the Var/value pairs which is currently in effect for the
  current thread."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">clojure.lang.Var/<span class="symbol">getThreadBindings</span></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/binding" title="binding =&gt; var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.">binding</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"binding => var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">assert-args</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace"> </span><span class="string">"a vector for its binding"</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/even?" title="Returns true if n is even, throws an exception if n is not an integer">even?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span><span class="whitespace"> </span><span class="string">"an even number of forms in binding vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">var-ize</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">var-vals</span>]</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="symbol">vvs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">var-vals</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">vvs</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="macro">recur</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span>`<span>(<span class="macro">var</span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">vvs</span>)</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">vvs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">vvs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/push-thread-bindings" title="WARNING: This is a low-level function. Prefer high-level macros like
  binding where ever possible.

  Takes a map of Var/value pairs. Binds each Var to the associated value for
  the current thread. Each call *MUST* be accompanied by a matching call to
  pop-thread-bindings wrapped in a try-finally!
  
      (push-thread-bindings bindings)
      (try
        ...
        (finally
          (pop-thread-bindings)))">push-thread-bindings</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash-map" title="keyval =&gt; key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.">hash-map</a></span><span class="whitespace"> </span>~<span class="unparsed">@</span><span>(<span class="symbol">var-ize</span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">try</span><span class="whitespace">
</span><span class="whitespace">         </span>~<span class="unknown">@body</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="symbol">finally</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pop-thread-bindings" title="Pop one set of bindings pushed with push-binding before. It is an error to
  pop bindings without pushing before.">pop-thread-bindings</a></span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-bindings*" title="Takes a map of Var/value pairs. Installs for the given Vars the associated
  values as thread-local bindings. Then calls f with the supplied arguments.
  Pops the installed bindings after f returned. Returns whatever f returns.">with-bindings*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a map of Var/value pairs. Installs for the given Vars the associated
  values as thread-local bindings. Then calls f with the supplied arguments.
  Pops the installed bindings after f returned. Returns whatever f returns."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">binding-map</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/push-thread-bindings" title="WARNING: This is a low-level function. Prefer high-level macros like
  binding where ever possible.

  Takes a map of Var/value pairs. Binds each Var to the associated value for
  the current thread. Each call *MUST* be accompanied by a matching call to
  pop-thread-bindings wrapped in a try-finally!
  
      (push-thread-bindings bindings)
      (try
        ...
        (finally
          (pop-thread-bindings)))">push-thread-bindings</a></span><span class="whitespace"> </span><span class="symbol">binding-map</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">try</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">args</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">finally</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pop-thread-bindings" title="Pop one set of bindings pushed with push-binding before. It is an error to
  pop bindings without pushing before.">pop-thread-bindings</a></span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-bindings" title="Takes a map of Var/value pairs. Installs for the given Vars the associated
  values as thread-local bindings. Then executes body. Pops the installed
  bindings after body was evaluated. Returns the value of body.">with-bindings</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a map of Var/value pairs. Installs for the given Vars the associated
  values as thread-local bindings. Then executes body. Pops the installed
  bindings after body was evaluated. Returns the value of body."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">binding-map</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-bindings*" title="Takes a map of Var/value pairs. Installs for the given Vars the associated
  values as thread-local bindings. Then calls f with the supplied arguments.
  Pops the installed bindings after f returned. Returns whatever f returns.">with-bindings*</a></span><span class="whitespace"> </span>~<span class="symbol">binding-map</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span>~<span class="unknown">@body</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bound-fn*" title="Returns a function, which will install the same bindings in effect as in
  the thread at the time bound-fn* was called and then call f with any given
  arguments. This may be used to define a helper function which runs on a
  different thread, but needs the same bindings in place.">bound-fn*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a function, which will install the same bindings in effect as in
  the thread at the time bound-fn* was called and then call f with any given
  arguments. This may be used to define a helper function which runs on a
  different thread, but needs the same bindings in place."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">f</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get-thread-bindings" title="Get a map with the Var/value pairs which is currently in effect for the
  current thread.">get-thread-bindings</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-bindings*" title="Takes a map of Var/value pairs. Installs for the given Vars the associated
  values as thread-local bindings. Then calls f with the supplied arguments.
  Pops the installed bindings after f returned. Returns whatever f returns.">with-bindings*</a></span><span class="whitespace"> </span><span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/bound-fn" title="Returns a function defined by the given fntail, which will install the
  same bindings in effect as in the thread at the time bound-fn was called.
  This may be used to define a helper function which runs on a different
  thread, but needs the same bindings in place.">bound-fn</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a function defined by the given fntail, which will install the
  same bindings in effect as in the thread at the time bound-fn was called.
  This may be used to define a helper function which runs on a different
  thread, but needs the same bindings in place."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">fntail</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bound-fn*" title="Returns a function, which will install the same bindings in effect as in
  the thread at the time bound-fn* was called and then call f with any given
  arguments. This may be used to define a helper function which runs on a
  different thread, but needs the same bindings in place.">bound-fn*</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span>~<span class="unknown">@fntail</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find-var" title="Returns the global var named by the namespace-qualified symbol, or
  nil if no var with that name.">find-var</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the global var named by the namespace-qualified symbol, or
  nil if no var with that name."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">sym</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Var</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find" title="Returns the map entry for key, or nil if key not present.">find</a></span><span class="whitespace"> </span><span class="symbol">sym</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="symbol">binding-conveyor-fn</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">f</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">frame</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Var/<span class="symbol">cloneThreadBindingFrame</span></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span>[]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="java-class">clojure.lang.Var/<span class="symbol">resetThreadBindingFrame</span></span><span class="whitespace"> </span><span class="symbol">frame</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="symbol">f</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="java-class">clojure.lang.Var/<span class="symbol">resetThreadBindingFrame</span></span><span class="whitespace"> </span><span class="symbol">frame</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="java-class">clojure.lang.Var/<span class="symbol">resetThreadBindingFrame</span></span><span class="whitespace"> </span><span class="symbol">frame</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="java-class">clojure.lang.Var/<span class="symbol">resetThreadBindingFrame</span></span><span class="whitespace"> </span><span class="symbol">frame</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="java-class">clojure.lang.Var/<span class="symbol">resetThreadBindingFrame</span></span><span class="whitespace"> </span><span class="symbol">frame</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Refs ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="symbol">setup-reference</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.ARef</span></span><span class="whitespace"> </span><span class="symbol">r</span><span class="whitespace"> </span><span class="symbol">options</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">opts</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash-map" title="keyval =&gt; key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.">hash-map</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="keyword">:meta</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="java-class">.resetMeta</span><span class="whitespace"> </span><span class="symbol">r</span><span class="whitespace"> </span><span>(<span class="keyword">:meta</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="keyword">:validator</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="java-class">.setValidator</span><span class="whitespace"> </span><span class="symbol">r</span><span class="whitespace"> </span><span>(<span class="keyword">:validator</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="symbol">r</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/agent" title="Creates and returns an agent with an initial value of state and
  zero or more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :error-handler handler-fn

  :error-mode mode-keyword

  If metadata-map is supplied, it will become the metadata on the
  agent. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.  handler-fn is called if an
  action throws an exception or if validate-fn rejects a new state --
  see set-error-handler! for details.  The mode-keyword may be either
  :continue (the default if an error-handler is given) or :fail (the
  default if no error-handler is given) -- see set-error-mode! for
  details.">agent</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates and returns an agent with an initial value of state and
  zero or more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :error-handler handler-fn

  :error-mode mode-keyword

  If metadata-map is supplied, it will become the metadata on the
  agent. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.  handler-fn is called if an
  action throws an exception or if validate-fn rejects a new state --
  see set-error-handler! for details.  The mode-keyword may be either
  :continue (the default if an error-handler is given) or :fail (the
  default if no error-handler is given) -- see set-error-mode! for
  details."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">state</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">options</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Agent</span><span class="whitespace"> </span><span class="symbol">state</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span class="symbol">opts</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash-map" title="keyval =&gt; key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.">hash-map</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="symbol">setup-reference</span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">options</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="keyword">:error-handler</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="java-class">.setErrorHandler</span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="keyword">:error-handler</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="java-class">.setErrorMode</span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="keyword">:error-mode</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="keyword">:error-handler</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span><span class="whitespace"> </span><span class="keyword">:continue</span><span class="whitespace"> </span><span class="keyword">:fail</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span class="symbol">a</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set-agent-send-executor!" title="Sets the ExecutorService to be used by send">set-agent-send-executor!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Sets the ExecutorService to be used by send"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.5"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">executor</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">set!</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Agent/<span class="symbol">pooledExecutor</span></span><span class="whitespace"> </span><span class="symbol">executor</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set-agent-send-off-executor!" title="Sets the ExecutorService to be used by send-off">set-agent-send-off-executor!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Sets the ExecutorService to be used by send-off"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.5"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">executor</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">set!</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Agent/<span class="symbol">soloExecutor</span></span><span class="whitespace"> </span><span class="symbol">executor</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/send-via" title="Dispatch an action to an agent. Returns the agent immediately.
  Subsequently, in a thread supplied by executor, the state of the agent
  will be set to the value of:

  (apply action-fn state-of-agent args)">send-via</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Dispatch an action to an agent. Returns the agent immediately.
  Subsequently, in a thread supplied by executor, the state of the agent
  will be set to the value of:

  (apply action-fn state-of-agent args)"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.5"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">executor</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Agent</span></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.dispatch</span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/binding" title="binding =&gt; var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.">binding</a></span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*agent*" title="The agent currently running an action on this thread, else nil">*agent*</a></span><span class="whitespace"> </span><span class="symbol">a</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">binding-conveyor-fn</span><span class="whitespace"> </span><span class="symbol">f</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">args</span><span class="whitespace"> </span><span class="symbol">executor</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/send" title="Dispatch an action to an agent. Returns the agent immediately.
  Subsequently, in a thread from a thread pool, the state of the agent
  will be set to the value of:

  (apply action-fn state-of-agent args)">send</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Dispatch an action to an agent. Returns the agent immediately.
  Subsequently, in a thread from a thread pool, the state of the agent
  will be set to the value of:

  (apply action-fn state-of-agent args)"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Agent</span></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/send-via" title="Dispatch an action to an agent. Returns the agent immediately.
  Subsequently, in a thread supplied by executor, the state of the agent
  will be set to the value of:

  (apply action-fn state-of-agent args)">send-via</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Agent/<span class="symbol">pooledExecutor</span></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/send-off" title="Dispatch a potentially blocking action to an agent. Returns the
  agent immediately. Subsequently, in a separate thread, the state of
  the agent will be set to the value of:

  (apply action-fn state-of-agent args)">send-off</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Dispatch a potentially blocking action to an agent. Returns the
  agent immediately. Subsequently, in a separate thread, the state of
  the agent will be set to the value of:

  (apply action-fn state-of-agent args)"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Agent</span></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/send-via" title="Dispatch an action to an agent. Returns the agent immediately.
  Subsequently, in a thread supplied by executor, the state of the agent
  will be set to the value of:

  (apply action-fn state-of-agent args)">send-via</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Agent/<span class="symbol">soloExecutor</span></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/release-pending-sends" title="Normally, actions sent directly or indirectly during another action
  are held until the action completes (changes the agent&apos;s
  state). This function can be used to dispatch any pending sent
  actions immediately. This has no impact on actions sent during a
  transaction, which are still held until commit. If no action is
  occurring, does nothing. Returns the number of actions dispatched.">release-pending-sends</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Normally, actions sent directly or indirectly during another action
  are held until the action completes (changes the agent's
  state). This function can be used to dispatch any pending sent
  actions immediately. This has no impact on actions sent during a
  transaction, which are still held until commit. If no action is
  occurring, does nothing. Returns the number of actions dispatched."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Agent/<span class="symbol">releasePendingSends</span></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/add-watch" title="Adds a watch function to an agent/atom/var/ref reference. The watch
  fn must be a fn of 4 args: a key, the reference, its old-state, its
  new-state. Whenever the reference&apos;s state might have been changed,
  any registered watches will have their functions called. The watch fn
  will be called synchronously, on the agent&apos;s thread if an agent,
  before any pending sends if agent or ref. Note that an atom&apos;s or
  ref&apos;s state may have changed again prior to the fn call, so use
  old/new-state rather than derefing the reference. Note also that watch
  fns may be called from multiple threads simultaneously. Var watchers
  are triggered only by root binding changes, not thread-local
  set!s. Keys must be unique per reference, and can be used to remove
  the watch with remove-watch, but are otherwise considered opaque by
  the watch mechanism.">add-watch</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Adds a watch function to an agent/atom/var/ref reference. The watch
  fn must be a fn of 4 args: a key, the reference, its old-state, its
  new-state. Whenever the reference's state might have been changed,
  any registered watches will have their functions called. The watch fn
  will be called synchronously, on the agent's thread if an agent,
  before any pending sends if agent or ref. Note that an atom's or
  ref's state may have changed again prior to the fn call, so use
  old/new-state rather than derefing the reference. Note also that watch
  fns may be called from multiple threads simultaneously. Var watchers
  are triggered only by root binding changes, not thread-local
  set!s. Keys must be unique per reference, and can be used to remove
  the watch with remove-watch, but are otherwise considered opaque by
  the watch mechanism."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.IRef</span></span><span class="whitespace"> </span><span class="symbol">reference</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="macro">fn</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.addWatch</span><span class="whitespace"> </span><span class="symbol">reference</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="macro">fn</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/remove-watch" title="Removes a watch (set by add-watch) from a reference">remove-watch</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Removes a watch (set by add-watch) from a reference"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.IRef</span></span><span class="whitespace"> </span><span class="symbol">reference</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.removeWatch</span><span class="whitespace"> </span><span class="symbol">reference</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/agent-error" title="Returns the exception thrown during an asynchronous action of the
  agent if the agent is failed.  Returns nil if the agent is not
  failed.">agent-error</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the exception thrown during an asynchronous action of the
  agent if the agent is failed.  Returns nil if the agent is not
  failed."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Agent</span></span><span class="whitespace"> </span><span class="symbol">a</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.getError</span><span class="whitespace"> </span><span class="symbol">a</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/restart-agent" title="When an agent is failed, changes the agent state to new-state and
  then un-fails the agent so that sends are allowed again.  If
  a :clear-actions true option is given, any actions queued on the
  agent that were being held while it was failed will be discarded,
  otherwise those held actions will proceed.  The new-state must pass
  the validator if any, or restart will throw an exception and the
  agent will remain failed with its old state and error.  Watchers, if
  any, will NOT be notified of the new state.  Throws an exception if
  the agent is not failed.">restart-agent</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"When an agent is failed, changes the agent state to new-state and
  then un-fails the agent so that sends are allowed again.  If
  a :clear-actions true option is given, any actions queued on the
  agent that were being held while it was failed will be discarded,
  otherwise those held actions will proceed.  The new-state must pass
  the validator if any, or restart will throw an exception and the
  agent will remain failed with its old state and error.  Watchers, if
  any, will NOT be notified of the new state.  Throws an exception if
  the agent is not failed."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Agent</span></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace">, </span><span class="symbol">new-state</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">options</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">opts</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash-map" title="keyval =&gt; key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.">hash-map</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.restart</span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">new-state</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="keyword">:clear-actions</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace"> </span><span class="unknown">false</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set-error-handler!" title="Sets the error-handler of agent a to handler-fn.  If an action
  being run by the agent throws an exception or doesn&apos;t pass the
  validator fn, handler-fn will be called with two arguments: the
  agent and the exception.">set-error-handler!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Sets the error-handler of agent a to handler-fn.  If an action
  being run by the agent throws an exception or doesn't pass the
  validator fn, handler-fn will be called with two arguments: the
  agent and the exception."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Agent</span></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace">, </span><span class="symbol">handler-fn</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.setErrorHandler</span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">handler-fn</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/error-handler" title="Returns the error-handler of agent a, or nil if there is none.
  See set-error-handler!">error-handler</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the error-handler of agent a, or nil if there is none.
  See set-error-handler!"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Agent</span></span><span class="whitespace"> </span><span class="symbol">a</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.getErrorHandler</span><span class="whitespace"> </span><span class="symbol">a</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set-error-mode!" title="Sets the error-mode of agent a to mode-keyword, which must be
  either :fail or :continue.  If an action being run by the agent
  throws an exception or doesn&apos;t pass the validator fn, an
  error-handler may be called (see set-error-handler!), after which,
  if the mode is :continue, the agent will continue as if neither the
  action that caused the error nor the error itself ever happened.
  
  If the mode is :fail, the agent will become failed and will stop
  accepting new &apos;send&apos; and &apos;send-off&apos; actions, and any previously
  queued actions will be held until a &apos;restart-agent&apos;.  Deref will
  still work, returning the state of the agent before the error.">set-error-mode!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Sets the error-mode of agent a to mode-keyword, which must be
  either :fail or :continue.  If an action being run by the agent
  throws an exception or doesn't pass the validator fn, an
  error-handler may be called (see set-error-handler!), after which,
  if the mode is :continue, the agent will continue as if neither the
  action that caused the error nor the error itself ever happened.
  
  If the mode is :fail, the agent will become failed and will stop
  accepting new 'send' and 'send-off' actions, and any previously
  queued actions will be held until a 'restart-agent'.  Deref will
  still work, returning the state of the agent before the error."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Agent</span></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace">, </span><span class="symbol">mode-keyword</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.setErrorMode</span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">mode-keyword</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/error-mode" title="Returns the error-mode of agent a.  See set-error-mode!">error-mode</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the error-mode of agent a.  See set-error-mode!"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Agent</span></span><span class="whitespace"> </span><span class="symbol">a</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.getErrorMode</span><span class="whitespace"> </span><span class="symbol">a</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/agent-errors" title="DEPRECATED: Use &apos;agent-error&apos; instead.
  Returns a sequence of the exceptions thrown during asynchronous
  actions of the agent.">agent-errors</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"DEPRECATED: Use 'agent-error' instead.
  Returns a sequence of the exceptions thrown during asynchronous
  actions of the agent."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:deprecated</span><span class="whitespace"> </span><span class="string">"1.2"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">a</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">e</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/agent-error" title="Returns the exception thrown during an asynchronous action of the
  agent if the agent is failed.  Returns nil if the agent is not
  failed.">agent-error</a></span><span class="whitespace"> </span><span class="symbol">a</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span class="symbol">e</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/clear-agent-errors" title="DEPRECATED: Use &apos;restart-agent&apos; instead.
  Clears any exceptions thrown during asynchronous actions of the
  agent, allowing subsequent actions to occur.">clear-agent-errors</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"DEPRECATED: Use 'restart-agent' instead.
  Clears any exceptions thrown during asynchronous actions of the
  agent, allowing subsequent actions to occur."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:deprecated</span><span class="whitespace"> </span><span class="string">"1.2"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Agent</span></span><span class="whitespace"> </span><span class="symbol">a</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/restart-agent" title="When an agent is failed, changes the agent state to new-state and
  then un-fails the agent so that sends are allowed again.  If
  a :clear-actions true option is given, any actions queued on the
  agent that were being held while it was failed will be discarded,
  otherwise those held actions will proceed.  The new-state must pass
  the validator if any, or restart will throw an exception and the
  agent will remain failed with its old state and error.  Watchers, if
  any, will NOT be notified of the new state.  Throws an exception if
  the agent is not failed.">restart-agent</a></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="java-class">.deref</span><span class="whitespace"> </span><span class="symbol">a</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/shutdown-agents" title="Initiates a shutdown of the thread pools that back the agent
  system. Running actions will complete, but no new actions will be
  accepted">shutdown-agents</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Initiates a shutdown of the thread pools that back the agent
  system. Running actions will complete, but no new actions will be
  accepted"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Agent</span><span class="whitespace"> </span><span class="symbol">shutdown</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Ref</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">options</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">r</span><span class="whitespace">  </span><span>^<span class="java-class">clojure.lang.Ref</span></span><span class="whitespace"> </span><span>(<span class="symbol">setup-reference</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="symbol">options</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">opts</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash-map" title="keyval =&gt; key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.">hash-map</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="keyword">:max-history</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="java-class">.setMaxHistory</span><span class="whitespace"> </span><span class="symbol">r</span><span class="whitespace"> </span><span>(<span class="keyword">:max-history</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="keyword">:min-history</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="java-class">.setMinHistory</span><span class="whitespace"> </span><span class="symbol">r</span><span class="whitespace"> </span><span>(<span class="keyword">:min-history</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="symbol">r</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:private</span></span><span class="whitespace"> </span><span class="symbol">deref-future</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">java.util.concurrent.Future</span></span><span class="whitespace"> </span><span class="symbol">fut</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">.get</span><span class="whitespace"> </span><span class="symbol">fut</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">java.util.concurrent.Future</span></span><span class="whitespace"> </span><span class="symbol">fut</span><span class="whitespace"> </span><span class="symbol">timeout-ms</span><span class="whitespace"> </span><span class="symbol">timeout-val</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">try</span><span class="whitespace"> </span><span>(<span class="java-class">.get</span><span class="whitespace"> </span><span class="symbol">fut</span><span class="whitespace"> </span><span class="symbol">timeout-ms</span><span class="whitespace"> </span><span class="java-class">java.util.concurrent.TimeUnit/<span class="symbol">MILLISECONDS</span></span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="symbol">catch</span><span class="whitespace"> </span><span class="java-class">java.util.concurrent.TimeoutException</span><span class="whitespace"> </span><span class="symbol">e</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">timeout-val</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/deref" title="Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,
  returns the in-transaction-value of ref, else returns the
  most-recently-committed value of ref. When applied to a var, agent
  or atom, returns its current state. When applied to a delay, forces
  it if not already forced. When applied to a future, will block if
  computation not complete. When applied to a promise, will block
  until a value is delivered.  The variant taking a timeout can be
  used for blocking references (futures and promises), and will return
  timeout-val if the timeout (in milliseconds) is reached before a
  value is available. See also - realized?.">deref</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,
  returns the in-transaction-value of ref, else returns the
  most-recently-committed value of ref. When applied to a var, agent
  or atom, returns its current state. When applied to a delay, forces
  it if not already forced. When applied to a future, will block if
  computation not complete. When applied to a promise, will block
  until a value is delivered.  The variant taking a timeout can be
  used for blocking references (futures and promises), and will return
  timeout-val if the timeout (in milliseconds) is reached before a
  value is available. See also - realized?."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span>]</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IDeref</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="java-class">.deref</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.IDeref</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="symbol">deref-future</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span class="symbol">timeout-ms</span><span class="whitespace"> </span><span class="symbol">timeout-val</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IBlockingDeref</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="java-class">.deref</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.IBlockingDeref</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span class="symbol">timeout-ms</span><span class="whitespace"> </span><span class="symbol">timeout-val</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="symbol">deref-future</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span class="symbol">timeout-ms</span><span class="whitespace"> </span><span class="symbol">timeout-val</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Atom</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">options</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">setup-reference</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="symbol">options</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/swap!" title="Atomically swaps the value of atom to be:
  (apply f current-value-of-atom args). Note that f may be called
  multiple times, and thus should be free of side effects.  Returns
  the value that was swapped in.">swap!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Atomically swaps the value of atom to be:
  (apply f current-value-of-atom args). Note that f may be called
  multiple times, and thus should be free of side effects.  Returns
  the value that was swapped in."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.IAtom</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span class="symbol">f</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.swap</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span class="symbol">f</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.IAtom</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.swap</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.IAtom</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.swap</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.IAtom</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.swap</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/compare-and-set!" title="Atomically sets the value of atom to newval if and only if the
  current value of the atom is identical to oldval. Returns true if
  set happened, else false">compare-and-set!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Atomically sets the value of atom to newval if and only if the
  current value of the atom is identical to oldval. Returns true if
  set happened, else false"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.IAtom</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span class="symbol">oldval</span><span class="whitespace"> </span><span class="symbol">newval</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.compareAndSet</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span class="symbol">oldval</span><span class="whitespace"> </span><span class="symbol">newval</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reset!" title="Sets the value of atom to newval without regard for the
  current value. Returns newval.">reset!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Sets the value of atom to newval without regard for the
  current value. Returns newval."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.IAtom</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span class="symbol">newval</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.reset</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span class="symbol">newval</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set-validator!" title="Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a
  side-effect-free fn of one argument, which will be passed the intended
  new state on any state change. If the new state is unacceptable, the
  validator-fn should return false or throw an exception. If the current state (root
  value if var) is not acceptable to the new validator, an exception
  will be thrown and the validator will not be changed.">set-validator!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a
  side-effect-free fn of one argument, which will be passed the intended
  new state on any state change. If the new state is unacceptable, the
  validator-fn should return false or throw an exception. If the current state (root
  value if var) is not acceptable to the new validator, an exception
  will be thrown and the validator will not be changed."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.IRef</span></span><span class="whitespace"> </span><span class="symbol">iref</span><span class="whitespace"> </span><span class="symbol">validator-fn</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">iref</span><span class="whitespace"> </span><span>(<span class="symbol">setValidator</span><span class="whitespace"> </span><span class="symbol">validator-fn</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get-validator" title="Gets the validator-fn for a var/ref/agent/atom.">get-validator</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Gets the validator-fn for a var/ref/agent/atom."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.IRef</span></span><span class="whitespace"> </span><span class="symbol">iref</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">iref</span><span class="whitespace"> </span><span>(<span class="symbol">getValidator</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alter-meta!" title="Atomically sets the metadata for a namespace/var/ref/agent/atom to be:

  (apply f its-current-meta args)

  f must be free of side-effects">alter-meta!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Atomically sets the metadata for a namespace/var/ref/agent/atom to be:

  (apply f its-current-meta args)

  f must be free of side-effects"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.IReference</span></span><span class="whitespace"> </span><span class="symbol">iref</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.alterMeta</span><span class="whitespace"> </span><span class="symbol">iref</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reset-meta!" title="Atomically resets the metadata for a namespace/var/ref/agent/atom">reset-meta!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Atomically resets the metadata for a namespace/var/ref/agent/atom"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.IReference</span></span><span class="whitespace"> </span><span class="symbol">iref</span><span class="whitespace"> </span><span class="symbol">metadata-map</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.resetMeta</span><span class="whitespace"> </span><span class="symbol">iref</span><span class="whitespace"> </span><span class="symbol">metadata-map</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/commute" title="Must be called in a transaction. Sets the in-transaction-value of
  ref to:

  (apply fun in-transaction-value-of-ref args)

  and returns the in-transaction-value of ref.

  At the commit point of the transaction, sets the value of ref to be:

  (apply fun most-recently-committed-value-of-ref args)

  Thus fun should be commutative, or, failing that, you must accept
  last-one-in-wins behavior.  commute allows for more concurrency than
  ref-set.">commute</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Must be called in a transaction. Sets the in-transaction-value of
  ref to:

  (apply fun in-transaction-value-of-ref args)

  and returns the in-transaction-value of ref.

  At the commit point of the transaction, sets the value of ref to be:

  (apply fun most-recently-committed-value-of-ref args)

  Thus fun should be commutative, or, failing that, you must accept
  last-one-in-wins behavior.  commute allows for more concurrency than
  ref-set."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Ref</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span class="symbol">fun</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/commute" title="Must be called in a transaction. Sets the in-transaction-value of
  ref to:

  (apply fun in-transaction-value-of-ref args)

  and returns the in-transaction-value of ref.

  At the commit point of the transaction, sets the value of ref to be:

  (apply fun most-recently-committed-value-of-ref args)

  Thus fun should be commutative, or, failing that, you must accept
  last-one-in-wins behavior.  commute allows for more concurrency than
  ref-set.">commute</a></span><span class="whitespace"> </span><span class="symbol">fun</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alter" title="Must be called in a transaction. Sets the in-transaction-value of
  ref to:

  (apply fun in-transaction-value-of-ref args)

  and returns the in-transaction-value of ref.">alter</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Must be called in a transaction. Sets the in-transaction-value of
  ref to:

  (apply fun in-transaction-value-of-ref args)

  and returns the in-transaction-value of ref."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Ref</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span class="symbol">fun</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alter" title="Must be called in a transaction. Sets the in-transaction-value of
  ref to:

  (apply fun in-transaction-value-of-ref args)

  and returns the in-transaction-value of ref.">alter</a></span><span class="whitespace"> </span><span class="symbol">fun</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref-set" title="Must be called in a transaction. Sets the value of ref.
  Returns val.">ref-set</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Must be called in a transaction. Sets the value of ref.
  Returns val."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Ref</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref-history-count" title="Returns the history count of a ref">ref-history-count</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the history count of a ref"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Ref</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.getHistoryCount</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref-min-history" title="Gets the min-history of a ref, or sets it and returns the ref">ref-min-history</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Gets the min-history of a ref, or sets it and returns the ref"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.Ref</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.getMinHistory</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.Ref</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.setMinHistory</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref-max-history" title="Gets the max-history of a ref, or sets it and returns the ref">ref-max-history</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Gets the max-history of a ref, or sets it and returns the ref"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.Ref</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.getMaxHistory</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.Ref</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.setMaxHistory</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ensure" title="Must be called in a transaction. Protects the ref from modification
  by other transactions.  Returns the in-transaction-value of
  ref. Allows for more concurrency than (ref-set ref @ref)">ensure</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Must be called in a transaction. Protects the ref from modification
  by other transactions.  Returns the in-transaction-value of
  ref. Allows for more concurrency than (ref-set ref @ref)"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Ref</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span>(<span class="symbol">touch</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/deref" title="Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,
  returns the in-transaction-value of ref, else returns the
  most-recently-committed value of ref. When applied to a var, agent
  or atom, returns its current state. When applied to a delay, forces
  it if not already forced. When applied to a future, will block if
  computation not complete. When applied to a promise, will block
  until a value is delivered.  The variant taking a timeout can be
  used for blocking references (futures and promises), and will return
  timeout-val if the timeout (in milliseconds) is reached before a
  value is available. See also - realized?.">deref</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/sync" title="transaction-flags =&gt; TBD, pass nil for now

  Runs the exprs (in an implicit do) in a transaction that encompasses
  exprs and any nested calls.  Starts a transaction if none is already
  running on this thread. Any uncaught exception will abort the
  transaction and flow out of sync. The exprs may be run more than
  once, but any effects on Refs will be atomic.">sync</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"transaction-flags => TBD, pass nil for now

  Runs the exprs (in an implicit do) in a transaction that encompasses
  exprs and any nested calls.  Starts a transaction if none is already
  running on this thread. Any uncaught exception will abort the
  transaction and flow out of sync. The exprs may be run more than
  once, but any effects on Refs will be atomic."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">flags-ignored-for-now</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.LockingTransaction</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">runInTransaction</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span>~<span class="unknown">@body</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/io!" title="If an io! block occurs in a transaction, throws an
  IllegalStateException, else runs body in an implicit do. If the
  first expression in body is a literal string, will use that as the
  exception message.">io!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"If an io! block occurs in a transaction, throws an
  IllegalStateException, else runs body in an implicit do. If the
  first expression in body is a literal string, will use that as the
  exception message."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">message</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">body</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">body</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">body</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">message</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">body</span>)</span><span class="whitespace"> </span><span class="symbol">body</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.LockingTransaction/<span class="symbol">isRunning</span></span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">IllegalStateException</span><span class="whitespace"> </span>~<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span class="symbol">message</span><span class="whitespace"> </span><span class="string">"I/O in transaction"</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">do</span><span class="whitespace"> </span>~<span class="unknown">@body</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/volatile!" title="Creates and returns a Volatile with an initial value of val.">volatile!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates and returns a Volatile with an initial value of val."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Volatile</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">clojure.lang.Volatile.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vreset!" title="Sets the value of volatile to newval without regard for the
   current value. Returns newval.">vreset!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Sets the value of volatile to newval without regard for the
   current value. Returns newval."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Volatile</span></span><span class="whitespace"> </span><span class="symbol">vol</span><span class="whitespace"> </span><span class="symbol">newval</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.reset</span><span class="whitespace"> </span><span class="symbol">vol</span><span class="whitespace"> </span><span class="symbol">newval</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/vswap!" title="Non-atomically swaps the value of the volatile as if:
   (apply f current-value-of-vol args). Returns the value that
   was swapped in.">vswap!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Non-atomically swaps the value of the volatile as if:
   (apply f current-value-of-vol args). Returns the value that
   was swapped in."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">vol</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span class="symbol">vol</span><span class="whitespace"> </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span>'<span class="java-class">clojure.lang.Volatile</span></span>}</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="java-class">.reset</span><span class="whitespace"> </span>~<span class="symbol">v</span><span class="whitespace"> </span><span>(~<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="java-class">.deref</span><span class="whitespace"> </span>~<span class="symbol">v</span>)</span><span class="whitespace"> </span>~<span class="unknown">@args</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/volatile?" title="Returns true if x is a volatile.">volatile?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x is a volatile."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Volatile</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; fn stuff ;;;;;;;;;;;;;;;;</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comp" title="Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.">comp</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identity" title="Returns its argument.">identity</a></span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span>]</span><span class="whitespace"> </span><span class="symbol">f</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">g</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">g</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">fs</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comp" title="Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.">comp</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list*" title="Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.">list*</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">fs</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/juxt" title="Takes a set of functions and returns a fn that is the juxtaposition
  of those fns.  The returned fn takes a variable number of args, and
  returns a vector containing the result of applying each fn to the
  args (left-to-right).
  ((juxt a b c) x) =&gt; [(a x) (b x) (c x)]">juxt</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a set of functions and returns a fn that is the juxtaposition
  of those fns.  The returned fn takes a variable number of args, and
  returns a vector containing the result of applying each fn to the
  args (left-to-right).
  ((juxt a b c) x) => [(a x) (b x) (c x)]"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[]</span><span class="whitespace"> </span><span>[<span>(<span class="symbol">f</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>[<span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>[<span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>[<span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>[<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>]</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">g</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[]</span><span class="whitespace"> </span><span>[<span>(<span class="symbol">f</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">g</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>[<span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>[<span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>[<span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>[<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">args</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>]</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">h</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[]</span><span class="whitespace"> </span><span>[<span>(<span class="symbol">f</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">g</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">h</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>[<span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>[<span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>[<span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>[<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">args</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">args</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>]</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">fs</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">fs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list*" title="Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.">list*</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">fs</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">%1</span><span class="whitespace"> </span><span>(<span class="symbol">%2</span>)</span>)</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="symbol">fs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">%1</span><span class="whitespace"> </span><span>(<span class="symbol">%2</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="symbol">fs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">%1</span><span class="whitespace"> </span><span>(<span class="symbol">%2</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="symbol">fs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">%1</span><span class="whitespace"> </span><span>(<span class="symbol">%2</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="symbol">fs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">%1</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">%2</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="symbol">fs</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partial" title="Takes a function f and fewer than the normal arguments to f, and
  returns a fn that takes a variable number of additional args. When
  called, the returned function calls f with args + additional args.">partial</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a function f and fewer than the normal arguments to f, and
  returns a fn that takes a variable number of additional args. When
  called, the returned function calls f with args + additional args."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span>]</span><span class="whitespace"> </span><span class="symbol">f</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">arg2</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">arg2</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">arg2</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">arg2</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">arg2</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">arg2</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">arg2</span><span class="whitespace"> </span><span class="symbol">arg3</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">arg2</span><span class="whitespace"> </span><span class="symbol">arg3</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">arg2</span><span class="whitespace"> </span><span class="symbol">arg3</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">arg2</span><span class="whitespace"> </span><span class="symbol">arg3</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">arg2</span><span class="whitespace"> </span><span class="symbol">arg3</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">arg2</span><span class="whitespace"> </span><span class="symbol">arg3</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">arg2</span><span class="whitespace"> </span><span class="symbol">arg3</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">arg1</span><span class="whitespace"> </span><span class="symbol">arg2</span><span class="whitespace"> </span><span class="symbol">arg3</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/concat" title="Returns a lazy seq representing the concatenation of the elements in the supplied colls.">concat</a></span><span class="whitespace"> </span><span class="symbol">more</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;;;;;;;;;; sequence fns  ;;;;;;;;;;;;;;;;;;;;;;;</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sequence" title="Coerces coll to a (possibly empty) sequence, if it is not already
  one. Will not force a lazy seq. (sequence nil) yields (), When a
  transducer is supplied, returns a lazy sequence of applications of
  the transform to the items in coll(s), i.e. to the set of first
  items of each coll, followed by the set of second
  items in each coll, until any one of the colls is exhausted.  Any
  remaining items in other colls are ignored. The transform should accept
  number-of-colls arguments">sequence</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerces coll to a (possibly empty) sequence, if it is not already
  one. Will not force a lazy seq. (sequence nil) yields (), When a
  transducer is supplied, returns a lazy sequence of applications of
  the transform to the items in coll(s), i.e. to the set of first
  items of each coll, followed by the set of second
  items in each coll, until any one of the colls is exhausted.  Any
  remaining items in other colls are ignored. The transform should accept
  number-of-colls arguments"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace"> </span><span>()</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">xform</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">chunkIteratorSeq</span></span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="java-class">clojure.lang.TransformerIterator/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">xform</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">iter</span></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>()</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">xform</span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">colls</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">chunkIteratorSeq</span></span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="java-class">clojure.lang.TransformerIterator/<span class="symbol">createMulti</span></span><span class="whitespace">
</span><span class="whitespace">           </span><span class="symbol">xform</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="java-class">clojure.lang.RT/<span class="symbol">iter</span></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">colls</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>()</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if (pred x) is logical true for every x in coll, else
  false."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">Boolean</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="symbol">pred</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">pred</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:else</span><span class="whitespace"> </span><span class="unknown">false</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">Boolean</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Returns false if (pred x) is logical true for every x in
  coll, else true."</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not-every?" title="Returns false if (pred x) is logical true for every x in
  coll, else true.">not-every?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comp" title="Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.">comp</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some" title="Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)">some</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">pred</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">pred</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">Boolean</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Returns false if (pred x) is logical true for any x in coll,
  else true."</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not-any?" title="Returns false if (pred x) is logical true for any x in coll,
  else true.">not-any?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comp" title="Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.">comp</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some" title="Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)">some</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;will be redefed later with arg checks</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/dotimes" title="bindings =&gt; name n

  Repeatedly executes body (presumably for side-effects) with name
  bound to integers from 0 through n-1.">dotimes</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"bindings => name n

  Repeatedly executes body (presumably for side-effects) with name
  bound to integers from 0 through n-1."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">n</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">n#</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">longCast</span></span><span class="whitespace"> </span>~<span class="symbol">n</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[~<span class="symbol">i</span><span class="whitespace"> </span><span class="unknown">0</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span>~<span class="symbol">i</span><span class="whitespace"> </span><span class="symbol">n#</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span>~<span class="unknown">@body</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-inc" title="Returns a number one greater than x, a long.
  Note - uses a primitive operator subject to overflow.">unchecked-inc</a></span><span class="whitespace"> </span>~<span class="symbol">i</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">input</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">inputs</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">input</span><span class="whitespace"> </span><span class="symbol">inputs</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunked-seq?">chunked-seq?</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">c</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-first">chunk-first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">size</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">c</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">b</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-buffer">chunk-buffer</a></span><span class="whitespace"> </span><span class="symbol">size</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/dotimes" title="bindings =&gt; name n

  Repeatedly executes body (presumably for side-effects) with name
  bound to integers from 0 through n-1.">dotimes</a></span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span class="symbol">size</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-append">chunk-append</a></span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="java-class">.nth</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-cons">chunk-cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk">chunk</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-rest">chunk-rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">c1</span><span class="whitespace"> </span><span class="symbol">c2</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">s1</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">c1</span>)</span><span class="whitespace"> </span><span class="symbol">s2</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">c2</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span class="symbol">s1</span><span class="whitespace"> </span><span class="symbol">s2</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s1</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s2</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s1</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s2</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">c1</span><span class="whitespace"> </span><span class="symbol">c2</span><span class="whitespace"> </span><span class="symbol">c3</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">s1</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">c1</span>)</span><span class="whitespace"> </span><span class="symbol">s2</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">c2</span>)</span><span class="whitespace"> </span><span class="symbol">s3</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">c3</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace">  </span><span class="symbol">s1</span><span class="whitespace"> </span><span class="symbol">s2</span><span class="whitespace"> </span><span class="symbol">s3</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s1</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s2</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s3</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s1</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s2</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s3</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">c1</span><span class="whitespace"> </span><span class="symbol">c2</span><span class="whitespace"> </span><span class="symbol">c3</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">colls</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">step</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">step</span><span class="whitespace"> </span><span>[<span class="symbol">cs</span>]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ss</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">cs</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identity" title="Returns its argument.">identity</a></span><span class="whitespace"> </span><span class="symbol">ss</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ss</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">step</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">ss</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">step</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">colls</span><span class="whitespace"> </span><span class="symbol">c3</span><span class="whitespace"> </span><span class="symbol">c2</span><span class="whitespace"> </span><span class="symbol">c1</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/declare" title="defs the supplied var names with no bindings, useful for making forward declarations.">declare</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"defs the supplied var names with no bindings, useful for making forward declarations."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">names</span>]</span><span class="whitespace"> </span>`<span>(<span class="macro">do</span><span class="whitespace"> </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="macro">def</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vary-meta" title="Returns an object of the same type and value as obj, with
  (apply f (meta obj) args) as its metadata.">vary-meta</a></span><span class="whitespace"> </span><span class="symbol">%</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="keyword">:declared</span><span class="whitespace"> </span><span class="unknown">true</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">names</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/declare" title="defs the supplied var names with no bindings, useful for making forward declarations.">declare</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cat" title="A transducer which concatenates the contents of each input, which must be a
  collection, into the reduction.">cat</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/mapcat" title="Returns the result of applying concat to the result of applying map
  to f and colls.  Thus function f should return a collection. Returns
  a transducer when no collections are provided">mapcat</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the result of applying concat to the result of applying map
  to f and colls.  Thus function f should return a collection. Returns
  a transducer when no collections are provided"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comp" title="Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.">comp</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">f</span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cat" title="A transducer which concatenates the contents of each input, which must be a
  collection, into the reduction.">cat</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">colls</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/concat" title="Returns a lazy seq representing the concatenation of the elements in the supplied colls.">concat</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">colls</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filter" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">filter</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">pred</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">input</span>)</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>)</span><span class="whitespace">
</span><span class="whitespace">             </span><span class="symbol">result</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunked-seq?">chunked-seq?</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">c</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-first">chunk-first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">size</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">c</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">b</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-buffer">chunk-buffer</a></span><span class="whitespace"> </span><span class="symbol">size</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/dotimes" title="bindings =&gt; name n

  Repeatedly executes body (presumably for side-effects) with name
  bound to integers from 0 through n-1.">dotimes</a></span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span class="symbol">size</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="java-class">.nth</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-append">chunk-append</a></span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-cons">chunk-cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk">chunk</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filter" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">filter</a></span><span class="whitespace"> </span><span class="symbol">pred</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-rest">chunk-rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span class="symbol">r</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">f</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filter" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">filter</a></span><span class="whitespace"> </span><span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">r</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filter" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">filter</a></span><span class="whitespace"> </span><span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">r</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/remove" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns false. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">remove</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of the items in coll for which
  (pred item) returns false. pred must be free of side-effects.
  Returns a transducer when no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">pred</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filter" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">filter</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/complement" title="Takes a fn f and returns a fn that takes the same arguments as f,
  has the same effects, if any, and returns the opposite truth value.">complement</a></span><span class="whitespace"> </span><span class="symbol">pred</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filter" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">filter</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/complement" title="Takes a fn f and returns a fn that takes the same arguments as f,
  has the same effects, if any, and returns the opposite truth value.">complement</a></span><span class="whitespace"> </span><span class="symbol">pred</span>)</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduced" title="Wraps x in a way such that a reduce will terminate with the value x">reduced</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Wraps x in a way such that a reduce will terminate with the value x"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.5"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">clojure.lang.Reduced.</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduced?" title="Returns true if x is the result of a call to reduced">reduced?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x is the result of a call to reduced"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">clojure.lang.RT/<span class="symbol">isReduced</span></span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace"> </span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">1</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.5"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">isReduced</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ensure-reduced" title="If x is already reduced?, returns it, else returns (reduced x)">ensure-reduced</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"If x is already reduced?, returns it, else returns (reduced x)"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduced?" title="Returns true if x is the result of a call to reduced">reduced?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduced" title="Wraps x in a way such that a reduce will terminate with the value x">reduced</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unreduced" title="If x is reduced?, returns (deref x), else returns x">unreduced</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"If x is reduced?, returns (deref x), else returns x"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduced?" title="Returns true if x is the result of a call to reduced">reduced?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/deref" title="Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,
  returns the in-transaction-value of ref, else returns the
  most-recently-committed value of ref. When applied to a var, agent
  or atom, returns its current state. When applied to a delay, forces
  it if not already forced. When applied to a future, will block if
  computation not complete. When applied to a promise, will block
  until a value is delivered.  The variant taking a timeout can be
  used for blocking references (futures and promises), and will return
  timeout-val if the timeout (in milliseconds) is reached before a
  value is available. See also - realized?.">deref</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take" title="Returns a lazy sequence of the first n items in coll, or all items if
  there are fewer than n.  Returns a stateful transducer when
  no collection is provided.">take</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of the first n items in coll, or all items if
  there are fewer than n.  Returns a stateful transducer when
  no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">nv</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/volatile!" title="Creates and returns a Volatile with an initial value of val.">volatile!</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="unknown">@nv</span><span class="whitespace">
</span><span class="whitespace">                    </span><span class="symbol">nn</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/vswap!" title="Non-atomically swaps the value of the volatile as if:
   (apply f current-value-of-vol args). Returns the value that
   was swapped in.">vswap!</a></span><span class="whitespace"> </span><span class="symbol">nv</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dec" title="Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec&apos;">dec</a></span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span class="symbol">result</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span class="symbol">result</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace"> </span><span class="symbol">nn</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ensure-reduced" title="If x is already reduced?, returns it, else returns (reduced x)">ensure-reduced</a></span><span class="whitespace"> </span><span class="symbol">result</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="symbol">result</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take" title="Returns a lazy sequence of the first n items in coll, or all items if
  there are fewer than n.  Returns a stateful transducer when
  no collection is provided.">take</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dec" title="Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec&apos;">dec</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-while" title="Returns a lazy sequence of successive items from coll while
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">take-while</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of successive items from coll while
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">pred</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">input</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduced" title="Wraps x in a way such that a reduce will terminate with the value x">reduced</a></span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="symbol">pred</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-while" title="Returns a lazy sequence of successive items from coll while
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">take-while</a></span><span class="whitespace"> </span><span class="symbol">pred</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop" title="Returns a lazy sequence of all but the first n items in coll.
  Returns a stateful transducer when no collection is provided.">drop</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of all but the first n items in coll.
  Returns a stateful transducer when no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">nv</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/volatile!" title="Creates and returns a Volatile with an initial value of val.">volatile!</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="unknown">@nv</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/vswap!" title="Non-atomically swaps the value of the volatile as if:
   (apply f current-value-of-vol args). Returns the value that
   was swapped in.">vswap!</a></span><span class="whitespace"> </span><span class="symbol">nv</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dec" title="Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec&apos;">dec</a></span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="symbol">result</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">step</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dec" title="Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec&apos;">dec</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span class="symbol">s</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace"> </span><span>(<span class="symbol">step</span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop-last" title="Return a lazy sequence of all but the last n (default 1) items in coll">drop-last</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Return a lazy sequence of all but the last n (default 1) items in coll"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">s</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop-last" title="Return a lazy sequence of all but the last n (default 1) items in coll">drop-last</a></span><span class="whitespace"> </span><span class="unknown">1</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">_</span>]</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop" title="Returns a lazy sequence of all but the first n items in coll.
  Returns a stateful transducer when no collection is provided.">drop</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-last" title="Returns a seq of the last n items in coll.  Depending on the type
  of coll may be no better than linear time.  For vectors, see also subvec.">take-last</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a seq of the last n items in coll.  Depending on the type
  of coll may be no better than linear time.  For vectors, see also subvec."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">, </span><span class="symbol">lead</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop" title="Returns a lazy sequence of all but the first n items in coll.
  Returns a stateful transducer when no collection is provided.">drop</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">lead</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">lead</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="symbol">s</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop-while" title="Returns a lazy sequence of the items in coll starting from the
  first item for which (pred item) returns logical false.  Returns a
  stateful transducer when no collection is provided.">drop-while</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of the items in coll starting from the
  first item for which (pred item) returns logical false.  Returns a
  stateful transducer when no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">pred</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">dv</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/volatile!" title="Creates and returns a Volatile with an initial value of val.">volatile!</a></span><span class="whitespace"> </span><span class="unknown">true</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">drop?</span><span class="whitespace"> </span><span class="unknown">@dv</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span class="symbol">drop?</span><span class="whitespace"> </span><span>(<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">input</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="symbol">result</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="macro">do</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vreset!" title="Sets the value of volatile to newval without regard for the
   current value. Returns newval.">vreset!</a></span><span class="whitespace"> </span><span class="symbol">dv</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">step</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="symbol">pred</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">pred</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span class="symbol">s</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace"> </span><span>(<span class="symbol">step</span><span class="whitespace"> </span><span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cycle" title="Returns a lazy (infinite!) sequence of repetitions of the items in coll.">cycle</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy (infinite!) sequence of repetitions of the items in coll."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Cycle/<span class="symbol">create</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/split-at" title="Returns a vector of [(take n coll) (drop n coll)]">split-at</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a vector of [(take n coll) (drop n coll)]"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>[<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take" title="Returns a lazy sequence of the first n items in coll, or all items if
  there are fewer than n.  Returns a stateful transducer when
  no collection is provided.">take</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop" title="Returns a lazy sequence of all but the first n items in coll.
  Returns a stateful transducer when no collection is provided.">drop</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/split-with" title="Returns a vector of [(take-while pred coll) (drop-while pred coll)]">split-with</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a vector of [(take-while pred coll) (drop-while pred coll)]"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>[<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-while" title="Returns a lazy sequence of successive items from coll while
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">take-while</a></span><span class="whitespace"> </span><span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop-while" title="Returns a lazy sequence of the items in coll starting from the
  first item for which (pred item) returns logical false.  Returns a
  stateful transducer when no collection is provided.">drop-while</a></span><span class="whitespace"> </span><span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/repeat" title="Returns a lazy (infinite!, or length n if supplied) sequence of xs.">repeat</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy (infinite!, or length n if supplied) sequence of xs."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Repeat/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Repeat/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/replicate" title="DEPRECATED: Use &apos;repeat&apos; instead.
   Returns a lazy seq of n xs.">replicate</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"DEPRECATED: Use 'repeat' instead.
   Returns a lazy seq of n xs."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:deprecated</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take" title="Returns a lazy sequence of the first n items in coll, or all items if
  there are fewer than n.  Returns a stateful transducer when
  no collection is provided.">take</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/repeat" title="Returns a lazy (infinite!, or length n if supplied) sequence of xs.">repeat</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/iterate" title="Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects">iterate</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Iterate/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/range" title="Returns a lazy seq of nums from start (inclusive) to end
  (exclusive), by step, where start defaults to 0, step to 1, and end to
  infinity. When step is equal to 0, returns an infinite sequence of
  start. When start is equal to end, returns empty list.">range</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy seq of nums from start (inclusive) to end
  (exclusive), by step, where start defaults to 0, step to 1, and end to
  infinity. When step is equal to 0, returns an infinite sequence of
  start. When start is equal to end, returns empty list."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/iterate" title="Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects">iterate</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc&apos;" title="Returns a number one greater than num. Supports arbitrary precision.
  See also: inc">inc'</a></span><span class="whitespace"> </span><span class="unknown">0</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">end</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Long</span><span class="whitespace"> </span><span class="symbol">end</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">clojure.lang.LongRange/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">end</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">clojure.lang.Range/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">end</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">start</span><span class="whitespace"> </span><span class="symbol">end</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Long</span><span class="whitespace"> </span><span class="symbol">start</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Long</span><span class="whitespace"> </span><span class="symbol">end</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">clojure.lang.LongRange/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">start</span><span class="whitespace"> </span><span class="symbol">end</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">clojure.lang.Range/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">start</span><span class="whitespace"> </span><span class="symbol">end</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">start</span><span class="whitespace"> </span><span class="symbol">end</span><span class="whitespace"> </span><span class="symbol">step</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Long</span><span class="whitespace"> </span><span class="symbol">start</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Long</span><span class="whitespace"> </span><span class="symbol">end</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Long</span><span class="whitespace"> </span><span class="symbol">step</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">clojure.lang.LongRange/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">start</span><span class="whitespace"> </span><span class="symbol">end</span><span class="whitespace"> </span><span class="symbol">step</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">clojure.lang.Range/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">start</span><span class="whitespace"> </span><span class="symbol">end</span><span class="whitespace"> </span><span class="symbol">step</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/merge" title="Returns a map that consists of the rest of the maps conj-ed onto
  the first.  If a key occurs in more than one map, the mapping from
  the latter (left-to-right) will be the mapping in the result.">merge</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a map that consists of the rest of the maps conj-ed onto
  the first.  If a key occurs in more than one map, the mapping from
  the latter (left-to-right) will be the mapping in the result."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">maps</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some" title="Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)">some</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identity" title="Returns its argument.">identity</a></span><span class="whitespace"> </span><span class="symbol">maps</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span class="symbol">%1</span><span class="whitespace"> </span><span>{}</span>)</span><span class="whitespace"> </span><span class="symbol">%2</span>)</span><span class="whitespace"> </span><span class="symbol">maps</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/merge-with" title="Returns a map that consists of the rest of the maps conj-ed onto
  the first.  If a key occurs in more than one map, the mapping(s)
  from the latter (left-to-right) will be combined with the mapping in
  the result by calling (f val-in-result val-in-latter).">merge-with</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a map that consists of the rest of the maps conj-ed onto
  the first.  If a key occurs in more than one map, the mapping(s)
  from the latter (left-to-right) will be combined with the mapping in
  the result by calling (f val-in-result val-in-latter)."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">maps</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some" title="Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)">some</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identity" title="Returns its argument.">identity</a></span><span class="whitespace"> </span><span class="symbol">maps</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">merge-entry</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">e</span>]</span><span class="whitespace">
</span><span class="whitespace">			</span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="symbol">e</span>)</span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">e</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">			  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace">
</span><span class="whitespace">			    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">			    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">merge2</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">m1</span><span class="whitespace"> </span><span class="symbol">m2</span>]</span><span class="whitespace">
</span><span class="whitespace">		   </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="symbol">merge-entry</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span class="symbol">m1</span><span class="whitespace"> </span><span>{}</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">m2</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="symbol">merge2</span><span class="whitespace"> </span><span class="symbol">maps</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/zipmap" title="Returns a map with the keys mapped to the corresponding vals.">zipmap</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a map with the keys mapped to the corresponding vals."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vals" title="Returns a sequence of the map&apos;s values, in the same order as (seq map).">vals</a></span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>{}</span><span class="whitespace">
</span><span class="whitespace">           </span><span class="symbol">ks</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span class="symbol">vs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vals" title="Returns a sequence of the map&apos;s values, in the same order as (seq map).">vals</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span class="symbol">ks</span><span class="whitespace"> </span><span class="symbol">vs</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">vs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">vs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/line-seq" title="Returns the lines of text from rdr as a lazy sequence of strings.
  rdr must implement java.io.BufferedReader.">line-seq</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the lines of text from rdr as a lazy sequence of strings.
  rdr must implement java.io.BufferedReader."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">java.io.BufferedReader</span></span><span class="whitespace"> </span><span class="symbol">rdr</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">line</span><span class="whitespace"> </span><span>(<span class="java-class">.readLine</span><span class="whitespace"> </span><span class="symbol">rdr</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">line</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/line-seq" title="Returns the lines of text from rdr as a lazy sequence of strings.
  rdr must implement java.io.BufferedReader.">line-seq</a></span><span class="whitespace"> </span><span class="symbol">rdr</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comparator" title="Returns an implementation of java.util.Comparator based upon pred.">comparator</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns an implementation of java.util.Comparator based upon pred."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">pred</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace"> </span><span>(<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="unknown">-1</span><span class="whitespace"> </span><span>(<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="unknown">1</span><span class="whitespace"> </span><span class="keyword">:else</span><span class="whitespace"> </span><span class="unknown">0</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sort" title="Returns a sorted sequence of the items in coll. If no comparator is
  supplied, uses compare.  comparator must implement
  java.util.Comparator.  Guaranteed to be stable: equal elements will
  not be reordered.  If coll is a Java array, it will be modified.  To
  avoid this, sort a copy of the array.">sort</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a sorted sequence of the items in coll. If no comparator is
  supplied, uses compare.  comparator must implement
  java.util.Comparator.  Guaranteed to be stable: equal elements will
  not be reordered.  If coll is a Java array, it will be modified.  To
  avoid this, sort a copy of the array."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sort" title="Returns a sorted sequence of the items in coll. If no comparator is
  supplied, uses compare.  comparator must implement
  java.util.Comparator.  Guaranteed to be stable: equal elements will
  not be reordered.  If coll is a Java array, it will be modified.  To
  avoid this, sort a copy of the array.">sort</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/compare" title="Comparator. Returns a negative number, zero, or a positive number
  when x is logically &apos;less than&apos;, &apos;equal to&apos;, or &apos;greater than&apos;
  y. Same as Java x.compareTo(y) except it also works for nil, and
  compares numbers and collections in a type-independent manner. x
  must implement Comparable">compare</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">java.util.Comparator</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comp" title="Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.">comp</a></span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/to-array" title="Returns an array of Objects containing the contents of coll, which
  can be any Collection.  Maps to java.util.Collection.toArray().">to-array</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">java.util.Arrays</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sort" title="Returns a sorted sequence of the items in coll. If no comparator is
  supplied, uses compare.  comparator must implement
  java.util.Comparator.  Guaranteed to be stable: equal elements will
  not be reordered.  If coll is a Java array, it will be modified.  To
  avoid this, sort a copy of the array.">sort</a></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comp" title="Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.">comp</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">a</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>()</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sort-by" title="Returns a sorted sequence of the items in coll, where the sort
  order is determined by comparing (keyfn item).  If no comparator is
  supplied, uses compare.  comparator must implement
  java.util.Comparator.  Guaranteed to be stable: equal elements will
  not be reordered.  If coll is a Java array, it will be modified.  To
  avoid this, sort a copy of the array.">sort-by</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a sorted sequence of the items in coll, where the sort
  order is determined by comparing (keyfn item).  If no comparator is
  supplied, uses compare.  comparator must implement
  java.util.Comparator.  Guaranteed to be stable: equal elements will
  not be reordered.  If coll is a Java array, it will be modified.  To
  avoid this, sort a copy of the array."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">keyfn</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sort-by" title="Returns a sorted sequence of the items in coll, where the sort
  order is determined by comparing (keyfn item).  If no comparator is
  supplied, uses compare.  comparator must implement
  java.util.Comparator.  Guaranteed to be stable: equal elements will
  not be reordered.  If coll is a Java array, it will be modified.  To
  avoid this, sort a copy of the array.">sort-by</a></span><span class="whitespace"> </span><span class="symbol">keyfn</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/compare" title="Comparator. Returns a negative number, zero, or a positive number
  when x is logically &apos;less than&apos;, &apos;equal to&apos;, or &apos;greater than&apos;
  y. Same as Java x.compareTo(y) except it also works for nil, and
  compares numbers and collections in a type-independent manner. x
  must implement Comparable">compare</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">keyfn</span><span class="whitespace"> </span><span>^<span class="java-class">java.util.Comparator</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comp" title="Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.">comp</a></span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sort" title="Returns a sorted sequence of the items in coll. If no comparator is
  supplied, uses compare.  comparator must implement
  java.util.Comparator.  Guaranteed to be stable: equal elements will
  not be reordered.  If coll is a Java array, it will be modified.  To
  avoid this, sort a copy of the array.">sort</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comp" title="Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.">comp</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/compare" title="Comparator. Returns a negative number, zero, or a positive number
  when x is logically &apos;less than&apos;, &apos;equal to&apos;, or &apos;greater than&apos;
  y. Same as Java x.compareTo(y) except it also works for nil, and
  compares numbers and collections in a type-independent manner. x
  must implement Comparable">compare</a></span><span class="whitespace"> </span><span>(<span class="symbol">keyfn</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">keyfn</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dorun" title="When lazy sequences are produced via functions that have side
  effects, any effects other than those needed to produce the first
  element in the seq do not occur until the seq is consumed. dorun can
  be used to force any effects. Walks through the successive nexts of
  the seq, does not retain the head and returns nil.">dorun</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"When lazy sequences are produced via functions that have side
  effects, any effects other than those needed to produce the first
  element in the seq do not occur until the seq is consumed. dorun can
  be used to force any effects. Walks through the successive nexts of
  the seq, does not retain the head and returns nil."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dec" title="Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec&apos;">dec</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/doall" title="When lazy sequences are produced via functions that have side
  effects, any effects other than those needed to produce the first
  element in the seq do not occur until the seq is consumed. doall can
  be used to force any effects. Walks through the successive nexts of
  the seq, retains the head and returns it, thus causing the entire
  seq to reside in memory at one time.">doall</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"When lazy sequences are produced via functions that have side
  effects, any effects other than those needed to produce the first
  element in the seq do not occur until the seq is consumed. doall can
  be used to force any effects. Walks through the successive nexts of
  the seq, retains the head and returns it, thus causing the entire
  seq to reside in memory at one time."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dorun" title="When lazy sequences are produced via functions that have side
  effects, any effects other than those needed to produce the first
  element in the seq do not occur until the seq is consumed. dorun can
  be used to force any effects. Walks through the successive nexts of
  the seq, does not retain the head and returns nil.">dorun</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dorun" title="When lazy sequences are produced via functions that have side
  effects, any effects other than those needed to produce the first
  element in the seq do not occur until the seq is consumed. dorun can
  be used to force any effects. Walks through the successive nexts of
  the seq, does not retain the head and returns nil.">dorun</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nthnext" title="Returns the nth next of coll, (seq coll) when n is 0.">nthnext</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the nth next of coll, (seq coll) when n is 0."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">xs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span class="symbol">xs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dec" title="Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec&apos;">dec</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">xs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">xs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nthrest" title="Returns the nth rest of coll, coll when n is 0.">nthrest</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the nth rest of coll, coll when n is 0."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">xs</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">xs</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">xs</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dec" title="Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec&apos;">dec</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">xs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">xs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition" title="Returns a lazy sequence of lists of n items each, at offsets step
  apart. If step is not supplied, defaults to n, i.e. the partitions
  do not overlap. If a pad collection is supplied, use its elements as
  necessary to complete last partition upto n items. In case there are
  not enough padding elements, return a partition with less than n items.">partition</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of lists of n items each, at offsets step
  apart. If step is not supplied, defaults to n, i.e. the partitions
  do not overlap. If a pad collection is supplied, use its elements as
  necessary to complete last partition upto n items. In case there are
  not enough padding elements, return a partition with less than n items."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition" title="Returns a lazy sequence of lists of n items each, at offsets step
  apart. If step is not supplied, defaults to n, i.e. the partitions
  do not overlap. If a pad collection is supplied, use its elements as
  necessary to complete last partition upto n items. In case there are
  not enough padding elements, return a partition with less than n items.">partition</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">step</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">p</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/doall" title="When lazy sequences are produced via functions that have side
  effects, any effects other than those needed to produce the first
  element in the seq do not occur until the seq is consumed. doall can
  be used to force any effects. Walks through the successive nexts of
  the seq, retains the head and returns it, thus causing the entire
  seq to reside in memory at one time.">doall</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take" title="Returns a lazy sequence of the first n items in coll, or all items if
  there are fewer than n.  Returns a stateful transducer when
  no collection is provided.">take</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">p</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">p</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition" title="Returns a lazy sequence of lists of n items each, at offsets step
  apart. If step is not supplied, defaults to n, i.e. the partitions
  do not overlap. If a pad collection is supplied, use its elements as
  necessary to complete last partition upto n items. In case there are
  not enough padding elements, return a partition with less than n items.">partition</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">step</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nthrest" title="Returns the nth rest of coll, coll when n is 0.">nthrest</a></span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">step</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">step</span><span class="whitespace"> </span><span class="symbol">pad</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">p</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/doall" title="When lazy sequences are produced via functions that have side
  effects, any effects other than those needed to produce the first
  element in the seq do not occur until the seq is consumed. doall can
  be used to force any effects. Walks through the successive nexts of
  the seq, retains the head and returns it, thus causing the entire
  seq to reside in memory at one time.">doall</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take" title="Returns a lazy sequence of the first n items in coll, or all items if
  there are fewer than n.  Returns a stateful transducer when
  no collection is provided.">take</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">p</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">p</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition" title="Returns a lazy sequence of lists of n items each, at offsets step
  apart. If step is not supplied, defaults to n, i.e. the partitions
  do not overlap. If a pad collection is supplied, use its elements as
  necessary to complete last partition upto n items. In case there are
  not enough padding elements, return a partition with less than n items.">partition</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">step</span><span class="whitespace"> </span><span class="symbol">pad</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nthrest" title="Returns the nth rest of coll, coll when n is 0.">nthrest</a></span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">step</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take" title="Returns a lazy sequence of the first n items in coll, or all items if
  there are fewer than n.  Returns a stateful transducer when
  no collection is provided.">take</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/concat" title="Returns a lazy seq representing the concatenation of the elements in the supplied colls.">concat</a></span><span class="whitespace"> </span><span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">pad</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;; evaluation</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/eval" title="Evaluates the form data structure (not text!) and returns the result.">eval</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Evaluates the form data structure (not text!) and returns the result."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">form</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Compiler</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/eval" title="Evaluates the form data structure (not text!) and returns the result.">eval</a></span><span class="whitespace"> </span><span class="symbol">form</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/doseq" title="Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by &quot;for&quot;.  Does not retain
  the head of the sequence. Returns nil.">doseq</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by \"for\".  Does not retain
  the head of the sequence. Returns nil."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">seq-exprs</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">assert-args</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">seq-exprs</span>)</span><span class="whitespace"> </span><span class="string">"a vector for its binding"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/even?" title="Returns true if n is even, throws an exception if n is not an integer">even?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">seq-exprs</span>)</span>)</span><span class="whitespace"> </span><span class="string">"an even number of forms in binding vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">step</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">step</span><span class="whitespace"> </span><span>[<span class="symbol">recform</span><span class="whitespace"> </span><span class="symbol">exprs</span>]</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-not" title="Evaluates test. If logical false, evaluates and returns then expr, 
  otherwise else expr, if supplied, else nil.">if-not</a></span><span class="whitespace"> </span><span class="symbol">exprs</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>[<span class="unknown">true</span><span class="whitespace"> </span>`<span>(<span class="macro">do</span><span class="whitespace"> </span>~<span class="unknown">@body</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">exprs</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">exprs</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">steppair</span><span class="whitespace"> </span><span>(<span class="symbol">step</span><span class="whitespace"> </span><span class="symbol">recform</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nnext" title="Same as (next (next x))">nnext</a></span><span class="whitespace"> </span><span class="symbol">exprs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">needrec</span><span class="whitespace"> </span><span>(<span class="symbol">steppair</span><span class="whitespace"> </span><span class="unknown">0</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">subform</span><span class="whitespace"> </span><span>(<span class="symbol">steppair</span><span class="whitespace"> </span><span class="unknown">1</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="keyword">:let</span>)</span><span class="whitespace"> </span><span>[<span class="symbol">needrec</span><span class="whitespace"> </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span>~<span class="symbol">v</span><span class="whitespace"> </span>~<span class="symbol">subform</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="keyword">:while</span>)</span><span class="whitespace"> </span><span>[<span class="unknown">false</span><span class="whitespace"> </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span>~<span class="symbol">v</span><span class="whitespace">
</span><span class="whitespace">                                                </span>~<span class="symbol">subform</span><span class="whitespace">
</span><span class="whitespace">                                                </span>~<span class="unparsed">@</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">needrec</span><span class="whitespace"> </span><span>[<span class="symbol">recform</span>]</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="keyword">:when</span>)</span><span class="whitespace"> </span><span>[<span class="unknown">false</span><span class="whitespace"> </span>`<span>(<span class="macro">if</span><span class="whitespace"> </span>~<span class="symbol">v</span><span class="whitespace">
</span><span class="whitespace">                                               </span><span>(<span class="macro">do</span><span class="whitespace">
</span><span class="whitespace">                                                 </span>~<span class="symbol">subform</span><span class="whitespace">
</span><span class="whitespace">                                                 </span>~<span class="unparsed">@</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">needrec</span><span class="whitespace"> </span><span>[<span class="symbol">recform</span>]</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                               </span>~<span class="symbol">recform</span>)</span>]</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">seq-</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"seq_"</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">chunk-</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"chunk_"</span>)</span><span class="whitespace">
</span><span class="whitespace">                                             </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span>'<span class="java-class">clojure.lang.IChunk</span></span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">count-</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"count_"</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">i-</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"i_"</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">recform</span><span class="whitespace"> </span>`<span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span>~<span class="symbol">seq-</span>)</span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span class="unknown">0</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">steppair</span><span class="whitespace"> </span><span>(<span class="symbol">step</span><span class="whitespace"> </span><span class="symbol">recform</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nnext" title="Same as (next (next x))">nnext</a></span><span class="whitespace"> </span><span class="symbol">exprs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">needrec</span><span class="whitespace"> </span><span>(<span class="symbol">steppair</span><span class="whitespace"> </span><span class="unknown">0</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">subform</span><span class="whitespace"> </span><span>(<span class="symbol">steppair</span><span class="whitespace"> </span><span class="unknown">1</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">recform-chunk</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                             </span>`<span>(<span class="macro">recur</span><span class="whitespace"> </span>~<span class="symbol">seq-</span><span class="whitespace"> </span>~<span class="symbol">chunk-</span><span class="whitespace"> </span>~<span class="symbol">count-</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-inc" title="Returns a number one greater than x, a long.
  Note - uses a primitive operator subject to overflow.">unchecked-inc</a></span><span class="whitespace"> </span>~<span class="symbol">i-</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">steppair-chunk</span><span class="whitespace"> </span><span>(<span class="symbol">step</span><span class="whitespace"> </span><span class="symbol">recform-chunk</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nnext" title="Same as (next (next x))">nnext</a></span><span class="whitespace"> </span><span class="symbol">exprs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">subform-chunk</span><span class="whitespace"> </span><span>(<span class="symbol">steppair-chunk</span><span class="whitespace"> </span><span class="unknown">1</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>[<span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">                        </span>`<span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[~<span class="symbol">seq-</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span>~<span class="symbol">v</span>)</span><span class="whitespace">, </span>~<span class="symbol">chunk-</span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace">,</span><span class="whitespace">
</span><span class="whitespace">                                </span>~<span class="symbol">count-</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace">, </span>~<span class="symbol">i-</span><span class="whitespace"> </span><span class="unknown">0</span>]</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span>~<span class="symbol">i-</span><span class="whitespace"> </span>~<span class="symbol">count-</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="java-class">.nth</span><span class="whitespace"> </span>~<span class="symbol">chunk-</span><span class="whitespace"> </span>~<span class="symbol">i-</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                               </span>~<span class="symbol">subform-chunk</span><span class="whitespace">
</span><span class="whitespace">                               </span>~<span class="unparsed">@</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">needrec</span><span class="whitespace"> </span><span>[<span class="symbol">recform-chunk</span>]</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[~<span class="symbol">seq-</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span>~<span class="symbol">seq-</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                               </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunked-seq?">chunked-seq?</a></span><span class="whitespace"> </span>~<span class="symbol">seq-</span>)</span><span class="whitespace">
</span><span class="whitespace">                                 </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">c#</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-first">chunk-first</a></span><span class="whitespace"> </span>~<span class="symbol">seq-</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                                   </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-rest">chunk-rest</a></span><span class="whitespace"> </span>~<span class="symbol">seq-</span>)</span><span class="whitespace"> </span><span class="symbol">c#</span><span class="whitespace">
</span><span class="whitespace">                                          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">c#</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span class="unknown">0</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                 </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span>~<span class="symbol">seq-</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                                   </span>~<span class="symbol">subform</span><span class="whitespace">
</span><span class="whitespace">                                   </span>~<span class="unparsed">@</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">needrec</span><span class="whitespace"> </span><span>[<span class="symbol">recform</span>]</span>)</span>)</span>)</span>)</span>)</span>)</span>]</span>)</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nth" title="Returns the value at the index. get returns nil if index out of
  bounds, nth throws an exception unless not-found is supplied.  nth
  also works for strings, Java arrays, regex Matchers and Lists, and,
  in O(n) time, for sequences.">nth</a></span><span class="whitespace"> </span><span>(<span class="symbol">step</span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">seq-exprs</span>)</span>)</span><span class="whitespace"> </span><span class="unknown">1</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/await" title="Blocks the current thread (indefinitely!) until all actions
  dispatched thus far, from this thread or agent, to the agent(s) have
  occurred.  Will block on failed agents.  Will never return if
  a failed agent is restarted with :clear-actions true.">await</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Blocks the current thread (indefinitely!) until all actions
  dispatched thus far, from this thread or agent, to the agent(s) have
  occurred.  Will block on failed agents.  Will never return if
  a failed agent is restarted with :clear-actions true."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">agents</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/io!" title="If an io! block occurs in a transaction, throws an
  IllegalStateException, else runs body in an implicit do. If the
  first expression in body is a literal string, will use that as the
  exception message.">io!</a></span><span class="whitespace"> </span><span class="string">"await in transaction"</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*agent*" title="The agent currently running an action on this thread, else nil">*agent*</a></span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">Exception</span><span class="whitespace"> </span><span class="string">"Can't await in agent action"</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">latch</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">java.util.concurrent.CountDownLatch</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">agents</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">count-down</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/agent" title="Creates and returns an agent with an initial value of state and
  zero or more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :error-handler handler-fn

  :error-mode mode-keyword

  If metadata-map is supplied, it will become the metadata on the
  agent. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.  handler-fn is called if an
  action throws an exception or if validate-fn rejects a new state --
  see set-error-handler! for details.  The mode-keyword may be either
  :continue (the default if an error-handler is given) or :fail (the
  default if no error-handler is given) -- see set-error-mode! for
  details.">agent</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">latch</span><span class="whitespace"> </span><span>(<span class="symbol">countDown</span>)</span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/agent" title="Creates and returns an agent with an initial value of state and
  zero or more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :error-handler handler-fn

  :error-mode mode-keyword

  If metadata-map is supplied, it will become the metadata on the
  agent. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.  handler-fn is called if an
  action throws an exception or if validate-fn rejects a new state --
  see set-error-handler! for details.  The mode-keyword may be either
  :continue (the default if an error-handler is given) or :fail (the
  default if no error-handler is given) -- see set-error-mode! for
  details.">agent</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/doseq" title="Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by &quot;for&quot;.  Does not retain
  the head of the sequence. Returns nil.">doseq</a></span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/agent" title="Creates and returns an agent with an initial value of state and
  zero or more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :error-handler handler-fn

  :error-mode mode-keyword

  If metadata-map is supplied, it will become the metadata on the
  agent. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.  handler-fn is called if an
  action throws an exception or if validate-fn rejects a new state --
  see set-error-handler! for details.  The mode-keyword may be either
  :continue (the default if an error-handler is given) or :fail (the
  default if no error-handler is given) -- see set-error-mode! for
  details.">agent</a></span><span class="whitespace"> </span><span class="symbol">agents</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/send" title="Dispatch an action to an agent. Returns the agent immediately.
  Subsequently, in a thread from a thread pool, the state of the agent
  will be set to the value of:

  (apply action-fn state-of-agent args)">send</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/agent" title="Creates and returns an agent with an initial value of state and
  zero or more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :error-handler handler-fn

  :error-mode mode-keyword

  If metadata-map is supplied, it will become the metadata on the
  agent. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.  handler-fn is called if an
  action throws an exception or if validate-fn rejects a new state --
  see set-error-handler! for details.  The mode-keyword may be either
  :continue (the default if an error-handler is given) or :fail (the
  default if no error-handler is given) -- see set-error-mode! for
  details.">agent</a></span><span class="whitespace"> </span><span class="symbol">count-down</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">latch</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/await" title="Blocks the current thread (indefinitely!) until all actions
  dispatched thus far, from this thread or agent, to the agent(s) have
  occurred.  Will block on failed agents.  Will never return if
  a failed agent is restarted with :clear-actions true.">await</a></span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:static</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/await1">await1</a></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.Agent</span></span><span class="whitespace"> </span><span class="symbol">a</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace"> </span><span>(<span class="java-class">.getQueueCount</span><span class="whitespace"> </span><span class="symbol">a</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/await" title="Blocks the current thread (indefinitely!) until all actions
  dispatched thus far, from this thread or agent, to the agent(s) have
  occurred.  Will block on failed agents.  Will never return if
  a failed agent is restarted with :clear-actions true.">await</a></span><span class="whitespace"> </span><span class="symbol">a</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="symbol">a</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/await-for" title="Blocks the current thread until all actions dispatched thus
  far (from this thread or agent) to the agents have occurred, or the
  timeout (in milliseconds) has elapsed. Returns logical false if
  returning due to timeout, logical true otherwise.">await-for</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Blocks the current thread until all actions dispatched thus
  far (from this thread or agent) to the agents have occurred, or the
  timeout (in milliseconds) has elapsed. Returns logical false if
  returning due to timeout, logical true otherwise."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">timeout-ms</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">agents</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/io!" title="If an io! block occurs in a transaction, throws an
  IllegalStateException, else runs body in an implicit do. If the
  first expression in body is a literal string, will use that as the
  exception message.">io!</a></span><span class="whitespace"> </span><span class="string">"await-for in transaction"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*agent*" title="The agent currently running an action on this thread, else nil">*agent*</a></span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">Exception</span><span class="whitespace"> </span><span class="string">"Can't await in agent action"</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">latch</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">java.util.concurrent.CountDownLatch</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">agents</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span class="symbol">count-down</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/agent" title="Creates and returns an agent with an initial value of state and
  zero or more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :error-handler handler-fn

  :error-mode mode-keyword

  If metadata-map is supplied, it will become the metadata on the
  agent. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.  handler-fn is called if an
  action throws an exception or if validate-fn rejects a new state --
  see set-error-handler! for details.  The mode-keyword may be either
  :continue (the default if an error-handler is given) or :fail (the
  default if no error-handler is given) -- see set-error-mode! for
  details.">agent</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">latch</span><span class="whitespace"> </span><span>(<span class="symbol">countDown</span>)</span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/agent" title="Creates and returns an agent with an initial value of state and
  zero or more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :error-handler handler-fn

  :error-mode mode-keyword

  If metadata-map is supplied, it will become the metadata on the
  agent. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.  handler-fn is called if an
  action throws an exception or if validate-fn rejects a new state --
  see set-error-handler! for details.  The mode-keyword may be either
  :continue (the default if an error-handler is given) or :fail (the
  default if no error-handler is given) -- see set-error-mode! for
  details.">agent</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/doseq" title="Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by &quot;for&quot;.  Does not retain
  the head of the sequence. Returns nil.">doseq</a></span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/agent" title="Creates and returns an agent with an initial value of state and
  zero or more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :error-handler handler-fn

  :error-mode mode-keyword

  If metadata-map is supplied, it will become the metadata on the
  agent. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.  handler-fn is called if an
  action throws an exception or if validate-fn rejects a new state --
  see set-error-handler! for details.  The mode-keyword may be either
  :continue (the default if an error-handler is given) or :fail (the
  default if no error-handler is given) -- see set-error-mode! for
  details.">agent</a></span><span class="whitespace"> </span><span class="symbol">agents</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/send" title="Dispatch an action to an agent. Returns the agent immediately.
  Subsequently, in a thread from a thread pool, the state of the agent
  will be set to the value of:

  (apply action-fn state-of-agent args)">send</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/agent" title="Creates and returns an agent with an initial value of state and
  zero or more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :error-handler handler-fn

  :error-mode mode-keyword

  If metadata-map is supplied, it will become the metadata on the
  agent. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.  handler-fn is called if an
  action throws an exception or if validate-fn rejects a new state --
  see set-error-handler! for details.  The mode-keyword may be either
  :continue (the default if an error-handler is given) or :fail (the
  default if no error-handler is given) -- see set-error-mode! for
  details.">agent</a></span><span class="whitespace"> </span><span class="symbol">count-down</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">latch</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/await" title="Blocks the current thread (indefinitely!) until all actions
  dispatched thus far, from this thread or agent, to the agent(s) have
  occurred.  Will block on failed agents.  Will never return if
  a failed agent is restarted with :clear-actions true.">await</a></span><span class="whitespace">  </span><span class="symbol">timeout-ms</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">java.util.concurrent.TimeUnit</span><span class="whitespace"> </span><span class="symbol">MILLISECONDS</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/dotimes" title="bindings =&gt; name n

  Repeatedly executes body (presumably for side-effects) with name
  bound to integers from 0 through n-1.">dotimes</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"bindings => name n

  Repeatedly executes body (presumably for side-effects) with name
  bound to integers from 0 through n-1."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">assert-args</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace"> </span><span class="string">"a vector for its binding"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span><span class="whitespace"> </span><span class="string">"exactly 2 forms in binding vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">n</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">n#</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long" title="Coerce to long">long</a></span><span class="whitespace"> </span>~<span class="symbol">n</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[~<span class="symbol">i</span><span class="whitespace"> </span><span class="unknown">0</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span>~<span class="symbol">i</span><span class="whitespace"> </span><span class="symbol">n#</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span>~<span class="unknown">@body</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-inc" title="Returns a number one greater than x, a long.
  Note - uses a primitive operator subject to overflow.">unchecked-inc</a></span><span class="whitespace"> </span>~<span class="symbol">i</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="metadata">#_</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/into" title="Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined. A transducer may be supplied.">into</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">to</span><span class="whitespace"> </span><span class="symbol">from</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">to</span><span class="whitespace"> </span><span class="symbol">items</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">from</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">items</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">items</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">items</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">ret</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;; editable collections ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transient" title="Returns a new, transient version of the collection, in constant time.">transient</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a new, transient version of the collection, in constant time."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.IEditableCollection</span></span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.asTransient</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/persistent!" title="Returns a new, persistent version of the transient collection, in
  constant time. The transient collection cannot be used after this
  call, any such use will throw an exception.">persistent!</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a new, persistent version of the transient collection, in
  constant time. The transient collection cannot be used after this
  call, any such use will throw an exception."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.ITransientCollection</span></span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.persistent</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Adds x to the transient collection, and return coll. The 'addition'
  may happen at different 'places' depending on the concrete type."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transient" title="Returns a new, transient version of the collection, in constant time.">transient</a></span><span class="whitespace"> </span><span>[]</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.ITransientCollection</span></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">.conj</span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc!" title="When applied to a transient map, adds mapping of key(s) to
  val(s). When applied to a transient vector, sets the val at index.
  Note - index must be &lt;= (count vector). Returns coll.">assoc!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"When applied to a transient map, adds mapping of key(s) to
  val(s). When applied to a transient vector, sets the val at index.
  Note - index must be <= (count vector). Returns coll."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.ITransientAssociative</span></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.assoc</span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.ITransientAssociative</span></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">kvs</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="java-class">.assoc</span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">kvs</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">kvs</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">kvs</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nnext" title="Same as (next (next x))">nnext</a></span><span class="whitespace"> </span><span class="symbol">kvs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dissoc!" title="Returns a transient map that doesn&apos;t contain a mapping for key(s).">dissoc!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a transient map that doesn't contain a mapping for key(s)."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.ITransientMap</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.without</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.ITransientMap</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">ks</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="java-class">.without</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">ks</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pop!" title="Removes the last item from a transient vector. If
  the collection is empty, throws an exception. Returns coll">pop!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Removes the last item from a transient vector. If
  the collection is empty, throws an exception. Returns coll"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.ITransientVector</span></span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.pop</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/disj!" title="disj[oin]. Returns a transient set of the same (hashed/sorted) type, that
  does not contain key(s).">disj!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"disj[oin]. Returns a transient set of the same (hashed/sorted) type, that
  does not contain key(s)."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span>]</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.ITransientSet</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span>(<span class="symbol">disjoin</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.ITransientSet</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">ks</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span>(<span class="symbol">disjoin</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">ks</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;redef into with batch support</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:private</span></span><span class="whitespace"> </span><span class="symbol">into1</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">to</span><span class="whitespace"> </span><span class="symbol">from</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IEditableCollection</span><span class="whitespace"> </span><span class="symbol">to</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/persistent!" title="Returns a new, persistent version of the transient collection, in
  constant time. The transient collection cannot be used after this
  call, any such use will throw an exception.">persistent!</a></span><span class="whitespace"> </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transient" title="Returns a new, transient version of the collection, in constant time.">transient</a></span><span class="whitespace"> </span><span class="symbol">to</span>)</span><span class="whitespace"> </span><span class="symbol">from</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">to</span><span class="whitespace"> </span><span class="symbol">from</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/import" title="import-list =&gt; (package-symbol class-name-symbols*)

  For each name in class-name-symbols, adds a mapping from name to the
  class named by package.name to the current namespace. Use :import in the ns
  macro in preference to calling this directly.">import</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"import-list => (package-symbol class-name-symbols*)

  For each name in class-name-symbols, adds a mapping from name to the
  class named by package.name to the current namespace. Use :import in the ns
  macro in preference to calling this directly."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">import-symbols-or-lists</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">specs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span>'<span class="macro">quote</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">import-symbols-or-lists</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">do</span><span class="whitespace"> </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="symbol">import*</span></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">spec</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                          </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="symbol">spec</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">spec</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">p</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">spec</span>)</span><span class="whitespace"> </span><span class="symbol">cs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">spec</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                              </span><span>(<span class="symbol">into1</span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="symbol">p</span><span class="whitespace"> </span><span class="string">"."</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">cs</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>[]</span><span class="whitespace"> </span><span class="symbol">specs</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/into-array" title="Returns an array with components set to the values in aseq. The array&apos;s
  component type is type if provided, or the type of the first value in
  aseq if present, or Object. All values in aseq must be compatible with
  the component type. Class objects for the primitive types can be obtained
  using, e.g., Integer/TYPE.">into-array</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns an array with components set to the values in aseq. The array's
  component type is type if provided, or the type of the first value in
  aseq if present, or Object. All values in aseq must be compatible with
  the component type. Class objects for the primitive types can be obtained
  using, e.g., Integer/TYPE."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">aseq</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">seqToTypedArray</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">aseq</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/type" title="Returns the :type metadata of x, or its Class if none">type</a></span><span class="whitespace"> </span><span class="symbol">aseq</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">seqToTypedArray</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/type" title="Returns the :type metadata of x, or its Class if none">type</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">aseq</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="symbol">array</span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">items</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/into-array" title="Returns an array with components set to the values in aseq. The array&apos;s
  component type is type if provided, or the type of the first value in
  aseq if present, or Object. All values in aseq must be compatible with
  the component type. Class objects for the primitive types can be obtained
  using, e.g., Integer/TYPE.">into-array</a></span><span class="whitespace"> </span><span class="symbol">items</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class" title="Returns the Class of x">class</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the Class of x"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span class="java-class">Class</span></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">Object</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="symbol">getClass</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/type" title="Returns the :type metadata of x, or its Class if none">type</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the :type metadata of x, or its Class if none"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="keyword">:type</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class" title="Returns the Class of x">class</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/num" title="Coerce to Number">num</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to Number"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">Number</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/num" title="Coerce to Number">num</a></span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/num" title="Coerce to Number">num</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long" title="Coerce to long">long</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to long"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">longCast</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Number</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">longCast</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/float" title="Coerce to float">float</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to float"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(~<span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*unchecked-math*" title="While bound to true, compilations of +, -, *, inc, dec and the
  coercions will be done without overflow checks. While bound
  to :warn-on-boxed, same behavior as true, and a warning is emitted
  when compilation uses boxed math. Default: false.">*unchecked-math*</a></span><span class="whitespace"> </span><span>'<span class="symbol">uncheckedFloatCast</span></span><span class="whitespace"> </span><span>'<span class="symbol">floatCast</span></span>)</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Number</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">floatCast</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/double" title="Coerce to double">double</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to double"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">doubleCast</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Number</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">doubleCast</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/short" title="Coerce to short">short</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to short"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(~<span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*unchecked-math*" title="While bound to true, compilations of +, -, *, inc, dec and the
  coercions will be done without overflow checks. While bound
  to :warn-on-boxed, same behavior as true, and a warning is emitted
  when compilation uses boxed math. Default: false.">*unchecked-math*</a></span><span class="whitespace"> </span><span>'<span class="symbol">uncheckedShortCast</span></span><span class="whitespace"> </span><span>'<span class="symbol">shortCast</span></span>)</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Number</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">shortCast</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/byte" title="Coerce to byte">byte</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to byte"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(~<span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*unchecked-math*" title="While bound to true, compilations of +, -, *, inc, dec and the
  coercions will be done without overflow checks. While bound
  to :warn-on-boxed, same behavior as true, and a warning is emitted
  when compilation uses boxed math. Default: false.">*unchecked-math*</a></span><span class="whitespace"> </span><span>'<span class="symbol">uncheckedByteCast</span></span><span class="whitespace"> </span><span>'<span class="symbol">byteCast</span></span>)</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Number</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">byteCast</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/char" title="Coerce to char">char</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to char"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(~<span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*unchecked-math*" title="While bound to true, compilations of +, -, *, inc, dec and the
  coercions will be done without overflow checks. While bound
  to :warn-on-boxed, same behavior as true, and a warning is emitted
  when compilation uses boxed math. Default: false.">*unchecked-math*</a></span><span class="whitespace"> </span><span>'<span class="symbol">uncheckedCharCast</span></span><span class="whitespace"> </span><span>'<span class="symbol">charCast</span></span>)</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">charCast</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to boolean"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">booleanCast</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">booleanCast</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-byte" title="Coerce to byte. Subject to rounding or truncation.">unchecked-byte</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to byte. Subject to rounding or truncation."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">uncheckedByteCast</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Number</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">uncheckedByteCast</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-short" title="Coerce to short. Subject to rounding or truncation.">unchecked-short</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to short. Subject to rounding or truncation."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">uncheckedShortCast</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Number</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">uncheckedShortCast</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-char" title="Coerce to char. Subject to rounding or truncation.">unchecked-char</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to char. Subject to rounding or truncation."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">uncheckedCharCast</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">uncheckedCharCast</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-int" title="Coerce to int. Subject to rounding or truncation.">unchecked-int</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to int. Subject to rounding or truncation."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">uncheckedIntCast</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Number</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">uncheckedIntCast</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-long" title="Coerce to long. Subject to rounding or truncation.">unchecked-long</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to long. Subject to rounding or truncation."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">uncheckedLongCast</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Number</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">uncheckedLongCast</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-float" title="Coerce to float. Subject to rounding.">unchecked-float</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to float. Subject to rounding."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">uncheckedFloatCast</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Number</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">uncheckedFloatCast</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-double" title="Coerce to double. Subject to rounding.">unchecked-double</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to double. Subject to rounding."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="symbol">uncheckedDoubleCast</span><span class="whitespace"> </span>~<span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Number</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">uncheckedDoubleCast</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/number?" title="Returns true if x is a Number">number?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x is a Number"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Number</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/mod" title="Modulus of num and div. Truncates toward negative infinity.">mod</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Modulus of num and div. Truncates toward negative infinity."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/num" title="Coerce to Number">num</a></span><span class="whitespace"> </span><span class="symbol">div</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rem" title="remainder of dividing numerator by denominator.">rem</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/num" title="Coerce to Number">num</a></span><span class="whitespace"> </span><span class="symbol">div</span>)</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/zero?" title="Returns true if num is zero, else false">zero?</a></span><span class="whitespace"> </span><span class="symbol">m</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/num" title="Coerce to Number">num</a></span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace"> </span><span class="symbol">div</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="symbol">m</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">div</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ratio?" title="Returns true if n is a Ratio">ratio?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if n is a Ratio"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Ratio</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/numerator" title="Returns the numerator part of a Ratio.">numerator</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the numerator part of a Ratio."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">BigInteger</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">r</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.numerator</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Ratio</span></span><span class="whitespace"> </span><span class="symbol">r</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/denominator" title="Returns the denominator part of a Ratio.">denominator</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the denominator part of a Ratio."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">BigInteger</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">r</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.denominator</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Ratio</span></span><span class="whitespace"> </span><span class="symbol">r</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/decimal?" title="Returns true if n is a BigDecimal">decimal?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if n is a BigDecimal"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">BigDecimal</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/float?" title="Returns true if n is a floating point number">float?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if n is a floating point number"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">n</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Double</span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Float</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rational?" title="Returns true if n is a rational number">rational?</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if n is a rational number"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">n</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/integer?" title="Returns true if n is an integer">integer?</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ratio?" title="Returns true if n is a Ratio">ratio?</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/decimal?" title="Returns true if n is a BigDecimal">decimal?</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bigint" title="Coerce to BigInt">bigint</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to BigInt"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">clojure.lang.BigInt</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.BigInt</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">BigInteger</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.BigInt/<span class="symbol">fromBigInteger</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/decimal?" title="Returns true if n is a BigDecimal">decimal?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bigint" title="Coerce to BigInt">bigint</a></span><span class="whitespace"> </span><span>(<span class="java-class">.toBigInteger</span><span class="whitespace"> </span><span>^<span class="java-class">BigDecimal</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/float?" title="Returns true if n is a floating point number">float?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bigint" title="Coerce to BigInt">bigint</a></span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">BigDecimal</span><span class="whitespace"> </span><span class="symbol">valueOf</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/double" title="Coerce to double">double</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ratio?" title="Returns true if n is a Ratio">ratio?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bigint" title="Coerce to BigInt">bigint</a></span><span class="whitespace"> </span><span>(<span class="java-class">.bigIntegerValue</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Ratio</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/number?" title="Returns true if x is a Number">number?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.BigInt/<span class="symbol">valueOf</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long" title="Coerce to long">long</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span class="keyword">:else</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bigint" title="Coerce to BigInt">bigint</a></span><span class="whitespace"> </span><span>(<span class="symbol">BigInteger.</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/biginteger" title="Coerce to BigInteger">biginteger</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to BigInteger"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">BigInteger</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">BigInteger</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.BigInt</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">.toBigInteger</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.BigInt</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/decimal?" title="Returns true if n is a BigDecimal">decimal?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">.toBigInteger</span><span class="whitespace"> </span><span>^<span class="java-class">BigDecimal</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/float?" title="Returns true if n is a floating point number">float?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">.toBigInteger</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">BigDecimal</span><span class="whitespace"> </span><span class="symbol">valueOf</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/double" title="Coerce to double">double</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ratio?" title="Returns true if n is a Ratio">ratio?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">.bigIntegerValue</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Ratio</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/number?" title="Returns true if x is a Number">number?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">BigInteger/<span class="symbol">valueOf</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long" title="Coerce to long">long</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span class="keyword">:else</span><span class="whitespace"> </span><span>(<span class="symbol">BigInteger.</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bigdec" title="Coerce to BigDecimal">bigdec</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Coerce to BigDecimal"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">BigDecimal</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/decimal?" title="Returns true if n is a BigDecimal">decimal?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/float?" title="Returns true if n is a floating point number">float?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">BigDecimal</span><span class="whitespace"> </span><span class="symbol">valueOf</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/double" title="Coerce to double">double</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ratio?" title="Returns true if n is a Ratio">ratio?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core//" title="If no denominators are supplied, returns 1/numerator,
  else returns numerator divided by all of the denominators.">/</a></span><span class="whitespace"> </span><span>(<span class="symbol">BigDecimal.</span><span class="whitespace"> </span><span>(<span class="java-class">.numerator</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Ratio</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">.denominator</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Ratio</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.BigInt</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">.toBigDecimal</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.BigInt</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">BigInteger</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">BigDecimal.</span><span class="whitespace"> </span><span>^<span class="java-class">BigInteger</span></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/number?" title="Returns true if x is a Number">number?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">BigDecimal/<span class="symbol">valueOf</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long" title="Coerce to long">long</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span class="keyword">:else</span><span class="whitespace"> </span><span>(<span class="symbol">BigDecimal.</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span class="keyword">:dynamic</span></span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace"> </span><span class="symbol">print-initialized</span><span class="whitespace"> </span><span class="unknown">false</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmulti" title="Creates a new multimethod with the associated dispatch function.
  The docstring and attr-map are optional.

  Options are key-value pairs and may be one of:

  :default

  The default dispatch value, defaults to :default

  :hierarchy

  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)

  Hierarchies are type-like relationships that do not depend upon type
  inheritance. By default Clojure&apos;s multimethods dispatch off of a
  global hierarchy map.  However, a hierarchy relationship can be
  created with the derive function used to augment the root ancestor
  created with make-hierarchy.

  Multimethods expect the value of the hierarchy option to be supplied as
  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #&apos;
  or the var special form).">defmulti</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/print-method">print-method</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">writer</span>]</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">t</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="keyword">:type</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace"> </span><span class="symbol">t</span>)</span><span class="whitespace"> </span><span class="symbol">t</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class" title="Returns the Class of x">class</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmulti" title="Creates a new multimethod with the associated dispatch function.
  The docstring and attr-map are optional.

  Options are key-value pairs and may be one of:

  :default

  The default dispatch value, defaults to :default

  :hierarchy

  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)

  Hierarchies are type-like relationships that do not depend upon type
  inheritance. By default Clojure&apos;s multimethods dispatch off of a
  global hierarchy map.  However, a hierarchy relationship can be
  created with the derive function used to augment the root ancestor
  created with make-hierarchy.

  Multimethods expect the value of the hierarchy option to be supplied as
  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #&apos;
  or the var special form).">defmulti</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/print-dup">print-dup</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">writer</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class" title="Returns the Class of x">class</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="symbol">pr-on</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">w</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*print-dup*" title="When set to logical true, objects will be printed in a way that preserves
  their type when read in later.

  Defaults to false.">*print-dup*</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/print-dup">print-dup</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">w</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/print-method">print-method</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">w</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pr" title="Prints the object(s) to the output stream that is the current value
  of *out*.  Prints the object(s), separated by spaces if there is
  more than one.  By default, pr and prn print in a way that objects
  can be read by the reader">pr</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Prints the object(s) to the output stream that is the current value
  of *out*.  Prints the object(s), separated by spaces if there is
  more than one.  By default, pr and prn print in a way that objects
  can be read by the reader"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:dynamic</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">pr-on</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*out*" title="A java.io.Writer object representing standard output for print operations.

  Defaults to System/out, wrapped in an OutputStreamWriter">*out*</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pr" title="Prints the object(s) to the output stream that is the current value
  of *out*.  Prints the object(s), separated by spaces if there is
  more than one.  By default, pr and prn print in a way that objects
  can be read by the reader">pr</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*out*" title="A java.io.Writer object representing standard output for print operations.

  Defaults to System/out, wrapped in an OutputStreamWriter">*out*</a></span><span class="whitespace"> </span><span>(<span class="symbol">append</span><span class="whitespace"> </span><span class="string">s</span><span class="symbol">pace</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">nmore</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace"> </span><span class="symbol">nmore</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pr" title="Prints the object(s) to the output stream that is the current value
  of *out*.  Prints the object(s), separated by spaces if there is
  more than one.  By default, pr and prn print in a way that objects
  can be read by the reader">pr</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span class="keyword">:private</span></span><span class="whitespace"> </span><span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">system-newline</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">System/<span class="symbol">getProperty</span></span><span class="whitespace"> </span><span class="string">"line.separator"</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/newline" title="Writes a platform-specific newline to *out*">newline</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Writes a platform-specific newline to *out*"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*out*" title="A java.io.Writer object representing standard output for print operations.

  Defaults to System/out, wrapped in an OutputStreamWriter">*out*</a></span><span class="whitespace"> </span><span>(<span class="symbol">append</span><span class="whitespace"> </span><span class="symbol">system-newline</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/flush" title="Flushes the output stream that is the current value of
  *out*">flush</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Flushes the output stream that is the current value of
  *out*"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*out*" title="A java.io.Writer object representing standard output for print operations.

  Defaults to System/out, wrapped in an OutputStreamWriter">*out*</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/flush" title="Flushes the output stream that is the current value of
  *out*">flush</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/prn" title="Same as pr followed by (newline). Observes *flush-on-newline*">prn</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Same as pr followed by (newline). Observes *flush-on-newline*"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pr" title="Prints the object(s) to the output stream that is the current value
  of *out*.  Prints the object(s), separated by spaces if there is
  more than one.  By default, pr and prn print in a way that objects
  can be read by the reader">pr</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/newline" title="Writes a platform-specific newline to *out*">newline</a></span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*flush-on-newline*" title="When set to true, output will be flushed whenever a newline is printed.

  Defaults to true.">*flush-on-newline*</a></span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/flush" title="Flushes the output stream that is the current value of
  *out*">flush</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/print" title="Prints the object(s) to the output stream that is the current value
  of *out*.  print and println produce output for human consumption.">print</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Prints the object(s) to the output stream that is the current value
  of *out*.  print and println produce output for human consumption."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/binding" title="binding =&gt; var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.">binding</a></span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*print-readably*" title="When set to logical false, strings and characters will be printed with
  non-alphanumeric characters converted to the appropriate escape sequences.

  Defaults to true">*print-readably*</a></span><span class="whitespace"> </span><span class="unparsed">nil</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pr" title="Prints the object(s) to the output stream that is the current value
  of *out*.  Prints the object(s), separated by spaces if there is
  more than one.  By default, pr and prn print in a way that objects
  can be read by the reader">pr</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/println" title="Same as print followed by (newline)">println</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Same as print followed by (newline)"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/binding" title="binding =&gt; var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.">binding</a></span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*print-readably*" title="When set to logical false, strings and characters will be printed with
  non-alphanumeric characters converted to the appropriate escape sequences.

  Defaults to true">*print-readably*</a></span><span class="whitespace"> </span><span class="unparsed">nil</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/prn" title="Same as pr followed by (newline). Observes *flush-on-newline*">prn</a></span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/read" title="Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of *in*.

  Opts is a persistent map with valid keys:
    :read-cond - :allow to process reader conditionals, or
                 :preserve to keep all branches
    :features - persistent set of feature keywords for reader conditionals
    :eof - on eof, return value unless :eofthrow, then throw.
           if not specified, will throw

  Note that read can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read">read</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of *in*.

  Opts is a persistent map with valid keys:
    :read-cond - :allow to process reader conditionals, or
                 :preserve to keep all branches
    :features - persistent set of feature keywords for reader conditionals
    :eof - on eof, return value unless :eofthrow, then throw.
           if not specified, will throw

  Note that read can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/read" title="Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of *in*.

  Opts is a persistent map with valid keys:
    :read-cond - :allow to process reader conditionals, or
                 :preserve to keep all branches
    :features - persistent set of feature keywords for reader conditionals
    :eof - on eof, return value unless :eofthrow, then throw.
           if not specified, will throw

  Note that read can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read">read</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*in*" title="A java.io.Reader object representing standard input for read operations.

  Defaults to System/in, wrapped in a LineNumberingPushbackReader">*in*</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">stream</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/read" title="Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of *in*.

  Opts is a persistent map with valid keys:
    :read-cond - :allow to process reader conditionals, or
                 :preserve to keep all branches
    :features - persistent set of feature keywords for reader conditionals
    :eof - on eof, return value unless :eofthrow, then throw.
           if not specified, will throw

  Note that read can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read">read</a></span><span class="whitespace"> </span><span class="symbol">stream</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">stream</span><span class="whitespace"> </span><span class="symbol">eof-error?</span><span class="whitespace"> </span><span class="symbol">eof-value</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/read" title="Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of *in*.

  Opts is a persistent map with valid keys:
    :read-cond - :allow to process reader conditionals, or
                 :preserve to keep all branches
    :features - persistent set of feature keywords for reader conditionals
    :eof - on eof, return value unless :eofthrow, then throw.
           if not specified, will throw

  Note that read can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read">read</a></span><span class="whitespace"> </span><span class="symbol">stream</span><span class="whitespace"> </span><span class="symbol">eof-error?</span><span class="whitespace"> </span><span class="symbol">eof-value</span><span class="whitespace"> </span><span class="unknown">false</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">stream</span><span class="whitespace"> </span><span class="symbol">eof-error?</span><span class="whitespace"> </span><span class="symbol">eof-value</span><span class="whitespace"> </span><span class="symbol">recursive?</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.LispReader</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/read" title="Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of *in*.

  Opts is a persistent map with valid keys:
    :read-cond - :allow to process reader conditionals, or
                 :preserve to keep all branches
    :features - persistent set of feature keywords for reader conditionals
    :eof - on eof, return value unless :eofthrow, then throw.
           if not specified, will throw

  Note that read can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read">read</a></span><span class="whitespace"> </span><span class="symbol">stream</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span class="symbol">eof-error?</span>)</span><span class="whitespace"> </span><span class="symbol">eof-value</span><span class="whitespace"> </span><span class="symbol">recursive?</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">opts</span><span class="whitespace"> </span><span class="symbol">stream</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.LispReader</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/read" title="Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of *in*.

  Opts is a persistent map with valid keys:
    :read-cond - :allow to process reader conditionals, or
                 :preserve to keep all branches
    :features - persistent set of feature keywords for reader conditionals
    :eof - on eof, return value unless :eofthrow, then throw.
           if not specified, will throw

  Note that read can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read">read</a></span><span class="whitespace"> </span><span class="symbol">stream</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/read-line" title="Reads the next line from stream that is the current value of *in* .">read-line</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Reads the next line from stream that is the current value of *in* ."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.LineNumberingPushbackReader</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*in*" title="A java.io.Reader object representing standard input for read operations.

  Defaults to System/in, wrapped in a LineNumberingPushbackReader">*in*</a></span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.readLine</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.LineNumberingPushbackReader</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*in*" title="A java.io.Reader object representing standard input for read operations.

  Defaults to System/in, wrapped in a LineNumberingPushbackReader">*in*</a></span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.readLine</span><span class="whitespace"> </span><span>^<span class="java-class">java.io.BufferedReader</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*in*" title="A java.io.Reader object representing standard input for read operations.

  Defaults to System/in, wrapped in a LineNumberingPushbackReader">*in*</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/read-string" title="Reads one object from the string s. Optionally include reader
  options, as specified in read.

  Note that read-string can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read-string">read-string</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Reads one object from the string s. Optionally include reader
  options, as specified in read.

  Note that read-string can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read-string"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">s</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">readString</span></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">opts</span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">readString</span></span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/subvec" title="Returns a persistent vector of the items in vector from
  start (inclusive) to end (exclusive).  If end is not supplied,
  defaults to (count vector). This operation is O(1) and very fast, as
  the resulting vector shares structure with the original and no
  trimming is done.">subvec</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a persistent vector of the items in vector from
  start (inclusive) to end (exclusive).  If end is not supplied,
  defaults to (count vector). This operation is O(1) and very fast, as
  the resulting vector shares structure with the original and no
  trimming is done."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">start</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/subvec" title="Returns a persistent vector of the items in vector from
  start (inclusive) to end (exclusive).  If end is not supplied,
  defaults to (count vector). This operation is O(1) and very fast, as
  the resulting vector shares structure with the original and no
  trimming is done.">subvec</a></span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">start</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">start</span><span class="whitespace"> </span><span class="symbol">end</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/subvec" title="Returns a persistent vector of the items in vector from
  start (inclusive) to end (exclusive).  If end is not supplied,
  defaults to (count vector). This operation is O(1) and very fast, as
  the resulting vector shares structure with the original and no
  trimming is done.">subvec</a></span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">start</span><span class="whitespace"> </span><span class="symbol">end</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-open" title="bindings =&gt; [name init ...]

  Evaluates body in a try expression with names bound to the values
  of the inits, and a finally clause that calls (.close name) on each
  name in reverse order.">with-open</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"bindings => [name init ...]

  Evaluates body in a try expression with names bound to the values
  of the inits, and a finally clause that calls (.close name) on each
  name in reverse order."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">assert-args</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace"> </span><span class="string">"a vector for its binding"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/even?" title="Returns true if n is even, throws an exception if n is not an integer">even?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span><span class="whitespace"> </span><span class="string">"an even number of forms in binding vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace"> </span><span class="unknown">0</span>)</span><span class="whitespace"> </span>`<span>(<span class="macro">do</span><span class="whitespace"> </span>~<span class="unknown">@body</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span>(<span class="symbol">bindings</span><span class="whitespace"> </span><span class="unknown">0</span>)</span>)</span><span class="whitespace"> </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/subvec" title="Returns a persistent vector of the items in vector from
  start (inclusive) to end (exclusive).  If end is not supplied,
  defaults to (count vector). This operation is O(1) and very fast, as
  the resulting vector shares structure with the original and no
  trimming is done.">subvec</a></span><span class="whitespace"> </span><span class="symbol">bindings</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span class="unknown">2</span>)</span><span class="whitespace">
</span><span class="whitespace">                              </span><span>(<span class="macro">try</span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-open" title="bindings =&gt; [name init ...]

  Evaluates body in a try expression with names bound to the values
  of the inits, and a finally clause that calls (.close name) on each
  name in reverse order.">with-open</a></span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/subvec" title="Returns a persistent vector of the items in vector from
  start (inclusive) to end (exclusive).  If end is not supplied,
  defaults to (count vector). This operation is O(1) and very fast, as
  the resulting vector shares structure with the original and no
  trimming is done.">subvec</a></span><span class="whitespace"> </span><span class="symbol">bindings</span><span class="whitespace"> </span><span class="unknown">2</span>)</span><span class="whitespace"> </span>~<span class="unknown">@body</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="symbol">finally</span><span class="whitespace">
</span><span class="whitespace">                                  </span><span>(<span class="java-class">.</span><span class="whitespace"> </span>~<span>(<span class="symbol">bindings</span><span class="whitespace"> </span><span class="unknown">0</span>)</span><span class="whitespace"> </span><span class="symbol">close</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:else</span><span class="whitespace"> </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="string">"with-open only allows Symbols in bindings"</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/doto" title="Evaluates x then calls all of the methods and functions with the
  value of x supplied at the front of the given arguments.  The forms
  are evaluated in order.  Returns x.

  (doto (new java.util.HashMap) (.put &quot;a&quot; 1) (.put &quot;b&quot; 2))">doto</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Evaluates x then calls all of the methods and functions with the
  value of x supplied at the front of the given arguments.  The forms
  are evaluated in order.  Returns x.

  (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">forms</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">gx</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">gx</span><span class="whitespace"> </span>~<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">f</span>]</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span class="symbol">f</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span>`<span>(~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">f</span>)</span><span class="whitespace"> </span>~<span class="symbol">gx</span><span class="whitespace"> </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">f</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span>`<span>(~<span class="symbol">f</span><span class="whitespace"> </span>~<span class="symbol">gx</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span class="symbol">forms</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span>~<span class="symbol">gx</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/memfn" title="Expands into code that creates a fn that expects to be passed an
  object and any args and calls the named instance method on the
  object passing the args. Use when you want to treat a Java method as
  a first-class fn. name may be type-hinted with the method receiver&apos;s
  type in order to avoid reflective calls.">memfn</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Expands into code that creates a fn that expects to be passed an
  object and any args and calls the named instance method on the
  object passing the args. Use when you want to treat a Java method as
  a first-class fn. name may be type-hinted with the method receiver's
  type in order to avoid reflective calls."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">t</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"target"</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[~<span class="symbol">t</span><span class="whitespace"> </span>~<span class="unknown">@args</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="java-class">.</span><span class="whitespace"> </span>~<span class="symbol">t</span><span class="whitespace"> </span><span>(~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span>~<span class="unknown">@args</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/time" title="Evaluates expr and prints the time it took.  Returns the value of
 expr.">time</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Evaluates expr and prints the time it took.  Returns the value of
 expr."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">expr</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">start#</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">System</span><span class="whitespace"> </span><span>(<span class="symbol">nanoTime</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">ret#</span><span class="whitespace"> </span>~<span class="symbol">expr</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/prn" title="Same as pr followed by (newline). Observes *flush-on-newline*">prn</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Elapsed time: "</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core//" title="If no denominators are supplied, returns 1/numerator,
  else returns numerator divided by all of the denominators.">/</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/double" title="Coerce to double">double</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/-" title="If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Does not auto-promote
  longs, will throw on overflow. See also: -&apos;">-</a></span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">System</span><span class="whitespace"> </span><span>(<span class="symbol">nanoTime</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">start#</span>)</span>)</span><span class="whitespace"> </span><span class="unknown">1000000.0</span>)</span><span class="whitespace"> </span><span class="string">" msecs"</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="symbol">ret#</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/import" title="import-list =&gt; (package-symbol class-name-symbols*)

  For each name in class-name-symbols, adds a mapping from name to the
  class named by package.name to the current namespace. Use :import in the ns
  macro in preference to calling this directly.">import</a></span><span class="whitespace"> </span><span>'<span>(<span class="symbol">java.lang.reflect</span><span class="whitespace"> </span><span class="symbol">Array</span>)</span></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alength" title="Returns the length of the Java array. Works on arrays of all
  types.">alength</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the length of the Java array. Works on arrays of all
  types."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">a</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alength" title="Returns the length of the Java array. Works on arrays of all
  types.">alength</a></span><span class="whitespace"> </span>~<span class="symbol">a</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">array</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alength" title="Returns the length of the Java array. Works on arrays of all
  types.">alength</a></span><span class="whitespace"> </span><span class="symbol">array</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aclone" title="Returns a clone of the Java array. Works on arrays of known
  types.">aclone</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a clone of the Java array. Works on arrays of known
  types."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">a</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aclone" title="Returns a clone of the Java array. Works on arrays of known
  types.">aclone</a></span><span class="whitespace"> </span>~<span class="symbol">a</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">array</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aclone" title="Returns a clone of the Java array. Works on arrays of known
  types.">aclone</a></span><span class="whitespace"> </span><span class="symbol">array</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aget" title="Returns the value at the index/indices. Works on Java arrays of all
  types.">aget</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the value at the index/indices. Works on Java arrays of all
  types."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">i</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aget" title="Returns the value at the index/indices. Works on Java arrays of all
  types.">aget</a></span><span class="whitespace"> </span>~<span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span>~<span class="symbol">i</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">array</span><span class="whitespace"> </span><span class="symbol">idx</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">clojure.lang.Reflector/<span class="symbol">prepRet</span></span><span class="whitespace"> </span><span>(<span class="java-class">.getComponentType</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class" title="Returns the Class of x">class</a></span><span class="whitespace"> </span><span class="symbol">array</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">Array</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">array</span><span class="whitespace"> </span><span class="symbol">idx</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">array</span><span class="whitespace"> </span><span class="symbol">idx</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">idxs</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aget" title="Returns the value at the index/indices. Works on Java arrays of all
  types.">aget</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aget" title="Returns the value at the index/indices. Works on Java arrays of all
  types.">aget</a></span><span class="whitespace"> </span><span class="symbol">array</span><span class="whitespace"> </span><span class="symbol">idx</span>)</span><span class="whitespace"> </span><span class="symbol">idxs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aset" title="Sets the value at the index/indices. Works on Java arrays of
  reference types. Returns val.">aset</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Sets the value at the index/indices. Works on Java arrays of
  reference types. Returns val."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">i</span><span class="whitespace"> </span><span class="symbol">v</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aset" title="Sets the value at the index/indices. Works on Java arrays of
  reference types. Returns val.">aset</a></span><span class="whitespace"> </span>~<span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span>~<span class="symbol">i</span>)</span><span class="whitespace"> </span>~<span class="symbol">v</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">3</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">array</span><span class="whitespace"> </span><span class="symbol">idx</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">Array</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span class="symbol">array</span><span class="whitespace"> </span><span class="symbol">idx</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">array</span><span class="whitespace"> </span><span class="symbol">idx</span><span class="whitespace"> </span><span class="symbol">idx2</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">idxv</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aset" title="Sets the value at the index/indices. Works on Java arrays of
  reference types. Returns val.">aset</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aget" title="Returns the value at the index/indices. Works on Java arrays of all
  types.">aget</a></span><span class="whitespace"> </span><span class="symbol">array</span><span class="whitespace"> </span><span class="symbol">idx</span>)</span><span class="whitespace"> </span><span class="symbol">idx2</span><span class="whitespace"> </span><span class="symbol">idxv</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="symbol">def-aset</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">method</span><span class="whitespace"> </span><span class="symbol">coerce</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace">
</span><span class="whitespace">       </span><span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[~<span>'<span class="symbol">array</span></span><span class="whitespace"> </span>~<span>'<span class="symbol">idx</span></span><span class="whitespace"> </span>~<span>'<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span></span>]</span><span class="whitespace"> </span><span>[~<span>'<span class="symbol">array</span></span><span class="whitespace"> </span>~<span>'<span class="symbol">idx</span></span><span class="whitespace"> </span>~<span>'<span class="symbol">idx2</span></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span>~<span>'<span class="symbol">idxv</span></span>]</span>)</span></span>}</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">array#</span><span class="whitespace"> </span><span class="symbol">idx#</span><span class="whitespace"> </span><span class="symbol">val#</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">Array</span><span class="whitespace"> </span><span>(~<span class="symbol">method</span><span class="whitespace"> </span><span class="symbol">array#</span><span class="whitespace"> </span><span class="symbol">idx#</span><span class="whitespace"> </span><span>(~<span class="symbol">coerce</span><span class="whitespace"> </span><span class="symbol">val#</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">val#</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">array#</span><span class="whitespace"> </span><span class="symbol">idx#</span><span class="whitespace"> </span><span class="symbol">idx2#</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">idxv#</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aget" title="Returns the value at the index/indices. Works on Java arrays of all
  types.">aget</a></span><span class="whitespace"> </span><span class="symbol">array#</span><span class="whitespace"> </span><span class="symbol">idx#</span>)</span><span class="whitespace"> </span><span class="symbol">idx2#</span><span class="whitespace"> </span><span class="symbol">idxv#</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">def-aset</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Sets the value at the index/indices. Works on arrays of int. Returns val."</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aset-int" title="Sets the value at the index/indices. Works on arrays of int. Returns val.">aset-int</a></span><span class="whitespace"> </span><span class="symbol">setInt</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">def-aset</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Sets the value at the index/indices. Works on arrays of long. Returns val."</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aset-long" title="Sets the value at the index/indices. Works on arrays of long. Returns val.">aset-long</a></span><span class="whitespace"> </span><span class="symbol">setLong</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long" title="Coerce to long">long</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">def-aset</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Sets the value at the index/indices. Works on arrays of boolean. Returns val."</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aset-boolean" title="Sets the value at the index/indices. Works on arrays of boolean. Returns val.">aset-boolean</a></span><span class="whitespace"> </span><span class="symbol">setBoolean</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">def-aset</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Sets the value at the index/indices. Works on arrays of float. Returns val."</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aset-float" title="Sets the value at the index/indices. Works on arrays of float. Returns val.">aset-float</a></span><span class="whitespace"> </span><span class="symbol">setFloat</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/float" title="Coerce to float">float</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">def-aset</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Sets the value at the index/indices. Works on arrays of double. Returns val."</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aset-double" title="Sets the value at the index/indices. Works on arrays of double. Returns val.">aset-double</a></span><span class="whitespace"> </span><span class="symbol">setDouble</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/double" title="Coerce to double">double</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">def-aset</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Sets the value at the index/indices. Works on arrays of short. Returns val."</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aset-short" title="Sets the value at the index/indices. Works on arrays of short. Returns val.">aset-short</a></span><span class="whitespace"> </span><span class="symbol">setShort</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/short" title="Coerce to short">short</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">def-aset</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Sets the value at the index/indices. Works on arrays of byte. Returns val."</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aset-byte" title="Sets the value at the index/indices. Works on arrays of byte. Returns val.">aset-byte</a></span><span class="whitespace"> </span><span class="symbol">setByte</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/byte" title="Coerce to byte">byte</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">def-aset</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Sets the value at the index/indices. Works on arrays of char. Returns val."</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aset-char" title="Sets the value at the index/indices. Works on arrays of char. Returns val.">aset-char</a></span><span class="whitespace"> </span><span class="symbol">setChar</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/char" title="Coerce to char">char</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/make-array" title="Creates and returns an array of instances of the specified class of
  the specified dimension(s).  Note that a class object is required.
  Class objects can be obtained by using their imported or
  fully-qualified name.  Class objects for the primitive types can be
  obtained using, e.g., Integer/TYPE.">make-array</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates and returns an array of instances of the specified class of
  the specified dimension(s).  Note that a class object is required.
  Class objects can be obtained by using their imported or
  fully-qualified name.  Class objects for the primitive types can be
  obtained using, e.g., Integer/TYPE."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">Class</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/type" title="Returns the :type metadata of x, or its Class if none">type</a></span><span class="whitespace"> </span><span class="symbol">len</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">Array</span><span class="whitespace"> </span><span>(<span class="symbol">newInstance</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/type" title="Returns the :type metadata of x, or its Class if none">type</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span class="symbol">len</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">Class</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/type" title="Returns the :type metadata of x, or its Class if none">type</a></span><span class="whitespace"> </span><span class="symbol">dim</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more-dims</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">dims</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">dim</span><span class="whitespace"> </span><span class="symbol">more-dims</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>^<span class="string">"[I"</span></span><span class="whitespace"> </span><span class="symbol">dimarray</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/make-array" title="Creates and returns an array of instances of the specified class of
  the specified dimension(s).  Note that a class object is required.
  Class objects can be obtained by using their imported or
  fully-qualified name.  Class objects for the primitive types can be
  obtained using, e.g., Integer/TYPE.">make-array</a></span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">Integer</span><span class="whitespace"> </span><span class="symbol">TYPE</span>)</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">dims</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/dotimes" title="bindings =&gt; name n

  Repeatedly executes body (presumably for side-effects) with name
  bound to integers from 0 through n-1.">dotimes</a></span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alength" title="Returns the length of the Java array. Works on arrays of all
  types.">alength</a></span><span class="whitespace"> </span><span class="symbol">dimarray</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aset-int" title="Sets the value at the index/indices. Works on arrays of int. Returns val.">aset-int</a></span><span class="whitespace"> </span><span class="symbol">dimarray</span><span class="whitespace"> </span><span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nth" title="Returns the value at the index. get returns nil if index out of
  bounds, nth throws an exception unless not-found is supplied.  nth
  also works for strings, Java arrays, regex Matchers and Lists, and,
  in O(n) time, for sequences.">nth</a></span><span class="whitespace"> </span><span class="symbol">dims</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">Array</span><span class="whitespace"> </span><span>(<span class="symbol">newInstance</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/type" title="Returns the :type metadata of x, or its Class if none">type</a></span><span class="whitespace"> </span><span class="symbol">dimarray</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/to-array-2d" title="Returns a (potentially-ragged) 2-dimensional array of Objects
  containing the contents of coll, which can be any Collection of any
  Collection.">to-array-2d</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a (potentially-ragged) 2-dimensional array of Objects
  containing the contents of coll, which can be any Collection of any
  Collection."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="string">"[[Ljava.lang.Object;"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">java.util.Collection</span></span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/make-array" title="Creates and returns an array of instances of the specified class of
  the specified dimension(s).  Note that a class object is required.
  Class objects can be obtained by using their imported or
  fully-qualified name.  Class objects for the primitive types can be
  obtained using, e.g., Integer/TYPE.">make-array</a></span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">Class</span><span class="whitespace"> </span><span>(<span class="symbol">forName</span><span class="whitespace"> </span><span class="string">"[Ljava.lang.Object;"</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span>(<span class="symbol">size</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span class="symbol">xs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">xs</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aset" title="Sets the value at the index/indices. Works on Java arrays of
  reference types. Returns val.">aset</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/to-array" title="Returns an array of Objects containing the contents of coll, which
  can be any Collection.  Maps to java.util.Collection.toArray().">to-array</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">xs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">i</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">xs</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="symbol">ret</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/macroexpand-1" title="If form represents a macro form, returns its expansion,
  else returns form.">macroexpand-1</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"If form represents a macro form, returns its expansion,
  else returns form."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">form</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Compiler</span><span class="whitespace"> </span><span>(<span class="symbol">macroexpand1</span><span class="whitespace"> </span><span class="symbol">form</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/macroexpand" title="Repeatedly calls macroexpand-1 on form until it no longer
  represents a macro form, then returns it.  Note neither
  macroexpand-1 nor macroexpand expand macros in subforms.">macroexpand</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Repeatedly calls macroexpand-1 on form until it no longer
  represents a macro form, then returns it.  Note neither
  macroexpand-1 nor macroexpand expand macros in subforms."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">form</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ex</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/macroexpand-1" title="If form represents a macro form, returns its expansion,
  else returns form.">macroexpand-1</a></span><span class="whitespace"> </span><span class="symbol">form</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identical?" title="Tests if 2 arguments are the same object">identical?</a></span><span class="whitespace"> </span><span class="symbol">ex</span><span class="whitespace"> </span><span class="symbol">form</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">form</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/macroexpand" title="Repeatedly calls macroexpand-1 on form until it no longer
  represents a macro form, then returns it.  Note neither
  macroexpand-1 nor macroexpand expand macros in subforms.">macroexpand</a></span><span class="whitespace"> </span><span class="symbol">ex</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/create-struct" title="Returns a structure basis object.">create-struct</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a structure basis object."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.PersistentStructMap</span><span class="whitespace"> </span><span>(<span class="symbol">createSlotMap</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defstruct" title="Same as (def name (create-struct keys...))">defstruct</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Same as (def name (create-struct keys...))"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="macro">def</span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/create-struct" title="Returns a structure basis object.">create-struct</a></span><span class="whitespace"> </span>~<span class="unknown">@keys</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/struct-map" title="Returns a new structmap instance with the keys of the
  structure-basis. keyvals may contain all, some or none of the basis
  keys - where values are not supplied they will default to nil.
  keyvals can also contain keys not in the basis.">struct-map</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a new structmap instance with the keys of the
  structure-basis. keyvals may contain all, some or none of the basis
  keys - where values are not supplied they will default to nil.
  keyvals can also contain keys not in the basis."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">inits</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.PersistentStructMap</span><span class="whitespace"> </span><span>(<span class="symbol">create</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">inits</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/struct" title="Returns a new structmap instance with the keys of the
  structure-basis. vals must be supplied for basis keys in order -
  where values are not supplied they will default to nil.">struct</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a new structmap instance with the keys of the
  structure-basis. vals must be supplied for basis keys in order -
  where values are not supplied they will default to nil."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vals" title="Returns a sequence of the map&apos;s values, in the same order as (seq map).">vals</a></span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.PersistentStructMap</span><span class="whitespace"> </span><span>(<span class="symbol">construct</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vals" title="Returns a sequence of the map&apos;s values, in the same order as (seq map).">vals</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/accessor" title="Returns a fn that, given an instance of a structmap with the basis,
  returns the value at the key.  The key must be in the basis. The
  returned function should be (slightly) more efficient than using
  get, but such use of accessors should be limited to known
  performance-critical areas.">accessor</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a fn that, given an instance of a structmap with the basis,
  returns the value at the key.  The key must be in the basis. The
  returned function should be (slightly) more efficient than using
  get, but such use of accessors should be limited to known
  performance-critical areas."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.PersistentStructMap</span><span class="whitespace"> </span><span>(<span class="symbol">getAccessor</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load-reader" title="Sequentially read and evaluate the set of forms contained in the
  stream/file">load-reader</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Sequentially read and evaluate the set of forms contained in the
  stream/file"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">rdr</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Compiler</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span><span class="whitespace"> </span><span class="symbol">rdr</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load-string" title="Sequentially read and evaluate the set of forms contained in the
  string">load-string</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Sequentially read and evaluate the set of forms contained in the
  string"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">rdr</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span>(<span class="symbol">java.io.StringReader.</span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="symbol">clojure.lang.LineNumberingPushbackReader.</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load-reader" title="Sequentially read and evaluate the set of forms contained in the
  stream/file">load-reader</a></span><span class="whitespace"> </span><span class="symbol">rdr</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set?" title="Returns true if x implements IPersistentSet">set?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x implements IPersistentSet"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IPersistentSet</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a set of the distinct elements of coll."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set?" title="Returns true if x implements IPersistentSet">set?</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IReduceInit</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/persistent!" title="Returns a new, persistent version of the transient collection, in
  constant time. The transient collection cannot be used after this
  call, any such use will throw an exception.">persistent!</a></span><span class="whitespace"> </span><span>(<span class="java-class">.reduce</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.IReduceInit</span></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transient" title="Returns a new, transient version of the collection, in constant time.">transient</a></span><span class="whitespace"> </span><span>#{}</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/persistent!" title="Returns a new, persistent version of the transient collection, in
  constant time. The transient collection cannot be used after this
  call, any such use will throw an exception.">persistent!</a></span><span class="whitespace"> </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transient" title="Returns a new, transient version of the collection, in constant time.">transient</a></span><span class="whitespace"> </span><span>#{}</span>)</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="symbol">filter-key</span><span class="whitespace"> </span><span>[<span class="symbol">keyfn</span><span class="whitespace"> </span><span class="symbol">pred</span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/amap" title="Maps an expression across an array a, using an index named idx, and
  return value named ret, initialized to a clone of a, then setting 
  each element of ret to the evaluation of expr, returning the new 
  array ret.">amap</a></span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>{}</span><span class="whitespace"> </span><span class="symbol">es</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/amap" title="Maps an expression across an array a, using an index named idx, and
  return value named ret, initialized to a clone of a, then setting 
  each element of ret to the evaluation of expr, returning the new 
  array ret.">amap</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">es</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="symbol">pred</span><span class="whitespace"> </span><span>(<span class="symbol">keyfn</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">es</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">es</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">es</span>)</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">es</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">es</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">ret</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find-ns" title="Returns the namespace named by the symbol or nil if it doesn&apos;t exist.">find-ns</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the namespace named by the symbol or nil if it doesn't exist."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">sym</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Namespace/<span class="symbol">find</span></span><span class="whitespace"> </span><span class="symbol">sym</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/create-ns" title="Create a new namespace named by the symbol if one doesn&apos;t already
  exist, returns it or the already-existing namespace of the same
  name.">create-ns</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Create a new namespace named by the symbol if one doesn't already
  exist, returns it or the already-existing namespace of the same
  name."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">sym</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Namespace/<span class="symbol">findOrCreate</span></span><span class="whitespace"> </span><span class="symbol">sym</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/remove-ns" title="Removes the namespace named by the symbol. Use with caution.
  Cannot be used to remove the clojure namespace.">remove-ns</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Removes the namespace named by the symbol. Use with caution.
  Cannot be used to remove the clojure namespace."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">sym</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Namespace/<span class="symbol">remove</span></span><span class="whitespace"> </span><span class="symbol">sym</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/all-ns" title="Returns a sequence of all namespaces.">all-ns</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a sequence of all namespaces."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Namespace/<span class="symbol">all</span></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/the-ns" title="If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.">the-ns</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span class="java-class">clojure.lang.Namespace</span></span><span class="whitespace"> </span><span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Namespace</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="symbol">x</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find-ns" title="Returns the namespace named by the symbol or nil if it doesn&apos;t exist.">find-ns</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">Exception.</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"No namespace: "</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="string">" found"</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-name" title="Returns the name of the namespace, a symbol.">ns-name</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the name of the namespace, a symbol."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.getName</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/the-ns" title="If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.">the-ns</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-map" title="Returns a map of all the mappings for the namespace.">ns-map</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a map of all the mappings for the namespace."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.getMappings</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/the-ns" title="If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.">the-ns</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-unmap" title="Removes the mappings for the symbol from the namespace.">ns-unmap</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Removes the mappings for the symbol from the namespace."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span class="symbol">sym</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.unmap</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/the-ns" title="If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.">the-ns</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span><span class="whitespace"> </span><span class="symbol">sym</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;(defn export [syms]</span><span class="whitespace">
</span><span class="comment">;  (doseq [sym syms]</span><span class="whitespace">
</span><span class="comment">;   (.. *ns* (intern sym) (setExported true))))</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-publics" title="Returns a map of the public intern mappings for the namespace.">ns-publics</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a map of the public intern mappings for the namespace."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/the-ns" title="If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.">the-ns</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">filter-key</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.Var</span></span><span class="whitespace"> </span><span class="symbol">v</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Var</span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace">
</span><span class="whitespace">                                 </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span>(<span class="java-class">.ns</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                 </span><span>(<span class="java-class">.isPublic</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-map" title="Returns a map of all the mappings for the namespace.">ns-map</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-imports" title="Returns a map of the import mappings for the namespace.">ns-imports</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a map of the import mappings for the namespace."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">filter-key</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partial" title="Takes a function f and fewer than the normal arguments to f, and
  returns a fn that takes a variable number of additional args. When
  called, the returned function calls f with args + additional args.">partial</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Class</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-map" title="Returns a map of all the mappings for the namespace.">ns-map</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-interns" title="Returns a map of the intern mappings for the namespace.">ns-interns</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a map of the intern mappings for the namespace."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/the-ns" title="If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.">the-ns</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">filter-key</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.Var</span></span><span class="whitespace"> </span><span class="symbol">v</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Var</span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace">
</span><span class="whitespace">                                 </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span>(<span class="java-class">.ns</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-map" title="Returns a map of all the mappings for the namespace.">ns-map</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/refer" title="refers to all public vars of ns, subject to filters.
  filters can include at most one each of:

  :exclude list-of-symbols
  :only list-of-symbols
  :rename map-of-fromsymbol-tosymbol

  For each public interned var in the namespace named by the symbol,
  adds a mapping from the name of the var to the var to the current
  namespace.  Throws an exception if name is already mapped to
  something else in the current namespace. Filters can be used to
  select a subset, via inclusion or exclusion, or to provide a mapping
  to a symbol different from the var&apos;s name, in order to prevent
  clashes. Use :use in the ns macro in preference to calling this directly.">refer</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"refers to all public vars of ns, subject to filters.
  filters can include at most one each of:

  :exclude list-of-symbols
  :only list-of-symbols
  :rename map-of-fromsymbol-tosymbol

  For each public interned var in the namespace named by the symbol,
  adds a mapping from the name of the var to the var to the current
  namespace.  Throws an exception if name is already mapped to
  something else in the current namespace. Filters can be used to
  select a subset, via inclusion or exclusion, or to provide a mapping
  to a symbol different from the var's name, in order to prevent
  clashes. Use :use in the ns macro in preference to calling this directly."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">ns-sym</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">filters</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find-ns" title="Returns the namespace named by the symbol or nil if it doesn&apos;t exist.">find-ns</a></span><span class="whitespace"> </span><span class="symbol">ns-sym</span>)</span><span class="whitespace"> </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">Exception</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"No namespace: "</span><span class="whitespace"> </span><span class="symbol">ns-sym</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">fs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash-map" title="keyval =&gt; key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.">hash-map</a></span><span class="whitespace"> </span><span class="symbol">filters</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">nspublics</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-publics" title="Returns a map of the public intern mappings for the namespace.">ns-publics</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">rename</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="keyword">:rename</span><span class="whitespace"> </span><span class="symbol">fs</span>)</span><span class="whitespace"> </span><span>{}</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">exclude</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span>(<span class="keyword">:exclude</span><span class="whitespace"> </span><span class="symbol">fs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">to-do</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="keyword">:all</span><span class="whitespace"> </span><span>(<span class="keyword">:refer</span><span class="whitespace"> </span><span class="symbol">fs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span><span class="whitespace"> </span><span class="symbol">nspublics</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="keyword">:refer</span><span class="whitespace"> </span><span class="symbol">fs</span>)</span><span class="whitespace"> </span><span>(<span class="keyword">:only</span><span class="whitespace"> </span><span class="symbol">fs</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span><span class="whitespace"> </span><span class="symbol">nspublics</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span class="symbol">to-do</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Sequential</span><span class="whitespace"> </span><span class="symbol">to-do</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">Exception</span><span class="whitespace"> </span><span class="string">":only/:refer value must be a sequential collection of symbols"</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/doseq" title="Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by &quot;for&quot;.  Does not retain
  the head of the sequence. Returns nil.">doseq</a></span><span class="whitespace"> </span><span>[<span class="symbol">sym</span><span class="whitespace"> </span><span class="symbol">to-do</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace"> </span><span>(<span class="symbol">exclude</span><span class="whitespace"> </span><span class="symbol">sym</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="symbol">nspublics</span><span class="whitespace"> </span><span class="symbol">sym</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">java.lang.IllegalAccessError</span><span class="whitespace">
</span><span class="whitespace">                          </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-interns" title="Returns a map of the intern mappings for the namespace.">ns-interns</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span><span class="whitespace"> </span><span class="symbol">sym</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="symbol">sym</span><span class="whitespace"> </span><span class="string">" is not public"</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="symbol">sym</span><span class="whitespace"> </span><span class="string">" does not exist"</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*ns*" title="A clojure.lang.Namespace object representing the current namespace.">*ns*</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/refer" title="refers to all public vars of ns, subject to filters.
  filters can include at most one each of:

  :exclude list-of-symbols
  :only list-of-symbols
  :rename map-of-fromsymbol-tosymbol

  For each public interned var in the namespace named by the symbol,
  adds a mapping from the name of the var to the var to the current
  namespace.  Throws an exception if name is already mapped to
  something else in the current namespace. Filters can be used to
  select a subset, via inclusion or exclusion, or to provide a mapping
  to a symbol different from the var&apos;s name, in order to prevent
  clashes. Use :use in the ns macro in preference to calling this directly.">refer</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">rename</span><span class="whitespace"> </span><span class="symbol">sym</span>)</span><span class="whitespace"> </span><span class="symbol">sym</span>)</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-refers" title="Returns a map of the refer mappings for the namespace.">ns-refers</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a map of the refer mappings for the namespace."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/the-ns" title="If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.">the-ns</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">filter-key</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.lang.Var</span></span><span class="whitespace"> </span><span class="symbol">v</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Var</span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace">
</span><span class="whitespace">                                 </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not=" title="Same as (not (= obj1 obj2))">not=</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span>(<span class="java-class">.ns</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-map" title="Returns a map of all the mappings for the namespace.">ns-map</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alias" title="Add an alias in the current namespace to another
  namespace. Arguments are two symbols: the alias to be used, and
  the symbolic name of the target namespace. Use :as in the ns macro in preference
  to calling this directly.">alias</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Add an alias in the current namespace to another
  namespace. Arguments are two symbols: the alias to be used, and
  the symbolic name of the target namespace. Use :as in the ns macro in preference
  to calling this directly."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alias" title="Add an alias in the current namespace to another
  namespace. Arguments are two symbols: the alias to be used, and
  the symbolic name of the target namespace. Use :as in the ns macro in preference
  to calling this directly.">alias</a></span><span class="whitespace"> </span><span class="symbol">namespace-sym</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.addAlias</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*ns*" title="A clojure.lang.Namespace object representing the current namespace.">*ns*</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alias" title="Add an alias in the current namespace to another
  namespace. Arguments are two symbols: the alias to be used, and
  the symbolic name of the target namespace. Use :as in the ns macro in preference
  to calling this directly.">alias</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/the-ns" title="If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.">the-ns</a></span><span class="whitespace"> </span><span class="symbol">namespace-sym</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-aliases" title="Returns a map of the aliases for the namespace.">ns-aliases</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a map of the aliases for the namespace."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.getAliases</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/the-ns" title="If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.">the-ns</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-unalias" title="Removes the alias for the symbol from the namespace.">ns-unalias</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Removes the alias for the symbol from the namespace."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span class="symbol">sym</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.removeAlias</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/the-ns" title="If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.">the-ns</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span><span class="whitespace"> </span><span class="symbol">sym</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-nth" title="Returns a lazy seq of every nth item in coll.  Returns a stateful
  transducer when no collection is provided.">take-nth</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy seq of every nth item in coll.  Returns a stateful
  transducer when no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">iv</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/volatile!" title="Creates and returns a Volatile with an initial value of val.">volatile!</a></span><span class="whitespace"> </span><span class="unknown">-1</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/vswap!" title="Non-atomically swaps the value of the volatile as if:
   (apply f current-value-of-vol args). Returns the value that
   was swapped in.">vswap!</a></span><span class="whitespace"> </span><span class="symbol">iv</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/zero?" title="Returns true if num is zero, else false">zero?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rem" title="remainder of dividing numerator by denominator.">rem</a></span><span class="whitespace"> </span><span class="symbol">i</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="symbol">result</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-nth" title="Returns a lazy seq of every nth item in coll.  Returns a stateful
  transducer when no collection is provided.">take-nth</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop" title="Returns a lazy sequence of all but the first n items in coll.
  Returns a stateful transducer when no collection is provided.">drop</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interleave" title="Returns a lazy seq of the first item in each coll, then the second etc.">interleave</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy seq of the first item in each coll, then the second etc."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span>()</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">c1</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace"> </span><span class="symbol">c1</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">c1</span><span class="whitespace"> </span><span class="symbol">c2</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">s1</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">c1</span>)</span><span class="whitespace"> </span><span class="symbol">s2</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">c2</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span class="symbol">s1</span><span class="whitespace"> </span><span class="symbol">s2</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s1</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s2</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                                 </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interleave" title="Returns a lazy seq of the first item in each coll, then the second etc.">interleave</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s1</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s2</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">c1</span><span class="whitespace"> </span><span class="symbol">c2</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">colls</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ss</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">colls</span><span class="whitespace"> </span><span class="symbol">c2</span><span class="whitespace"> </span><span class="symbol">c1</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identity" title="Returns its argument.">identity</a></span><span class="whitespace"> </span><span class="symbol">ss</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/concat" title="Returns a lazy seq representing the concatenation of the elements in the supplied colls.">concat</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ss</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interleave" title="Returns a lazy seq of the first item in each coll, then the second etc.">interleave</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">ss</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/var-get" title="Gets the value in the var object">var-get</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Gets the value in the var object"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Var</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/var-set" title="Sets the value in the var object to val. The var must be
 thread-locally bound.">var-set</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Sets the value in the var object to val. The var must be
 thread-locally bound."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Var</span></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-local-vars" title="varbinding=&gt; symbol init-expr

  Executes the exprs in a context in which the symbols are bound to
  vars with per-thread bindings to the init-exprs.  The symbols refer
  to the var objects themselves, and must be accessed with var-get and
  var-set">with-local-vars</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"varbinding=> symbol init-expr

  Executes the exprs in a context in which the symbols are bound to
  vars with per-thread bindings to the init-exprs.  The symbols refer
  to the var objects themselves, and must be accessed with var-get and
  var-set"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">name-vals-vec</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">assert-args</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">name-vals-vec</span>)</span><span class="whitespace"> </span><span class="string">"a vector for its binding"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/even?" title="Returns true if n is even, throws an exception if n is not an integer">even?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">name-vals-vec</span>)</span>)</span><span class="whitespace"> </span><span class="string">"an even number of forms in binding vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interleave" title="Returns a lazy seq of the first item in each coll, then the second etc.">interleave</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-nth" title="Returns a lazy seq of every nth item in coll.  Returns a stateful
  transducer when no collection is provided.">take-nth</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span class="symbol">name-vals-vec</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/repeat" title="Returns a lazy (infinite!, or length n if supplied) sequence of xs.">repeat</a></span><span class="whitespace"> </span><span>'<span>(<span class="java-class">..</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Var</span><span class="whitespace"> </span><span class="symbol">create</span><span class="whitespace"> </span><span class="symbol">setDynamic</span>)</span></span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Var</span><span class="whitespace"> </span><span>(<span class="symbol">pushThreadBindings</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash-map" title="keyval =&gt; key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.">hash-map</a></span><span class="whitespace"> </span>~<span class="unknown">@name-vals-vec</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">try</span><span class="whitespace">
</span><span class="whitespace">      </span>~<span class="unknown">@body</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">finally</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Var</span><span class="whitespace"> </span><span>(<span class="symbol">popThreadBindings</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-resolve" title="Returns the var or Class to which a symbol will be resolved in the
  namespace (unless found in the environment), else nil.  Note that
  if the symbol is fully qualified, the var/Class to which it resolves
  need not be present in the namespace.">ns-resolve</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the var or Class to which a symbol will be resolved in the
  namespace (unless found in the environment), else nil.  Note that
  if the symbol is fully qualified, the var/Class to which it resolves
  need not be present in the namespace."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span class="symbol">sym</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-resolve" title="Returns the var or Class to which a symbol will be resolved in the
  namespace (unless found in the environment), else nil.  Note that
  if the symbol is fully qualified, the var/Class to which it resolves
  need not be present in the namespace.">ns-resolve</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace"> </span><span class="symbol">sym</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span class="symbol">env</span><span class="whitespace"> </span><span class="symbol">sym</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span class="symbol">env</span><span class="whitespace"> </span><span class="symbol">sym</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="java-class">clojure.lang.Compiler/<span class="symbol">maybeResolveIn</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/the-ns" title="If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.">the-ns</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span><span class="whitespace"> </span><span class="symbol">sym</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/resolve" title="same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &amp;env symbol)">resolve</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &env symbol)"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">sym</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-resolve" title="Returns the var or Class to which a symbol will be resolved in the
  namespace (unless found in the environment), else nil.  Note that
  if the symbol is fully qualified, the var/Class to which it resolves
  need not be present in the namespace.">ns-resolve</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*ns*" title="A clojure.lang.Namespace object representing the current namespace.">*ns*</a></span><span class="whitespace"> </span><span class="symbol">sym</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">env</span><span class="whitespace"> </span><span class="symbol">sym</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-resolve" title="Returns the var or Class to which a symbol will be resolved in the
  namespace (unless found in the environment), else nil.  Note that
  if the symbol is fully qualified, the var/Class to which it resolves
  need not be present in the namespace.">ns-resolve</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*ns*" title="A clojure.lang.Namespace object representing the current namespace.">*ns*</a></span><span class="whitespace"> </span><span class="symbol">env</span><span class="whitespace"> </span><span class="symbol">sym</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/array-map" title="Constructs an array-map. If any keys are equal, they are handled as
  if by repeated uses of assoc.">array-map</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Constructs an array-map. If any keys are equal, they are handled as
  if by repeated uses of assoc."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.PersistentArrayMap</span><span class="whitespace"> </span><span class="symbol">EMPTY</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">keyvals</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">clojure.lang.PersistentArrayMap/<span class="symbol">createAsIfByAssoc</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/to-array" title="Returns an array of Objects containing the contents of coll, which
  can be any Collection.  Maps to java.util.Collection.toArray().">to-array</a></span><span class="whitespace"> </span><span class="symbol">keyvals</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;redefine let and loop  with destructuring</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/destructure">destructure</a></span><span class="whitespace"> </span><span>[<span class="symbol">bindings</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">bents</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition" title="Returns a lazy sequence of lists of n items each, at offsets step
  apart. If step is not supplied, defaults to n, i.e. the partitions
  do not overlap. If a pad collection is supplied, use its elements as
  necessary to complete last partition upto n items. In case there are
  not enough padding elements, return a partition with less than n items.">partition</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">pb</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">pb</span><span class="whitespace"> </span><span>[<span class="symbol">bvec</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">v</span>]</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">pvec</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">bvec</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>]</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">gvec</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"vec__"</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span class="symbol">bvec</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">gvec</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span class="symbol">n</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace">
</span><span class="whitespace">                                </span><span class="symbol">bs</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace">
</span><span class="whitespace">                                </span><span class="symbol">seen-rest?</span><span class="whitespace"> </span><span class="unknown">false</span>]</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">bs</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">firstb</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">bs</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                               </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">firstb</span><span class="whitespace"> </span><span>'<span class="symbol">&</span></span>)</span><span class="whitespace"> </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="symbol">pb</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">bs</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span>`<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nthnext" title="Returns the nth next of coll, (seq coll) when n is 0.">nthnext</a></span><span class="whitespace"> </span><span class="symbol">gvec</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                                     </span><span class="symbol">n</span><span class="whitespace">
</span><span class="whitespace">                                                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nnext" title="Same as (next (next x))">nnext</a></span><span class="whitespace"> </span><span class="symbol">bs</span>)</span><span class="whitespace">
</span><span class="whitespace">                                                     </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">firstb</span><span class="whitespace"> </span><span class="keyword">:as</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">pb</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">bs</span>)</span><span class="whitespace"> </span><span class="symbol">gvec</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span class="keyword">:else</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">seen-rest?</span><span class="whitespace">
</span><span class="whitespace">                                        </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">Exception</span><span class="whitespace"> </span><span class="string">"Unsupported binding form, only :as can follow & parameter"</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                        </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="symbol">pb</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">firstb</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span>`<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nth" title="Returns the value at the index. get returns nil if index out of
  bounds, nth throws an exception unless not-found is supplied.  nth
  also works for strings, Java arrays, regex Matchers and Lists, and,
  in O(n) time, for sequences.">nth</a></span><span class="whitespace"> </span><span class="symbol">gvec</span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                               </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace">
</span><span class="whitespace">                                               </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">bs</span>)</span><span class="whitespace">
</span><span class="whitespace">                                               </span><span class="symbol">seen-rest?</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                     </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pmap" title="Like map, except f is applied in parallel. Semi-lazy in that the
  parallel computation stays ahead of the consumption, but doesn&apos;t
  realize the entire result unless required. Only useful for
  computationally intensive functions where the time of f dominates
  the coordination overhead.">pmap</a></span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">bvec</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">v</span>]</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">gmap</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"map__"</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span class="symbol">gmapseq</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span class="symbol">gmap</span><span class="whitespace"> </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span>'<span class="java-class">clojure.lang.ISeq</span></span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span class="symbol">defaults</span><span class="whitespace"> </span><span>(<span class="keyword">:or</span><span class="whitespace"> </span><span class="symbol">b</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span class="symbol">bvec</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">gmap</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace">
</span><span class="whitespace">                                        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">gmap</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span>`<span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span>~<span class="symbol">gmap</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.PersistentHashMap/<span class="symbol">create</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span>~<span class="symbol">gmapseq</span>)</span>)</span><span class="whitespace"> </span>~<span class="symbol">gmap</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                        </span><span>(<span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span>]</span><span class="whitespace">
</span><span class="whitespace">                                           </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace">
</span><span class="whitespace">                                             </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span class="symbol">gmap</span>)</span><span class="whitespace">
</span><span class="whitespace">                                             </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span class="symbol">bes</span><span class="whitespace"> </span><span>(<span class="symbol">reduce1</span><span class="whitespace">
</span><span class="whitespace">                                     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">bes</span><span class="whitespace"> </span><span class="symbol">entry</span>]</span><span class="whitespace">
</span><span class="whitespace">                                       </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">%1</span><span class="whitespace"> </span><span class="symbol">%2</span><span class="whitespace"> </span><span>(<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">entry</span>)</span><span class="whitespace"> </span><span class="symbol">%2</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                               </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dissoc" title="dissoc[iate]. Returns a new map of the same (hashed/sorted) type,
  that does not contain a mapping for key(s).">dissoc</a></span><span class="whitespace"> </span><span class="symbol">bes</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="symbol">entry</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                               </span><span>(<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="symbol">entry</span>)</span><span class="whitespace"> </span><span class="symbol">bes</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dissoc" title="dissoc[iate]. Returns a new map of the same (hashed/sorted) type,
  that does not contain a mapping for key(s).">dissoc</a></span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="keyword">:or</span>)</span><span class="whitespace">
</span><span class="whitespace">                                     </span><span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>#(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">%</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword" title="Returns a Keyword with the given namespace and name.  Do not use :
  in the keyword strings, it will be added automatically.">keyword</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span>)</span><span class="whitespace">,</span><span class="whitespace">
</span><span class="whitespace">                                      </span><span class="keyword">:strs</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace">, </span><span class="keyword">:syms</span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span>`<span class="macro">quote</span><span class="whitespace"> </span><span class="symbol">%</span>)</span>}</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">bes</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">bb</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">bes</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                   </span><span class="symbol">bk</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">bes</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                   </span><span class="symbol">bv</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span class="symbol">defaults</span><span class="whitespace"> </span><span class="symbol">bb</span>)</span><span class="whitespace">
</span><span class="whitespace">                                        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span>`<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">gmap</span><span class="whitespace"> </span><span class="symbol">bk</span><span class="whitespace"> </span><span>(<span class="symbol">defaults</span><span class="whitespace"> </span><span class="symbol">bb</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span>`<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">gmap</span><span class="whitespace"> </span><span class="symbol">bk</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                               </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">                                        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="symbol">bb</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/namespace" title="Returns the namespace String of a symbol or keyword, or nil if not present.">namespace</a></span><span class="whitespace"> </span><span class="symbol">bb</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol" title="Returns a Symbol with the given namespace and name.">symbol</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">bb</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">bb</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">bv</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace"> </span><span class="symbol">bb</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol" title="Returns a Symbol with the given namespace and name.">symbol</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">bb</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">bv</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                        </span><span class="keyword">:else</span><span class="whitespace"> </span><span>(<span class="symbol">pb</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">bb</span><span class="whitespace"> </span><span class="symbol">bv</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">bes</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span class="symbol">bvec</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">pvec</span><span class="whitespace"> </span><span class="symbol">bvec</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pmap" title="Like map, except f is applied in parallel. Semi-lazy in that the
  parallel computation stays ahead of the consumption, but doesn&apos;t
  realize the entire result unless required. Only useful for
  computationally intensive functions where the time of f dominates
  the coordination overhead.">pmap</a></span><span class="whitespace"> </span><span class="symbol">bvec</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="keyword">:else</span><span class="whitespace"> </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">Exception</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Unsupported binding form: "</span><span class="whitespace"> </span><span class="symbol">b</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">process-entry</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">bvec</span><span class="whitespace"> </span><span class="symbol">b</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">pb</span><span class="whitespace"> </span><span class="symbol">bvec</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">bents</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="symbol">bindings</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="symbol">process-entry</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="symbol">bents</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="macro">let</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"binding => binding-form init-expr

  Evaluates the exprs in a lexical context in which the symbols in
  the binding-forms are bound to their respective init-exprs or parts
  therein."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">, </span><span class="keyword">:special-form</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">, </span><span class="keyword">:forms</span><span class="whitespace"> </span><span>'<span>[<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">bindings*</span>]</span><span class="whitespace"> </span><span class="symbol">exprs*</span>)</span>]</span></span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">assert-args</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace"> </span><span class="string">"a vector for its binding"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/even?" title="Returns true if n is even, throws an exception if n is not an integer">even?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span><span class="whitespace"> </span><span class="string">"an even number of forms in binding vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="symbol">let*</span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/destructure">destructure</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace"> </span>~<span class="unknown">@body</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="symbol">maybe-destructured</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">params</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="symbol">params</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">params</span><span class="whitespace"> </span><span class="symbol">body</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">params</span><span class="whitespace"> </span><span class="symbol">params</span><span class="whitespace">
</span><span class="whitespace">           </span><span class="symbol">new-params</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">params</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span class="symbol">lets</span><span class="whitespace"> </span><span>[]</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">params</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">params</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">params</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">new-params</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">params</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">lets</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">gparam</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"p__"</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">params</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">new-params</span><span class="whitespace"> </span><span class="symbol">gparam</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span class="symbol">lets</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">params</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">gparam</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span>`<span>(~<span class="symbol">new-params</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">let</span><span class="whitespace"> </span>~<span class="symbol">lets</span><span class="whitespace">
</span><span class="whitespace">            </span>~<span class="unknown">@body</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;redefine fn with destructuring and pre/post conditions</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"params => positional-params* , or positional-params* & next-param
  positional-param => binding-form
  next-param => binding-form
  name => symbol

  Defines a function"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">, </span><span class="keyword">:special-form</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">,</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:forms</span><span class="whitespace"> </span><span>'<span>[<span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">name?</span><span class="whitespace"> </span><span>[<span class="symbol">params*</span><span class="whitespace"> </span>]</span><span class="whitespace"> </span><span class="symbol">exprs*</span>)</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">name?</span><span class="whitespace"> </span><span>(<span>[<span class="symbol">params*</span><span class="whitespace"> </span>]</span><span class="whitespace"> </span><span class="symbol">exprs*</span>)</span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span>)</span>]</span></span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">sigs</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">sigs</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">sigs</span>)</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">sigs</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">sigs</span>)</span><span class="whitespace"> </span><span class="symbol">sigs</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">sigs</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">sigs</span>)</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span class="symbol">sigs</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">sigs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">sigs</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="comment">;; Assume single arity syntax</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">sigs</span>)</span><span class="whitespace">
</span><span class="whitespace">                              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Parameter declaration "</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                                   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">sigs</span>)</span><span class="whitespace">
</span><span class="whitespace">                                   </span><span class="string">" should be a vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">                              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Parameter declaration missing"</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">psig</span><span class="whitespace"> </span><span>(<span class="symbol">fn*</span><span class="whitespace"> </span><span>[<span class="symbol">sig</span>]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span class="comment">;; Ensure correct type before destructuring sig</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span class="symbol">sig</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Invalid signature "</span><span class="whitespace"> </span><span class="symbol">sig</span><span class="whitespace">
</span><span class="whitespace">                                 </span><span class="string">" should be a list"</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">params</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace"> </span><span class="symbol">sig</span><span class="whitespace">
</span><span class="whitespace">                       </span><span class="symbol">_</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">params</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                                    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">sigs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Parameter declaration "</span><span class="whitespace"> </span><span class="symbol">params</span><span class="whitespace">
</span><span class="whitespace">                                           </span><span class="string">" should be a vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">                                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Invalid signature "</span><span class="whitespace"> </span><span class="symbol">sig</span><span class="whitespace">
</span><span class="whitespace">                                           </span><span class="string">" should be a list"</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span class="symbol">conds</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">body</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">body</span>)</span>)</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                                           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">body</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span class="symbol">body</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">conds</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">body</span>)</span><span class="whitespace"> </span><span class="symbol">body</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span class="symbol">conds</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span class="symbol">conds</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">params</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span class="symbol">pre</span><span class="whitespace"> </span><span>(<span class="keyword">:pre</span><span class="whitespace"> </span><span class="symbol">conds</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span class="symbol">post</span><span class="whitespace"> </span><span>(<span class="keyword">:post</span><span class="whitespace"> </span><span class="symbol">conds</span>)</span><span class="whitespace">                       </span><span class="whitespace">
</span><span class="whitespace">                       </span><span class="symbol">body</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">post</span><span class="whitespace">
</span><span class="whitespace">                              </span>`<span>(<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span>'<span class="symbol">%</span></span><span class="whitespace"> </span>~<span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span><span class="unknown">1</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">body</span>)</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                                            </span>`<span>(<span class="macro">do</span><span class="whitespace"> </span>~<span class="unknown">@body</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                                            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">body</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                                 </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>(<span class="symbol">fn*</span><span class="whitespace"> </span><span>[<span class="symbol">c</span>]</span><span class="whitespace"> </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/assert" title="Evaluates expr and throws an exception if it does not evaluate to
  logical true.">assert</a></span><span class="whitespace"> </span>~<span class="symbol">c</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">post</span>)</span><span class="whitespace">
</span><span class="whitespace">                                 </span>~<span>'<span class="symbol">%</span></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                              </span><span class="symbol">body</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span class="symbol">body</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">pre</span><span class="whitespace">
</span><span class="whitespace">                              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/concat" title="Returns a lazy seq representing the concatenation of the elements in the supplied colls.">concat</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>(<span class="symbol">fn*</span><span class="whitespace"> </span><span>[<span class="symbol">c</span>]</span><span class="whitespace"> </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/assert" title="Evaluates expr and throws an exception if it does not evaluate to
  logical true.">assert</a></span><span class="whitespace"> </span>~<span class="symbol">c</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">pre</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                                      </span><span class="symbol">body</span>)</span><span class="whitespace">
</span><span class="whitespace">                              </span><span class="symbol">body</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="symbol">maybe-destructured</span><span class="whitespace"> </span><span class="symbol">params</span><span class="whitespace"> </span><span class="symbol">body</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">new-sigs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">psig</span><span class="whitespace"> </span><span class="symbol">sigs</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list*" title="Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.">list*</a></span><span class="whitespace"> </span><span>'<span class="symbol">fn*</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">new-sigs</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>'<span class="symbol">fn*</span></span><span class="whitespace"> </span><span class="symbol">new-sigs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">&form</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="macro">loop</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Evaluates the exprs in a lexical context in which the symbols in
  the binding-forms are bound to their respective init-exprs or parts
  therein. Acts as a recur target."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">, </span><span class="keyword">:special-form</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">, </span><span class="keyword">:forms</span><span class="whitespace"> </span><span>'<span>[<span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">bindings*</span>]</span><span class="whitespace"> </span><span class="symbol">exprs*</span>)</span>]</span></span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">assert-args</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace"> </span><span class="string">"a vector for its binding"</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/even?" title="Returns true if n is even, throws an exception if n is not an integer">even?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span><span class="whitespace"> </span><span class="string">"an even number of forms in binding vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">db</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/destructure">destructure</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">db</span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span>`<span>(<span class="symbol">loop*</span><span class="whitespace"> </span>~<span class="symbol">bindings</span><span class="whitespace"> </span>~<span class="unknown">@body</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">vs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-nth" title="Returns a lazy seq of every nth item in coll.  Returns a stateful
  transducer when no collection is provided.">take-nth</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop" title="Returns a lazy sequence of all but the first n items in coll.
  Returns a stateful transducer when no collection is provided.">drop</a></span><span class="whitespace"> </span><span class="unknown">1</span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">bs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-nth" title="Returns a lazy seq of every nth item in coll.  Returns a stateful
  transducer when no collection is provided.">take-nth</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">gs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">b</span>]</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span>)</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">bs</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">bfs</span><span class="whitespace"> </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>[<span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">g</span>]</span>]</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace">
</span><span class="whitespace">                              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace">
</span><span class="whitespace">                              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">g</span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">g</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                          </span><span>[]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector" title="Creates a new vector containing the args.">vector</a></span><span class="whitespace"> </span><span class="symbol">bs</span><span class="whitespace"> </span><span class="symbol">vs</span><span class="whitespace"> </span><span class="symbol">gs</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span>~<span class="symbol">bfs</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="symbol">loop*</span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vec" title="Creates a new vector containing the contents of coll. Java arrays
  will be aliased and should not be modified.">vec</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interleave" title="Returns a lazy seq of the first item in each coll, then the second etc.">interleave</a></span><span class="whitespace"> </span><span class="symbol">gs</span><span class="whitespace"> </span><span class="symbol">gs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="macro">let</span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vec" title="Creates a new vector containing the contents of coll. Java arrays
  will be aliased and should not be modified.">vec</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interleave" title="Returns a lazy seq of the first item in each coll, then the second etc.">interleave</a></span><span class="whitespace"> </span><span class="symbol">bs</span><span class="whitespace"> </span><span class="symbol">gs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span>~<span class="unknown">@body</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-first" title="bindings =&gt; x xs

  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once">when-first</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"bindings => x xs

  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">assert-args</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span><span class="whitespace"> </span><span class="string">"a vector for its binding"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span><span class="whitespace"> </span><span class="string">"exactly 2 forms in binding vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">xs</span>]</span><span class="whitespace"> </span><span class="symbol">bindings</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">xs#</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span>~<span class="symbol">xs</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">xs#</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span>~<span class="unknown">@body</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-cat" title="Expands to code which yields a lazy sequence of the concatenation
  of the supplied colls.  Each coll expr is not evaluated until it is
  needed. 

  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))">lazy-cat</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Expands to code which yields a lazy sequence of the concatenation
  of the supplied colls.  Each coll expr is not evaluated until it is
  needed. 

  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">colls</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/concat" title="Returns a lazy seq representing the concatenation of the elements in the supplied colls.">concat</a></span><span class="whitespace"> </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span>`<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">colls</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/for" title="List comprehension. Takes a vector of one or more
   binding-form/collection-expr pairs, each followed by zero or more
   modifiers, and yields a lazy sequence of evaluations of expr.
   Collections are iterated in a nested fashion, rightmost fastest,
   and nested coll-exprs can refer to bindings created in prior
   binding-forms.  Supported modifiers are: :let [binding-form expr ...],
   :while test, :when test.

  (take 100 (for [x (range 100000000) y (range 1000000) :while (&lt; y x)] [x y]))">for</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"List comprehension. Takes a vector of one or more
   binding-form/collection-expr pairs, each followed by zero or more
   modifiers, and yields a lazy sequence of evaluations of expr.
   Collections are iterated in a nested fashion, rightmost fastest,
   and nested coll-exprs can refer to bindings created in prior
   binding-forms.  Supported modifiers are: :let [binding-form expr ...],
   :while test, :when test.

  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">seq-exprs</span><span class="whitespace"> </span><span class="symbol">body-expr</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">assert-args</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">seq-exprs</span>)</span><span class="whitespace"> </span><span class="string">"a vector for its binding"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/even?" title="Returns true if n is even, throws an exception if n is not an integer">even?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">seq-exprs</span>)</span>)</span><span class="whitespace"> </span><span class="string">"an even number of forms in binding vector"</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">to-groups</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">seq-exprs</span>]</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">groups</span><span class="whitespace"> </span><span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">v</span>]</span>]</span><span class="whitespace">
</span><span class="whitespace">                              </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pop" title="For a list or queue, returns a new list/queue without the first
  item, for a vector, returns a new vector without the last item. If
  the collection is empty, throws an exception.  Note - not the same
  as next/butlast.">pop</a></span><span class="whitespace"> </span><span class="symbol">groups</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/peek" title="For a list or queue, same as first, for a vector, same as, but much
  more efficient than, last. If the collection is empty, returns nil.">peek</a></span><span class="whitespace"> </span><span class="symbol">groups</span>)</span><span class="whitespace"> </span><span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">v</span>]</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">groups</span><span class="whitespace"> </span><span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">v</span>]</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>[]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition" title="Returns a lazy sequence of lists of n items each, at offsets step
  apart. If step is not supplied, defaults to n, i.e. the partitions
  do not overlap. If a pad collection is supplied, use its elements as
  necessary to complete last partition upto n items. In case there are
  not enough padding elements, return a partition with less than n items.">partition</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span class="symbol">seq-exprs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">err</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">msg</span>]</span><span class="whitespace"> </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace"> </span><span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="symbol">msg</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">emit-bind</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">emit-bind</span><span class="whitespace"> </span><span>[<span>[<span>[<span class="symbol">bind</span><span class="whitespace"> </span><span class="symbol">expr</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">mod-pairs</span>]</span><span class="whitespace">
</span><span class="whitespace">                                  </span><span class="symbol">&</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">_</span><span class="whitespace"> </span><span class="symbol">next-expr</span>]</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">next-groups</span>]</span>]</span>]</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">giter</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"iter__"</span>)</span><span class="whitespace">
</span><span class="whitespace">                          </span><span class="symbol">gxs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"s__"</span>)</span><span class="whitespace">
</span><span class="whitespace">                          </span><span class="symbol">do-mod</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">do-mod</span><span class="whitespace"> </span><span>[<span>[<span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">pair</span>]</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">etc</span>]</span>]</span><span class="whitespace">
</span><span class="whitespace">                                   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">                                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="keyword">:let</span>)</span><span class="whitespace"> </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span>~<span class="symbol">v</span><span class="whitespace"> </span>~<span>(<span class="symbol">do-mod</span><span class="whitespace"> </span><span class="symbol">etc</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="keyword">:while</span>)</span><span class="whitespace"> </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span>~<span class="symbol">v</span><span class="whitespace"> </span>~<span>(<span class="symbol">do-mod</span><span class="whitespace"> </span><span class="symbol">etc</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="keyword">:when</span>)</span><span class="whitespace"> </span>`<span>(<span class="macro">if</span><span class="whitespace"> </span>~<span class="symbol">v</span><span class="whitespace">
</span><span class="whitespace">                                                    </span>~<span>(<span class="symbol">do-mod</span><span class="whitespace"> </span><span class="symbol">etc</span>)</span><span class="whitespace">
</span><span class="whitespace">                                                    </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span>~<span class="symbol">gxs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">err</span><span class="whitespace"> </span><span class="string">"Invalid 'for' keyword "</span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace">
</span><span class="whitespace">                                     </span><span class="symbol">next-groups</span><span class="whitespace">
</span><span class="whitespace">                                      </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">iterys#</span><span class="whitespace"> </span>~<span>(<span class="symbol">emit-bind</span><span class="whitespace"> </span><span class="symbol">next-groups</span>)</span><span class="whitespace">
</span><span class="whitespace">                                             </span><span class="symbol">fs#</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span>(<span class="symbol">iterys#</span><span class="whitespace"> </span>~<span class="symbol">next-expr</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                                         </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">fs#</span><span class="whitespace">
</span><span class="whitespace">                                           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/concat" title="Returns a lazy seq representing the concatenation of the elements in the supplied colls.">concat</a></span><span class="whitespace"> </span><span class="symbol">fs#</span><span class="whitespace"> </span><span>(~<span class="symbol">giter</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span>~<span class="symbol">gxs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                           </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span>~<span class="symbol">gxs</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                     </span><span class="keyword">:else</span><span class="whitespace"> </span>`<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span>~<span class="symbol">body-expr</span><span class="whitespace">
</span><span class="whitespace">                                                  </span><span>(~<span class="symbol">giter</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span>~<span class="symbol">gxs</span>)</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">next-groups</span><span class="whitespace">
</span><span class="whitespace">                        </span><span class="metadata">#_"not</span><span class="whitespace"> </span><span class="symbol">the</span><span class="whitespace"> </span><span class="symbol">inner-most</span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/loop" title="Evaluates the exprs in a lexical context in which the symbols in
  the binding-forms are bound to their respective init-exprs or parts
  therein. Acts as a recur target.">loop"</a></span><span class="whitespace">
</span><span class="whitespace">                        </span>`<span>(<span class="macro">fn</span><span class="whitespace"> </span>~<span class="symbol">giter</span><span class="whitespace"> </span><span>[~<span class="symbol">gxs</span>]</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[~<span class="symbol">gxs</span><span class="whitespace"> </span>~<span class="symbol">gxs</span>]</span><span class="whitespace">
</span><span class="whitespace">                               </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-first" title="bindings =&gt; x xs

  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once">when-first</a></span><span class="whitespace"> </span><span>[~<span class="symbol">bind</span><span class="whitespace"> </span>~<span class="symbol">gxs</span>]</span><span class="whitespace">
</span><span class="whitespace">                                 </span>~<span>(<span class="symbol">do-mod</span><span class="whitespace"> </span><span class="symbol">mod-pairs</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                        </span><span class="metadata">#_"inner-most</span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/loop" title="Evaluates the exprs in a lexical context in which the symbols in
  the binding-forms are bound to their respective init-exprs or parts
  therein. Acts as a recur target.">loop"</a></span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">gi</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"i__"</span>)</span><span class="whitespace">
</span><span class="whitespace">                              </span><span class="symbol">gb</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"b__"</span>)</span><span class="whitespace">
</span><span class="whitespace">                              </span><span class="symbol">do-cmod</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">do-cmod</span><span class="whitespace"> </span><span>[<span>[<span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">pair</span>]</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">etc</span>]</span>]</span><span class="whitespace">
</span><span class="whitespace">                                        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">                                          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="keyword">:let</span>)</span><span class="whitespace"> </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span>~<span class="symbol">v</span><span class="whitespace"> </span>~<span>(<span class="symbol">do-cmod</span><span class="whitespace"> </span><span class="symbol">etc</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="keyword">:while</span>)</span><span class="whitespace"> </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span>~<span class="symbol">v</span><span class="whitespace"> </span>~<span>(<span class="symbol">do-cmod</span><span class="whitespace"> </span><span class="symbol">etc</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="keyword">:when</span>)</span><span class="whitespace"> </span>`<span>(<span class="macro">if</span><span class="whitespace"> </span>~<span class="symbol">v</span><span class="whitespace">
</span><span class="whitespace">                                                         </span>~<span>(<span class="symbol">do-cmod</span><span class="whitespace"> </span><span class="symbol">etc</span>)</span><span class="whitespace">
</span><span class="whitespace">                                                         </span><span>(<span class="macro">recur</span><span class="whitespace">
</span><span class="whitespace">                                                           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-inc" title="Returns a number one greater than x, a long.
  Note - uses a primitive operator subject to overflow.">unchecked-inc</a></span><span class="whitespace"> </span>~<span class="symbol">gi</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace">
</span><span class="whitespace">                                            </span><span>(<span class="symbol">err</span><span class="whitespace"> </span><span class="string">"Invalid 'for' keyword "</span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace">
</span><span class="whitespace">                                          </span><span class="keyword">:else</span><span class="whitespace">
</span><span class="whitespace">                                            </span>`<span>(<span class="macro">do</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-append">chunk-append</a></span><span class="whitespace"> </span>~<span class="symbol">gb</span><span class="whitespace"> </span>~<span class="symbol">body-expr</span>)</span><span class="whitespace">
</span><span class="whitespace">                                                 </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-inc" title="Returns a number one greater than x, a long.
  Note - uses a primitive operator subject to overflow.">unchecked-inc</a></span><span class="whitespace"> </span>~<span class="symbol">gi</span>)</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                          </span>`<span>(<span class="macro">fn</span><span class="whitespace"> </span>~<span class="symbol">giter</span><span class="whitespace"> </span><span>[~<span class="symbol">gxs</span>]</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">                               </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[~<span class="symbol">gxs</span><span class="whitespace"> </span>~<span class="symbol">gxs</span>]</span><span class="whitespace">
</span><span class="whitespace">                                 </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[~<span class="symbol">gxs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span>~<span class="symbol">gxs</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                                   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunked-seq?">chunked-seq?</a></span><span class="whitespace"> </span>~<span class="symbol">gxs</span>)</span><span class="whitespace">
</span><span class="whitespace">                                     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">c#</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-first">chunk-first</a></span><span class="whitespace"> </span>~<span class="symbol">gxs</span>)</span><span class="whitespace">
</span><span class="whitespace">                                           </span><span class="symbol">size#</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">c#</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                           </span>~<span class="symbol">gb</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-buffer">chunk-buffer</a></span><span class="whitespace"> </span><span class="symbol">size#</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                                       </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[~<span class="symbol">gi</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span class="unknown">0</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                                             </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span>~<span class="symbol">gi</span><span class="whitespace"> </span><span class="symbol">size#</span>)</span><span class="whitespace">
</span><span class="whitespace">                                               </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">bind</span><span class="whitespace"> </span><span>(<span class="java-class">.nth</span><span class="whitespace"> </span><span class="symbol">c#</span><span class="whitespace"> </span>~<span class="symbol">gi</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                                                 </span>~<span>(<span class="symbol">do-cmod</span><span class="whitespace"> </span><span class="symbol">mod-pairs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                               </span><span class="unknown">true</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-cons">chunk-cons</a></span><span class="whitespace">
</span><span class="whitespace">                                           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk">chunk</a></span><span class="whitespace"> </span>~<span class="symbol">gb</span>)</span><span class="whitespace">
</span><span class="whitespace">                                           </span><span>(~<span class="symbol">giter</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-rest">chunk-rest</a></span><span class="whitespace"> </span>~<span class="symbol">gxs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-cons">chunk-cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk">chunk</a></span><span class="whitespace"> </span>~<span class="symbol">gb</span>)</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">bind</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span>~<span class="symbol">gxs</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                                       </span>~<span>(<span class="symbol">do-mod</span><span class="whitespace"> </span><span class="symbol">mod-pairs</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">iter#</span><span class="whitespace"> </span>~<span>(<span class="symbol">emit-bind</span><span class="whitespace"> </span><span>(<span class="symbol">to-groups</span><span class="whitespace"> </span><span class="symbol">seq-exprs</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="symbol">iter#</span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">seq-exprs</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/comment" title="Ignores body, yields nil">comment</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Ignores body, yields nil"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-out-str" title="Evaluates exprs in a context in which *out* is bound to a fresh
  StringWriter.  Returns the string created by any nested printing
  calls.">with-out-str</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Evaluates exprs in a context in which *out* is bound to a fresh
  StringWriter.  Returns the string created by any nested printing
  calls."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">s#</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">java.io.StringWriter</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/binding" title="binding =&gt; var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.">binding</a></span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*out*" title="A java.io.Writer object representing standard output for print operations.

  Defaults to System/out, wrapped in an OutputStreamWriter">*out*</a></span><span class="whitespace"> </span><span class="symbol">s#</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span>~<span class="unknown">@body</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="symbol">s#</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-in-str" title="Evaluates body in a context in which *in* is bound to a fresh
  StringReader initialized with the string s.">with-in-str</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Evaluates body in a context in which *in* is bound to a fresh
  StringReader initialized with the string s."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-open" title="bindings =&gt; [name init ...]

  Evaluates body in a try expression with names bound to the values
  of the inits, and a finally clause that calls (.close name) on each
  name in reverse order.">with-open</a></span><span class="whitespace"> </span><span>[<span class="symbol">s#</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span>(<span class="symbol">java.io.StringReader.</span><span class="whitespace"> </span>~<span class="symbol">s</span>)</span><span class="whitespace"> </span><span class="symbol">clojure.lang.LineNumberingPushbackReader.</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/binding" title="binding =&gt; var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.">binding</a></span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*in*" title="A java.io.Reader object representing standard input for read operations.

  Defaults to System/in, wrapped in a LineNumberingPushbackReader">*in*</a></span><span class="whitespace"> </span><span class="symbol">s#</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span>~<span class="unknown">@body</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pr-str" title="pr to a string, returning it">pr-str</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"pr to a string, returning it"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">String</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">xs</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-out-str" title="Evaluates exprs in a context in which *out* is bound to a fresh
  StringWriter.  Returns the string created by any nested printing
  calls.">with-out-str</a></span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pr" title="Prints the object(s) to the output stream that is the current value
  of *out*.  Prints the object(s), separated by spaces if there is
  more than one.  By default, pr and prn print in a way that objects
  can be read by the reader">pr</a></span><span class="whitespace"> </span><span class="symbol">xs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/prn-str" title="prn to a string, returning it">prn-str</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"prn to a string, returning it"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">String</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">xs</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-out-str" title="Evaluates exprs in a context in which *out* is bound to a fresh
  StringWriter.  Returns the string created by any nested printing
  calls.">with-out-str</a></span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/prn" title="Same as pr followed by (newline). Observes *flush-on-newline*">prn</a></span><span class="whitespace"> </span><span class="symbol">xs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/print-str" title="print to a string, returning it">print-str</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"print to a string, returning it"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">String</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">xs</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-out-str" title="Evaluates exprs in a context in which *out* is bound to a fresh
  StringWriter.  Returns the string created by any nested printing
  calls.">with-out-str</a></span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/print" title="Prints the object(s) to the output stream that is the current value
  of *out*.  print and println produce output for human consumption.">print</a></span><span class="whitespace"> </span><span class="symbol">xs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/println-str" title="println to a string, returning it">println-str</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"println to a string, returning it"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">String</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">xs</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-out-str" title="Evaluates exprs in a context in which *out* is bound to a fresh
  StringWriter.  Returns the string created by any nested printing
  calls.">with-out-str</a></span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/println" title="Same as print followed by (newline)">println</a></span><span class="whitespace"> </span><span class="symbol">xs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/import" title="import-list =&gt; (package-symbol class-name-symbols*)

  For each name in class-name-symbols, adds a mapping from name to the
  class named by package.name to the current namespace. Use :import in the ns
  macro in preference to calling this directly.">import</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.ExceptionInfo</span><span class="whitespace"> </span><span class="java-class">clojure.lang.IExceptionInfo</span>)</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ex-info" title="Create an instance of ExceptionInfo, a RuntimeException subclass
   that carries a map of additional data.">ex-info</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Create an instance of ExceptionInfo, a RuntimeException subclass
   that carries a map of additional data."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.4"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">msg</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">ExceptionInfo.</span><span class="whitespace"> </span><span class="symbol">msg</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">msg</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">cause</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">ExceptionInfo.</span><span class="whitespace"> </span><span class="symbol">msg</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">cause</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ex-data" title="Returns exception data (a map) if ex is an IExceptionInfo.
   Otherwise returns nil.">ex-data</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns exception data (a map) if ex is an IExceptionInfo.
   Otherwise returns nil."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.4"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">ex</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="symbol">IExceptionInfo</span><span class="whitespace"> </span><span class="symbol">ex</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.getData</span><span class="whitespace"> </span><span>^<span class="symbol">IExceptionInfo</span></span><span class="whitespace"> </span><span class="symbol">ex</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/assert" title="Evaluates expr and throws an exception if it does not evaluate to
  logical true.">assert</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Evaluates expr and throws an exception if it does not evaluate to
  logical true."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*assert*">*assert*</a></span><span class="whitespace">
</span><span class="whitespace">       </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">AssertionError</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Assert failed: "</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pr-str" title="pr to a string, returning it">pr-str</a></span><span class="whitespace"> </span><span>'~</span><span class="symbol">x</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">message</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*assert*">*assert*</a></span><span class="whitespace">
</span><span class="whitespace">       </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace"> </span>~<span class="symbol">x</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">AssertionError</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Assert failed: "</span><span class="whitespace"> </span>~<span class="symbol">message</span><span class="whitespace"> </span><span class="string">"\n"</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pr-str" title="pr to a string, returning it">pr-str</a></span><span class="whitespace"> </span><span>'~</span><span class="symbol">x</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">v</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="keyword">:test</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">do</span><span class="whitespace"> </span><span>(<span class="symbol">f</span>)</span><span class="whitespace"> </span><span class="keyword">:ok</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="keyword">:no-test</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/re-pattern" title="Returns an instance of java.util.regex.Pattern, for use, e.g. in
  re-matcher.">re-pattern</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns an instance of java.util.regex.Pattern, for use, e.g. in
  re-matcher."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">java.util.regex.Pattern</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">s</span>]</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">java.util.regex.Pattern</span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">s</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">java.util.regex.Pattern</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/compile" title="Compiles the namespace named by the symbol lib into a set of
  classfiles. The source for the lib must be in a proper
  classpath-relative directory. The output files will go into the
  directory specified by *compile-path*, and that directory too must
  be in the classpath.">compile</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/re-matcher" title="Returns an instance of java.util.regex.Matcher, for use, e.g. in
  re-find.">re-matcher</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns an instance of java.util.regex.Matcher, for use, e.g. in
  re-find."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">java.util.regex.Matcher</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">java.util.regex.Pattern</span></span><span class="whitespace"> </span><span class="symbol">re</span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">re</span><span class="whitespace"> </span><span>(<span class="symbol">matcher</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/re-groups" title="Returns the groups from the most recent match/find. If there are no
  nested groups, returns a string of the entire match. If there are
  nested groups, returns a vector of the groups, the first element
  being the entire match.">re-groups</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the groups from the most recent match/find. If there are no
  nested groups, returns a string of the entire match. If there are
  nested groups, returns a vector of the groups, the first element
  being the entire match."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">java.util.regex.Matcher</span></span><span class="whitespace"> </span><span class="symbol">m</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">gc</span><span class="whitespace">  </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="symbol">groupCount</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/zero?" title="Returns true if num is zero, else false">zero?</a></span><span class="whitespace"> </span><span class="symbol">gc</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="symbol">group</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="unknown">0</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;=" title="Returns non-nil if nums are in monotonically non-decreasing order,
  otherwise false."><=</a></span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">gc</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="symbol">group</span><span class="whitespace"> </span><span class="symbol">c</span>)</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">c</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/re-seq" title="Returns a lazy sequence of successive matches of pattern in string,
  using java.util.regex.Matcher.find(), each such match processed with
  re-groups.">re-seq</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of successive matches of pattern in string,
  using java.util.regex.Matcher.find(), each such match processed with
  re-groups."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">java.util.regex.Pattern</span></span><span class="whitespace"> </span><span class="symbol">re</span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/re-matcher" title="Returns an instance of java.util.regex.Matcher, for use, e.g. in
  re-find.">re-matcher</a></span><span class="whitespace"> </span><span class="symbol">re</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">step</span><span class="whitespace"> </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find" title="Returns the map entry for key, or nil if key not present.">find</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/re-groups" title="Returns the groups from the most recent match/find. If there are no
  nested groups, returns a string of the entire match. If there are
  nested groups, returns a vector of the groups, the first element
  being the entire match.">re-groups</a></span><span class="whitespace"> </span><span class="symbol">m</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace"> </span><span>(<span class="symbol">step</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/re-matches" title="Returns the match, if any, of string to pattern, using
  java.util.regex.Matcher.matches().  Uses re-groups to return the
  groups.">re-matches</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the match, if any, of string to pattern, using
  java.util.regex.Matcher.matches().  Uses re-groups to return the
  groups."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">java.util.regex.Pattern</span></span><span class="whitespace"> </span><span class="symbol">re</span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/re-matcher" title="Returns an instance of java.util.regex.Matcher, for use, e.g. in
  re-find.">re-matcher</a></span><span class="whitespace"> </span><span class="symbol">re</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="symbol">matches</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/re-groups" title="Returns the groups from the most recent match/find. If there are no
  nested groups, returns a string of the entire match. If there are
  nested groups, returns a vector of the groups, the first element
  being the entire match.">re-groups</a></span><span class="whitespace"> </span><span class="symbol">m</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/re-find" title="Returns the next regex match, if any, of string to pattern, using
  java.util.regex.Matcher.find().  Uses re-groups to return the
  groups.">re-find</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the next regex match, if any, of string to pattern, using
  java.util.regex.Matcher.find().  Uses re-groups to return the
  groups."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">java.util.regex.Matcher</span></span><span class="whitespace"> </span><span class="symbol">m</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find" title="Returns the map entry for key, or nil if key not present.">find</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/re-groups" title="Returns the groups from the most recent match/find. If there are no
  nested groups, returns a string of the entire match. If there are
  nested groups, returns a vector of the groups, the first element
  being the entire match.">re-groups</a></span><span class="whitespace"> </span><span class="symbol">m</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">java.util.regex.Pattern</span></span><span class="whitespace"> </span><span class="symbol">re</span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/re-matcher" title="Returns an instance of java.util.regex.Matcher, for use, e.g. in
  re-find.">re-matcher</a></span><span class="whitespace"> </span><span class="symbol">re</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/re-find" title="Returns the next regex match, if any, of string to pattern, using
  java.util.regex.Matcher.find().  Uses re-groups to return the
  groups.">re-find</a></span><span class="whitespace"> </span><span class="symbol">m</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rand" title="Returns a random floating point number between 0 (inclusive) and
  n (default 1) (exclusive).">rand</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a random floating point number between 0 (inclusive) and
  n (default 1) (exclusive)."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">Math</span><span class="whitespace"> </span><span>(<span class="symbol">random</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*" title="Returns the product of nums. (*) returns 1. Does not auto-promote
  longs, will throw on overflow. See also: *&apos;">*</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rand" title="Returns a random floating point number between 0 (inclusive) and
  n (default 1) (exclusive).">rand</a></span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rand-int" title="Returns a random integer between 0 (inclusive) and n (exclusive).">rand-int</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a random integer between 0 (inclusive) and n (exclusive)."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">n</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rand" title="Returns a random floating point number between 0 (inclusive) and
  n (default 1) (exclusive).">rand</a></span><span class="whitespace"> </span><span class="symbol">n</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"same as defn, yielding non-public def"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">decls</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list*" title="Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.">list*</a></span><span class="whitespace"> </span>`<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">decls</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/tree-seq" title="Returns a lazy sequence of the nodes in a tree, via a depth-first walk.
   branch? must be a fn of one arg that returns true if passed a node
   that can have children (but may not).  children must be a fn of one
   arg that returns a sequence of the children. Will only be called on
   nodes for which branch? returns true. Root is the root node of the
  tree.">tree-seq</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of the nodes in a tree, via a depth-first walk.
   branch? must be a fn of one arg that returns true if passed a node
   that can have children (but may not).  children must be a fn of one
   arg that returns a sequence of the children. Will only be called on
   nodes for which branch? returns true. Root is the root node of the
  tree."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span>[<span class="symbol">branch?</span><span class="whitespace"> </span><span class="symbol">children</span><span class="whitespace"> </span><span class="symbol">root</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">walk</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">walk</span><span class="whitespace"> </span><span>[<span class="symbol">node</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">node</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="symbol">branch?</span><span class="whitespace"> </span><span class="symbol">node</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/mapcat" title="Returns the result of applying concat to the result of applying map
  to f and colls.  Thus function f should return a collection. Returns
  a transducer when no collections are provided">mapcat</a></span><span class="whitespace"> </span><span class="symbol">walk</span><span class="whitespace"> </span><span>(<span class="symbol">children</span><span class="whitespace"> </span><span class="symbol">node</span>)</span>)</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">walk</span><span class="whitespace"> </span><span class="symbol">root</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/file-seq" title="A tree seq on java.io.Files">file-seq</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"A tree seq on java.io.Files"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">dir</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/tree-seq" title="Returns a lazy sequence of the nodes in a tree, via a depth-first walk.
   branch? must be a fn of one arg that returns true if passed a node
   that can have children (but may not).  children must be a fn of one
   arg that returns a sequence of the children. Will only be called on
   nodes for which branch? returns true. Root is the root node of the
  tree.">tree-seq</a></span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">java.io.File</span></span><span class="whitespace"> </span><span class="symbol">f</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">isDirectory</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">java.io.File</span></span><span class="whitespace"> </span><span class="symbol">d</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span>(<span class="symbol">listFiles</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="symbol">dir</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/xml-seq" title="A tree seq on the xml elements as per xml/parse">xml-seq</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"A tree seq on the xml elements as per xml/parse"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">root</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/tree-seq" title="Returns a lazy sequence of the nodes in a tree, via a depth-first walk.
   branch? must be a fn of one arg that returns true if passed a node
   that can have children (but may not).  children must be a fn of one
   arg that returns a sequence of the children. Will only be called on
   nodes for which branch? returns true. Root is the root node of the
  tree.">tree-seq</a></span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/complement" title="Takes a fn f and returns a fn that takes the same arguments as f,
  has the same effects, if any, and returns the opposite truth value.">complement</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comp" title="Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.">comp</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="keyword">:content</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="symbol">root</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/special-symbol?" title="Returns true if s names a special form">special-symbol?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if s names a special form"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Compiler</span><span class="whitespace"> </span><span class="symbol">specials</span>)</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/var?" title="Returns true if v is of type clojure.lang.Var">var?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if v is of type clojure.lang.Var"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">v</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Var</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/subs" title="Returns the substring of s beginning at start inclusive, and ending
  at end (defaults to length of string), exclusive.">subs</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the substring of s beginning at start inclusive, and ending
  at end (defaults to length of string), exclusive."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">start</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L46">substring</a></span><span class="whitespace"> </span><span class="symbol">start</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">start</span><span class="whitespace"> </span><span class="symbol">end</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L46">substring</a></span><span class="whitespace"> </span><span class="symbol">start</span><span class="whitespace"> </span><span class="symbol">end</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/max-key" title="Returns the x for which (k x), a number, is greatest.">max-key</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the x for which (k x), a number, is greatest."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&gt;" title="Returns non-nil if nums are in monotonically decreasing order,
  otherwise false.">></a></span><span class="whitespace"> </span><span>(<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/max-key" title="Returns the x for which (k x), a number, is greatest.">max-key</a></span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">%1</span><span class="whitespace"> </span><span class="symbol">%2</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/max-key" title="Returns the x for which (k x), a number, is greatest.">max-key</a></span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/min-key" title="Returns the x for which (k x), a number, is least.">min-key</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the x for which (k x), a number, is least."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span><span>(<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/min-key" title="Returns the x for which (k x), a number, is least.">min-key</a></span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">%1</span><span class="whitespace"> </span><span class="symbol">%2</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/min-key" title="Returns the x for which (k x), a number, is least.">min-key</a></span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/distinct" title="Returns a lazy sequence of the elements of coll with duplicates removed.
  Returns a stateful transducer when no collection is provided.">distinct</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of the elements of coll with duplicates removed.
  Returns a stateful transducer when no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">seen</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/volatile!" title="Creates and returns a Volatile with an initial value of val.">volatile!</a></span><span class="whitespace"> </span><span>#{}</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span class="unknown">@seen</span><span class="whitespace"> </span><span class="symbol">input</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">result</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">do</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/vswap!" title="Non-atomically swaps the value of the volatile as if:
   (apply f current-value-of-vol args). Returns the value that
   was swapped in.">vswap!</a></span><span class="whitespace"> </span><span class="symbol">seen</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">input</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">step</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">step</span><span class="whitespace"> </span><span>[<span class="symbol">xs</span><span class="whitespace"> </span><span class="symbol">seen</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">xs</span>]</span><span class="whitespace"> </span><span class="symbol">seen</span>]</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">xs</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span class="symbol">seen</span><span class="whitespace"> </span><span class="symbol">f</span>)</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span class="symbol">seen</span>)</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">step</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">seen</span><span class="whitespace"> </span><span class="symbol">f</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">xs</span><span class="whitespace"> </span><span class="symbol">seen</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">step</span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span>#{}</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/replace" title="Given a map of replacement pairs and a vector/collection, returns a
  vector/seq with any elements = a key in smap replaced with the
  corresponding val in smap.  Returns a transducer when no collection
  is provided.">replace</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Given a map of replacement pairs and a vector/collection, returns a
  vector/seq with any elements = a key in smap replaced with the
  corresponding val in smap.  Returns a transducer when no collection
  is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">smap</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">e</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find" title="Returns the map entry for key, or nil if key not present.">find</a></span><span class="whitespace"> </span><span class="symbol">smap</span><span class="whitespace"> </span><span class="symbol">%</span>)</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">e</span>)</span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">smap</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">i</span>]</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">e</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find" title="Returns the map entry for key, or nil if key not present.">find</a></span><span class="whitespace"> </span><span class="symbol">smap</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nth" title="Returns the value at the index. get returns nil if index out of
  bounds, nth throws an exception unless not-found is supplied.  nth
  also works for strings, Java arrays, regex Matchers and Lists, and,
  in O(n) time, for sequences.">nth</a></span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">e</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span class="symbol">v</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span class="symbol">coll</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/range" title="Returns a lazy seq of nums from start (inclusive) to end
  (exclusive), by step, where start defaults to 0, step to 1, and end to
  infinity. When step is equal to 0, returns an infinite sequence of
  start. When start is equal to end, returns empty list.">range</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">e</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find" title="Returns the map entry for key, or nil if key not present.">find</a></span><span class="whitespace"> </span><span class="symbol">smap</span><span class="whitespace"> </span><span class="symbol">%</span>)</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">e</span>)</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/dosync" title="Runs the exprs (in an implicit do) in a transaction that encompasses
  exprs and any nested calls.  Starts a transaction if none is already
  running on this thread. Any uncaught exception will abort the
  transaction and flow out of dosync. The exprs may be run more than
  once, but any effects on Refs will be atomic.">dosync</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Runs the exprs (in an implicit do) in a transaction that encompasses
  exprs and any nested calls.  Starts a transaction if none is already
  running on this thread. Any uncaught exception will abort the
  transaction and flow out of dosync. The exprs may be run more than
  once, but any effects on Refs will be atomic."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">exprs</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/sync" title="transaction-flags =&gt; TBD, pass nil for now

  Runs the exprs (in an implicit do) in a transaction that encompasses
  exprs and any nested calls.  Starts a transaction if none is already
  running on this thread. Any uncaught exception will abort the
  transaction and flow out of sync. The exprs may be run more than
  once, but any effects on Refs will be atomic.">sync</a></span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace"> </span>~<span class="unknown">@exprs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-precision" title="Sets the precision and rounding mode to be used for BigDecimal operations.

  Usage: (with-precision 10 (/ 1M 3))
  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))

  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,
  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.">with-precision</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Sets the precision and rounding mode to be used for BigDecimal operations.

  Usage: (with-precision 10 (/ 1M 3))
  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))

  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,
  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">precision</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">exprs</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">body</span><span class="whitespace"> </span><span class="symbol">rm</span>]</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">exprs</span>)</span><span class="whitespace"> </span><span class="keyword">:rounding</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>[<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">exprs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span>`<span>(<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">java.math.RoundingMode</span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">exprs</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>[<span class="symbol">exprs</span><span class="whitespace"> </span><span class="unparsed">nil</span>]</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/binding" title="binding =&gt; var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.">binding</a></span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*math-context*">*math-context*</a></span><span class="whitespace"> </span><span>(<span class="symbol">java.math.MathContext.</span><span class="whitespace"> </span>~<span class="symbol">precision</span><span class="whitespace"> </span>~<span class="unknown">@rm</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span>~<span class="unknown">@body</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="symbol">mk-bound-fn</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Sorted</span></span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">e</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span>(<span class="java-class">..</span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comparator" title="Returns an implementation of java.util.Comparator based upon pred.">comparator</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/compare" title="Comparator. Returns a negative number, zero, or a positive number
  when x is logically &apos;less than&apos;, &apos;equal to&apos;, or &apos;greater than&apos;
  y. Same as Java x.compareTo(y) except it also works for nil, and
  compares numbers and collections in a type-independent manner. x
  must implement Comparable">compare</a></span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="symbol">entryKey</span><span class="whitespace"> </span><span class="symbol">e</span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>)</span><span class="whitespace"> </span><span class="unknown">0</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/subseq" title="sc must be a sorted collection, test(s) one of &lt;, &lt;=, &gt; or
  &gt;=. Returns a seq of those entries with keys ek for
  which (test (.. sc comparator (compare ek key)) 0) is true">subseq</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"sc must be a sorted collection, test(s) one of <, <=, > or
  >=. Returns a seq of those entries with keys ek for
  which (test (.. sc comparator (compare ek key)) 0) is true"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.Sorted</span></span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">include</span><span class="whitespace"> </span><span>(<span class="symbol">mk-bound-fn</span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span>#{<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&gt;" title="Returns non-nil if nums are in monotonically decreasing order,
  otherwise false.">></a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&gt;=" title="Returns non-nil if nums are in monotonically non-increasing order,
  otherwise false.">>=</a></span>}</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span>[<span class="symbol">e</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="symbol">seqFrom</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="unknown">true</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="symbol">include</span><span class="whitespace"> </span><span class="symbol">e</span>)</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-while" title="Returns a lazy sequence of successive items from coll while
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">take-while</a></span><span class="whitespace"> </span><span class="symbol">include</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="unknown">true</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.Sorted</span></span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="symbol">start-test</span><span class="whitespace"> </span><span class="symbol">start-key</span><span class="whitespace"> </span><span class="symbol">end-test</span><span class="whitespace"> </span><span class="symbol">end-key</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span>[<span class="symbol">e</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="symbol">seqFrom</span><span class="whitespace"> </span><span class="symbol">start-key</span><span class="whitespace"> </span><span class="unknown">true</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-while" title="Returns a lazy sequence of successive items from coll while
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">take-while</a></span><span class="whitespace"> </span><span>(<span class="symbol">mk-bound-fn</span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="symbol">end-test</span><span class="whitespace"> </span><span class="symbol">end-key</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span>(<span class="symbol">mk-bound-fn</span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="symbol">start-test</span><span class="whitespace"> </span><span class="symbol">start-key</span>)</span><span class="whitespace"> </span><span class="symbol">e</span>)</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rsubseq" title="sc must be a sorted collection, test(s) one of &lt;, &lt;=, &gt; or
  &gt;=. Returns a reverse seq of those entries with keys ek for
  which (test (.. sc comparator (compare ek key)) 0) is true">rsubseq</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"sc must be a sorted collection, test(s) one of <, <=, > or
  >=. Returns a reverse seq of those entries with keys ek for
  which (test (.. sc comparator (compare ek key)) 0) is true"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.Sorted</span></span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">include</span><span class="whitespace"> </span><span>(<span class="symbol">mk-bound-fn</span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span>#{<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;=" title="Returns non-nil if nums are in monotonically non-decreasing order,
  otherwise false."><=</a></span>}</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span>[<span class="symbol">e</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="symbol">seqFrom</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="unknown">false</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="symbol">include</span><span class="whitespace"> </span><span class="symbol">e</span>)</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-while" title="Returns a lazy sequence of successive items from coll while
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">take-while</a></span><span class="whitespace"> </span><span class="symbol">include</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="unknown">false</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="java-class">clojure.lang.Sorted</span></span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="symbol">start-test</span><span class="whitespace"> </span><span class="symbol">start-key</span><span class="whitespace"> </span><span class="symbol">end-test</span><span class="whitespace"> </span><span class="symbol">end-key</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span>[<span class="symbol">e</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="symbol">seqFrom</span><span class="whitespace"> </span><span class="symbol">end-key</span><span class="whitespace"> </span><span class="unknown">false</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-while" title="Returns a lazy sequence of successive items from coll while
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">take-while</a></span><span class="whitespace"> </span><span>(<span class="symbol">mk-bound-fn</span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="symbol">start-test</span><span class="whitespace"> </span><span class="symbol">start-key</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span>(<span class="symbol">mk-bound-fn</span><span class="whitespace"> </span><span class="symbol">sc</span><span class="whitespace"> </span><span class="symbol">end-test</span><span class="whitespace"> </span><span class="symbol">end-key</span>)</span><span class="whitespace"> </span><span class="symbol">e</span>)</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/repeatedly" title="Takes a function of no args, presumably with side effects, and
  returns an infinite (or length n if supplied) lazy sequence of calls
  to it">repeatedly</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a function of no args, presumably with side effects, and
  returns an infinite (or length n if supplied) lazy sequence of calls
  to it"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="symbol">f</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/repeatedly" title="Takes a function of no args, presumably with side effects, and
  returns an infinite (or length n if supplied) lazy sequence of calls
  to it">repeatedly</a></span><span class="whitespace"> </span><span class="symbol">f</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">f</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take" title="Returns a lazy sequence of the first n items in coll, or all items if
  there are fewer than n.  Returns a stateful transducer when
  no collection is provided.">take</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/repeatedly" title="Takes a function of no args, presumably with side effects, and
  returns an infinite (or length n if supplied) lazy sequence of calls
  to it">repeatedly</a></span><span class="whitespace"> </span><span class="symbol">f</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/add-classpath" title="DEPRECATED 

  Adds the url (String or URL object) to the classpath per
  URLClassLoader.addURL">add-classpath</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"DEPRECATED 

  Adds the url (String or URL object) to the classpath per
  URLClassLoader.addURL"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:deprecated</span><span class="whitespace"> </span><span class="string">"1.1"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">url</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/println" title="Same as print followed by (newline)">println</a></span><span class="whitespace"> </span><span class="string">"WARNING: add-classpath is deprecated"</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">addURL</span></span><span class="whitespace"> </span><span class="symbol">url</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash" title="Returns the hash code of its argument. Note this is the hash code
  consistent with =, and thus is different than .hashCode for Integer,
  Short, Byte and Clojure collections.">hash</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the hash code of its argument. Note this is the hash code
  consistent with =, and thus is different than .hashCode for Integer,
  Short, Byte and Clojure collections."</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Util</span><span class="whitespace"> </span><span>(<span class="symbol">hasheq</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/mix-collection-hash" title="Mix final collection hash for ordered or unordered collections.
   hash-basis is the combined collection hash, count is the number
   of elements included in the basis. Note this is the hash code
   consistent with =, different from .hashCode.
   See http://clojure.org/data_structures#hash for full algorithms.">mix-collection-hash</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Mix final collection hash for ordered or unordered collections.
   hash-basis is the combined collection hash, count is the number
   of elements included in the basis. Note this is the hash code
   consistent with =, different from .hashCode.
   See http://clojure.org/data_structures#hash for full algorithms."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.6"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long" title="Coerce to long">long</a></span></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long" title="Coerce to long">long</a></span></span><span class="whitespace"> </span><span class="symbol">hash-basis</span><span class="whitespace"> </span><span>^<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long" title="Coerce to long">long</a></span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Murmur3/<span class="symbol">mixCollHash</span></span><span class="whitespace"> </span><span class="symbol">hash-basis</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash-ordered-coll" title="Returns the hash code, consistent with =, for an external ordered
   collection implementing Iterable.
   See http://clojure.org/data_structures#hash for full algorithms.">hash-ordered-coll</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the hash code, consistent with =, for an external ordered
   collection implementing Iterable.
   See http://clojure.org/data_structures#hash for full algorithms."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.6"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long" title="Coerce to long">long</a></span></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Murmur3/<span class="symbol">hashOrdered</span></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash-unordered-coll" title="Returns the hash code, consistent with =, for an external unordered
   collection implementing Iterable. For maps, the iterator should
   return map entries whose hash is computed as
     (hash-ordered-coll [k v]).
   See http://clojure.org/data_structures#hash for full algorithms.">hash-unordered-coll</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the hash code, consistent with =, for an external unordered
   collection implementing Iterable. For maps, the iterator should
   return map entries whose hash is computed as
     (hash-ordered-coll [k v]).
   See http://clojure.org/data_structures#hash for full algorithms."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.6"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long" title="Coerce to long">long</a></span></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Murmur3/<span class="symbol">hashUnordered</span></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interpose" title="Returns a lazy seq of the elements of coll separated by sep.
  Returns a stateful transducer when no collection is provided.">interpose</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy seq of the elements of coll separated by sep.
  Returns a stateful transducer when no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">sep</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">started</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/volatile!" title="Creates and returns a Volatile with an initial value of val.">volatile!</a></span><span class="whitespace"> </span><span class="unknown">false</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="unknown">@started</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">sepr</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">sep</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduced?" title="Returns true if x is the result of a call to reduced">reduced?</a></span><span class="whitespace"> </span><span class="symbol">sepr</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span class="symbol">sepr</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">sepr</span><span class="whitespace"> </span><span class="symbol">input</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">do</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vreset!" title="Sets the value of volatile to newval without regard for the
   current value. Returns newval.">vreset!</a></span><span class="whitespace"> </span><span class="symbol">started</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">sep</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop" title="Returns a lazy sequence of all but the first n items in coll.
  Returns a stateful transducer when no collection is provided.">drop</a></span><span class="whitespace"> </span><span class="unknown">1</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interleave" title="Returns a lazy seq of the first item in each coll, then the second etc.">interleave</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/repeat" title="Returns a lazy (infinite!, or length n if supplied) sequence of xs.">repeat</a></span><span class="whitespace"> </span><span class="symbol">sep</span>)</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/definline" title="Experimental - like defmacro, except defines a named function whose
  body is the expansion, calls to which may be expanded inline as if
  it were a macro. Cannot be used with variadic (&amp;) args.">definline</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Experimental - like defmacro, except defines a named function whose
  body is the expansion, calls to which may be expanded inline as if
  it were a macro. Cannot be used with variadic (&) args."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">decl</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">pre-args</span><span class="whitespace"> </span><span>[<span class="symbol">args</span><span class="whitespace"> </span><span class="symbol">expr</span>]</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/split-with" title="Returns a vector of [(take-while pred coll) (drop-while pred coll)]">split-with</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comp" title="Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.">comp</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span>)</span><span class="whitespace"> </span><span class="symbol">decl</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">do</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span>~<span class="unknown">@pre-args</span><span class="whitespace"> </span>~<span class="symbol">args</span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/eval" title="Evaluates the form data structure (not text!) and returns the result.">eval</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span>`<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">args</span><span class="whitespace"> </span><span class="symbol">expr</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alter-meta!" title="Atomically sets the metadata for a namespace/var/ref/agent/atom to be:

  (apply f its-current-meta args)

  f must be free of side-effects">alter-meta!</a></span><span class="whitespace"> </span><span>(<span class="macro">var</span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span>~<span class="symbol">args</span><span class="whitespace"> </span>~<span class="symbol">expr</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">var</span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/empty" title="Returns an empty collection of the same category as coll, or nil">empty</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns an empty collection of the same category as coll, or nil"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IPersistentCollection</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.empty</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.IPersistentCollection</span></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/amap" title="Maps an expression across an array a, using an index named idx, and
  return value named ret, initialized to a clone of a, then setting 
  each element of ret to the evaluation of expr, returning the new 
  array ret.">amap</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Maps an expression across an array a, using an index named idx, and
  return value named ret, initialized to a clone of a, then setting 
  each element of ret to the evaluation of expr, returning the new 
  array ret."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">idx</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">expr</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">a#</span><span class="whitespace"> </span>~<span class="symbol">a</span><span class="whitespace">
</span><span class="whitespace">         </span>~<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aclone" title="Returns a clone of the Java array. Works on arrays of known
  types.">aclone</a></span><span class="whitespace"> </span><span class="symbol">a#</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">loop</span><span class="whitespace">  </span><span>[~<span class="symbol">idx</span><span class="whitespace"> </span><span class="unknown">0</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span>~<span class="symbol">idx</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alength" title="Returns the length of the Java array. Works on arrays of all
  types.">alength</a></span><span class="whitespace"> </span><span class="symbol">a#</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">do</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/aset" title="Sets the value at the index/indices. Works on Java arrays of
  reference types. Returns val.">aset</a></span><span class="whitespace"> </span>~<span class="symbol">ret</span><span class="whitespace"> </span>~<span class="symbol">idx</span><span class="whitespace"> </span>~<span class="symbol">expr</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-inc" title="Returns a number one greater than x, a long.
  Note - uses a primitive operator subject to overflow.">unchecked-inc</a></span><span class="whitespace"> </span>~<span class="symbol">idx</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span>~<span class="symbol">ret</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/areduce" title="Reduces an expression across an array a, using an index named idx,
  and return value named ret, initialized to init, setting ret to the 
  evaluation of expr at each step, returning ret.">areduce</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Reduces an expression across an array a, using an index named idx,
  and return value named ret, initialized to init, setting ret to the 
  evaluation of expr at each step, returning ret."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">idx</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">init</span><span class="whitespace"> </span><span class="symbol">expr</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">a#</span><span class="whitespace"> </span>~<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">l#</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alength" title="Returns the length of the Java array. Works on arrays of all
  types.">alength</a></span><span class="whitespace"> </span><span class="symbol">a#</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">loop</span><span class="whitespace">  </span><span>[~<span class="symbol">idx</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span>~<span class="symbol">ret</span><span class="whitespace"> </span>~<span class="symbol">init</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span>~<span class="symbol">idx</span><span class="whitespace"> </span><span class="symbol">l#</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unchecked-inc-int" title="Returns a number one greater than x, an int.
  Note - uses a primitive operator subject to overflow.">unchecked-inc-int</a></span><span class="whitespace"> </span>~<span class="symbol">idx</span>)</span><span class="whitespace"> </span>~<span class="symbol">expr</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span>~<span class="symbol">ret</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/float-array" title="Creates an array of floats">float-array</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates an array of floats"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">float_array</span><span class="whitespace"> </span>~<span class="unknown">@args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">1</span><span class="whitespace"> </span><span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">float_array</span><span class="whitespace"> </span><span class="symbol">size-or-seq</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">float_array</span><span class="whitespace"> </span><span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean-array" title="Creates an array of booleans">boolean-array</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates an array of booleans"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">boolean_array</span><span class="whitespace"> </span>~<span class="unknown">@args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">1</span><span class="whitespace"> </span><span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">boolean_array</span><span class="whitespace"> </span><span class="symbol">size-or-seq</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">boolean_array</span><span class="whitespace"> </span><span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/byte-array" title="Creates an array of bytes">byte-array</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates an array of bytes"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">byte_array</span><span class="whitespace"> </span>~<span class="unknown">@args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">1</span><span class="whitespace"> </span><span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">byte_array</span><span class="whitespace"> </span><span class="symbol">size-or-seq</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">byte_array</span><span class="whitespace"> </span><span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/char-array" title="Creates an array of chars">char-array</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates an array of chars"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">char_array</span><span class="whitespace"> </span>~<span class="unknown">@args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">1</span><span class="whitespace"> </span><span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">char_array</span><span class="whitespace"> </span><span class="symbol">size-or-seq</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">char_array</span><span class="whitespace"> </span><span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/short-array" title="Creates an array of shorts">short-array</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates an array of shorts"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">short_array</span><span class="whitespace"> </span>~<span class="unknown">@args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">1</span><span class="whitespace"> </span><span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">short_array</span><span class="whitespace"> </span><span class="symbol">size-or-seq</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">short_array</span><span class="whitespace"> </span><span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/double-array" title="Creates an array of doubles">double-array</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates an array of doubles"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">double_array</span><span class="whitespace"> </span>~<span class="unknown">@args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">1</span><span class="whitespace"> </span><span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">double_array</span><span class="whitespace"> </span><span class="symbol">size-or-seq</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">double_array</span><span class="whitespace"> </span><span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/object-array" title="Creates an array of objects">object-array</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates an array of objects"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">arg</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span class="symbol">object_array</span><span class="whitespace"> </span>~<span class="symbol">arg</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">1</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.RT</span><span class="whitespace"> </span><span class="symbol">object_array</span><span class="whitespace"> </span><span class="symbol">size-or-seq</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int-array" title="Creates an array of ints">int-array</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates an array of ints"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">int_array</span><span class="whitespace"> </span>~<span class="unknown">@args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">1</span><span class="whitespace"> </span><span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">int_array</span><span class="whitespace"> </span><span class="symbol">size-or-seq</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">int_array</span><span class="whitespace"> </span><span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long-array" title="Creates an array of longs">long-array</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates an array of longs"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:inline</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">long_array</span><span class="whitespace"> </span>~<span class="unknown">@args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:inline-arities</span><span class="whitespace"> </span><span>#{<span class="unknown">1</span><span class="whitespace"> </span><span class="unknown">2</span>}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">long_array</span><span class="whitespace"> </span><span class="symbol">size-or-seq</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="symbol">long_array</span><span class="whitespace"> </span><span class="symbol">size</span><span class="whitespace"> </span><span class="symbol">init-val-or-seq</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/definline" title="Experimental - like defmacro, except defines a named function whose
  body is the expansion, calls to which may be expanded inline as if
  it were a macro. Cannot be used with variadic (&amp;) args.">definline</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/booleans" title="Casts to boolean[]">booleans</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Casts to boolean[]"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">xs</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/booleans" title="Casts to boolean[]">booleans</a></span><span class="whitespace"> </span>~<span class="symbol">xs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/definline" title="Experimental - like defmacro, except defines a named function whose
  body is the expansion, calls to which may be expanded inline as if
  it were a macro. Cannot be used with variadic (&amp;) args.">definline</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bytes" title="Casts to bytes[]">bytes</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Casts to bytes[]"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">xs</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bytes" title="Casts to bytes[]">bytes</a></span><span class="whitespace"> </span>~<span class="symbol">xs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/definline" title="Experimental - like defmacro, except defines a named function whose
  body is the expansion, calls to which may be expanded inline as if
  it were a macro. Cannot be used with variadic (&amp;) args.">definline</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chars" title="Casts to chars[]">chars</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Casts to chars[]"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">xs</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chars" title="Casts to chars[]">chars</a></span><span class="whitespace"> </span>~<span class="symbol">xs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/definline" title="Experimental - like defmacro, except defines a named function whose
  body is the expansion, calls to which may be expanded inline as if
  it were a macro. Cannot be used with variadic (&amp;) args.">definline</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/shorts" title="Casts to shorts[]">shorts</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Casts to shorts[]"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">xs</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/shorts" title="Casts to shorts[]">shorts</a></span><span class="whitespace"> </span>~<span class="symbol">xs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/definline" title="Experimental - like defmacro, except defines a named function whose
  body is the expansion, calls to which may be expanded inline as if
  it were a macro. Cannot be used with variadic (&amp;) args.">definline</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/floats" title="Casts to float[]">floats</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Casts to float[]"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">xs</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/floats" title="Casts to float[]">floats</a></span><span class="whitespace"> </span>~<span class="symbol">xs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/definline" title="Experimental - like defmacro, except defines a named function whose
  body is the expansion, calls to which may be expanded inline as if
  it were a macro. Cannot be used with variadic (&amp;) args.">definline</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ints" title="Casts to int[]">ints</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Casts to int[]"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">xs</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ints" title="Casts to int[]">ints</a></span><span class="whitespace"> </span>~<span class="symbol">xs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/definline" title="Experimental - like defmacro, except defines a named function whose
  body is the expansion, calls to which may be expanded inline as if
  it were a macro. Cannot be used with variadic (&amp;) args.">definline</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/doubles" title="Casts to double[]">doubles</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Casts to double[]"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">xs</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/doubles" title="Casts to double[]">doubles</a></span><span class="whitespace"> </span>~<span class="symbol">xs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/definline" title="Experimental - like defmacro, except defines a named function whose
  body is the expansion, calls to which may be expanded inline as if
  it were a macro. Cannot be used with variadic (&amp;) args.">definline</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/longs" title="Casts to long[]">longs</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Casts to long[]"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">xs</span>]</span><span class="whitespace"> </span>`<span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Numbers</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/longs" title="Casts to long[]">longs</a></span><span class="whitespace"> </span>~<span class="symbol">xs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/import" title="import-list =&gt; (package-symbol class-name-symbols*)

  For each name in class-name-symbols, adds a mapping from name to the
  class named by package.name to the current namespace. Use :import in the ns
  macro in preference to calling this directly.">import</a></span><span class="whitespace"> </span><span>'<span>(<span class="symbol">java.util.concurrent</span><span class="whitespace"> </span><span class="symbol">BlockingQueue</span><span class="whitespace"> </span><span class="symbol">LinkedBlockingQueue</span>)</span></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seque" title="Creates a queued seq on another (presumably lazy) seq s. The queued
  seq will produce a concrete seq in the background, and can get up to
  n items ahead of the consumer. n-or-q can be an integer n buffer
  size, or an instance of java.util.concurrent BlockingQueue. Note
  that reading from a seque can block if the reader gets ahead of the
  producer.">seque</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates a queued seq on another (presumably lazy) seq s. The queued
  seq will produce a concrete seq in the background, and can get up to
  n items ahead of the consumer. n-or-q can be an integer n buffer
  size, or an instance of java.util.concurrent BlockingQueue. Note
  that reading from a seque can block if the reader gets ahead of the
  producer."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">s</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seque" title="Creates a queued seq on another (presumably lazy) seq s. The queued
  seq will produce a concrete seq in the background, and can get up to
  n items ahead of the consumer. n-or-q can be an integer n buffer
  size, or an instance of java.util.concurrent BlockingQueue. Note
  that reading from a seque can block if the reader gets ahead of the
  producer.">seque</a></span><span class="whitespace"> </span><span class="unknown">100</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n-or-q</span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>^<span class="symbol">BlockingQueue</span></span><span class="whitespace"> </span><span class="symbol">q</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="symbol">BlockingQueue</span><span class="whitespace"> </span><span class="symbol">n-or-q</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span class="symbol">n-or-q</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="symbol">LinkedBlockingQueue.</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span class="symbol">n-or-q</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">NIL</span><span class="whitespace"> </span><span>(<span class="symbol">Object.</span>)</span><span class="whitespace"> </span><span class="comment">;nil sentinel since LBQ doesn't support nils</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">agt</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/agent" title="Creates and returns an agent with an initial value of state and
  zero or more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :error-handler handler-fn

  :error-mode mode-keyword

  If metadata-map is supplied, it will become the metadata on the
  agent. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.  handler-fn is called if an
  action throws an exception or if validate-fn rejects a new state --
  see set-error-handler! for details.  The mode-keyword may be either
  :continue (the default if an error-handler is given) or :fail (the
  default if no error-handler is given) -- see set-error-mode! for
  details.">agent</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace"> </span><span class="comment">; never start with nil; that signifies we've already put eos</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">log-error</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">q</span><span class="whitespace"> </span><span class="symbol">e</span>]</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">.offer</span><span class="whitespace"> </span><span class="symbol">q</span><span class="whitespace"> </span><span class="symbol">q</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span class="symbol">e</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span class="symbol">e</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">fill</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Exception</span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span class="comment">; we failed to .offer an error earlier</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="symbol">log-error</span><span class="whitespace"> </span><span class="symbol">q</span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="macro">try</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">xs</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">s</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace">
</span><span class="whitespace">                          </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">.offer</span><span class="whitespace"> </span><span class="symbol">q</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="symbol">NIL</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">xs</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">                          </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace"> </span><span>(<span class="java-class">.offer</span><span class="whitespace"> </span><span class="symbol">q</span><span class="whitespace"> </span><span class="symbol">q</span>)</span><span class="whitespace"> </span><span class="comment">; q itself is eos sentinel</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>()</span>)</span>)</span>)</span><span class="whitespace"> </span><span class="comment">; empty seq, not nil, so we know to put eos next time</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="symbol">catch</span><span class="whitespace"> </span><span class="java-class">Exception</span><span class="whitespace"> </span><span class="symbol">e</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="symbol">log-error</span><span class="whitespace"> </span><span class="symbol">q</span><span class="whitespace"> </span><span class="symbol">e</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">drain</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">drain</span><span class="whitespace"> </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="java-class">.take</span><span class="whitespace"> </span><span class="symbol">q</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identical?" title="Tests if 2 arguments are the same object">identical?</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">q</span>)</span><span class="whitespace"> </span><span class="comment">;q itself is eos sentinel</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="macro">do</span><span class="whitespace"> </span><span class="unknown">@agt</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span><span class="whitespace">  </span><span class="comment">;touch agent just to propagate errors</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="macro">do</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/send-off" title="Dispatch a potentially blocking action to an agent. Returns the
  agent immediately. Subsequently, in a separate thread, the state of
  the agent will be set to the value of:

  (apply action-fn state-of-agent args)">send-off</a></span><span class="whitespace"> </span><span class="symbol">agt</span><span class="whitespace"> </span><span class="symbol">fill</span>)</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/release-pending-sends" title="Normally, actions sent directly or indirectly during another action
  are held until the action completes (changes the agent&apos;s
  state). This function can be used to dispatch any pending sent
  actions immediately. This has no impact on actions sent during a
  transaction, which are still held until commit. If no action is
  occurring, does nothing. Returns the number of actions dispatched.">release-pending-sends</a></span>)</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identical?" title="Tests if 2 arguments are the same object">identical?</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">NIL</span>)</span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">drain</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/send-off" title="Dispatch a potentially blocking action to an agent. Returns the
  agent immediately. Subsequently, in a separate thread, the state of
  the agent will be set to the value of:

  (apply action-fn state-of-agent args)">send-off</a></span><span class="whitespace"> </span><span class="symbol">agt</span><span class="whitespace"> </span><span class="symbol">fill</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">drain</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class?" title="Returns true if x is an instance of Class">class?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x is an instance of Class"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">Class</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">is-annotation?</span><span class="whitespace"> </span><span>[<span class="symbol">c</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class?" title="Returns true if x is an instance of Class">class?</a></span><span class="whitespace"> </span><span class="symbol">c</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="java-class">.isAssignableFrom</span><span class="whitespace"> </span><span class="java-class">java.lang.annotation.Annotation</span><span class="whitespace"> </span><span class="symbol">c</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">is-runtime-annotation?</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">Class</span></span><span class="whitespace"> </span><span class="symbol">c</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">is-annotation?</span><span class="whitespace"> </span><span class="symbol">c</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">java.lang.annotation.Retention</span></span><span class="whitespace"> </span><span class="symbol">r</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="java-class">.getAnnotation</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="java-class">java.lang.annotation.Retention</span>)</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span>(<span class="java-class">.value</span><span class="whitespace"> </span><span class="symbol">r</span>)</span><span class="whitespace"> </span><span class="java-class">java.lang.annotation.RetentionPolicy/<span class="symbol">RUNTIME</span></span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">descriptor</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">Class</span></span><span class="whitespace"> </span><span class="symbol">c</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.asm.Type/<span class="symbol">getDescriptor</span></span><span class="whitespace"> </span><span class="symbol">c</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/declare" title="defs the supplied var names with no bindings, useful for making forward declarations.">declare</a></span><span class="whitespace"> </span><span class="symbol">process-annotation</span>)</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">add-annotation</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">clojure.asm.AnnotationVisitor</span></span><span class="whitespace"> </span><span class="symbol">av</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">v</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace"> </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">avec</span><span class="whitespace"> </span><span>(<span class="java-class">.visitArray</span><span class="whitespace"> </span><span class="symbol">av</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/doseq" title="Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by &quot;for&quot;.  Does not retain
  the head of the sequence. Returns nil.">doseq</a></span><span class="whitespace"> </span><span>[<span class="symbol">vval</span><span class="whitespace"> </span><span class="symbol">v</span>]</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="symbol">add-annotation</span><span class="whitespace"> </span><span class="symbol">avec</span><span class="whitespace"> </span><span class="string">"value"</span><span class="whitespace"> </span><span class="symbol">vval</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="java-class">.visitEnd</span><span class="whitespace"> </span><span class="symbol">avec</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace"> </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ev</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/eval" title="Evaluates the form data structure (not text!) and returns the result.">eval</a></span><span class="whitespace"> </span><span class="symbol">v</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">java.lang.Enum</span><span class="whitespace"> </span><span class="symbol">ev</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="java-class">.visitEnum</span><span class="whitespace"> </span><span class="symbol">av</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span>(<span class="symbol">descriptor</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class" title="Returns the Class of x">class</a></span><span class="whitespace"> </span><span class="symbol">ev</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="symbol">ev</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class?" title="Returns true if x is an instance of Class">class?</a></span><span class="whitespace"> </span><span class="symbol">ev</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">.visit</span><span class="whitespace"> </span><span class="symbol">av</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span>(<span class="java-class">clojure.asm.Type/<span class="symbol">getType</span></span><span class="whitespace"> </span><span class="symbol">ev</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="keyword">:else</span><span class="whitespace"> </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Unsupported annotation value: "</span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span class="string">" of class "</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class" title="Returns the Class of x">class</a></span><span class="whitespace"> </span><span class="symbol">ev</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace"> </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">nested</span><span class="whitespace"> </span><span class="symbol">nv</span>]</span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="symbol">c</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/resolve" title="same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &amp;env symbol)">resolve</a></span><span class="whitespace"> </span><span class="symbol">nested</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="symbol">nav</span><span class="whitespace"> </span><span>(<span class="java-class">.visitAnnotation</span><span class="whitespace"> </span><span class="symbol">av</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span>(<span class="symbol">descriptor</span><span class="whitespace"> </span><span class="symbol">c</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="symbol">process-annotation</span><span class="whitespace"> </span><span class="symbol">nav</span><span class="whitespace"> </span><span class="symbol">nv</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="java-class">.visitEnd</span><span class="whitespace"> </span><span class="symbol">nav</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:else</span><span class="whitespace"> </span><span>(<span class="java-class">.visit</span><span class="whitespace"> </span><span class="symbol">av</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">process-annotation</span><span class="whitespace"> </span><span>[<span class="symbol">av</span><span class="whitespace"> </span><span class="symbol">v</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/doseq" title="Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by &quot;for&quot;.  Does not retain
  the head of the sequence. Returns nil.">doseq</a></span><span class="whitespace"> </span><span>[<span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">v</span>]</span><span class="whitespace"> </span><span class="symbol">v</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">add-annotation</span><span class="whitespace"> </span><span class="symbol">av</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">add-annotation</span><span class="whitespace"> </span><span class="symbol">av</span><span class="whitespace"> </span><span class="string">"value"</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">add-annotations</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">visitor</span><span class="whitespace"> </span><span class="symbol">m</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">add-annotations</span><span class="whitespace"> </span><span class="symbol">visitor</span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">visitor</span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">i</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/doseq" title="Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by &quot;for&quot;.  Does not retain
  the head of the sequence. Returns nil.">doseq</a></span><span class="whitespace"> </span><span>[<span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">v</span>]</span><span class="whitespace"> </span><span class="symbol">m</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">c</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/resolve" title="same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &amp;env symbol)">resolve</a></span><span class="whitespace"> </span><span class="symbol">k</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="symbol">is-annotation?</span><span class="whitespace"> </span><span class="symbol">c</span>)</span><span class="whitespace">
</span><span class="whitespace">                                        </span><span class="comment">;this is known duck/reflective as no common base of ASM Visitors</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">av</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">i</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="java-class">.visitParameterAnnotation</span><span class="whitespace"> </span><span class="symbol">visitor</span><span class="whitespace"> </span><span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="symbol">descriptor</span><span class="whitespace"> </span><span class="symbol">c</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                                                   </span><span>(<span class="symbol">is-runtime-annotation?</span><span class="whitespace"> </span><span class="symbol">c</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="java-class">.visitAnnotation</span><span class="whitespace"> </span><span class="symbol">visitor</span><span class="whitespace"> </span><span>(<span class="symbol">descriptor</span><span class="whitespace"> </span><span class="symbol">c</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                                          </span><span>(<span class="symbol">is-runtime-annotation?</span><span class="whitespace"> </span><span class="symbol">c</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="symbol">process-annotation</span><span class="whitespace"> </span><span class="symbol">av</span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="java-class">.visitEnd</span><span class="whitespace"> </span><span class="symbol">av</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alter-var-root" title="Atomically alters the root binding of var v by applying f to its
  current value plus any args">alter-var-root</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Atomically alters the root binding of var v by applying f to its
  current value plus any args"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Var</span></span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.alterRoot</span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bound?" title="Returns true if all of the vars provided as arguments have any bound value, root or thread-local.
   Implies that deref&apos;ing the provided vars will succeed. Returns true if no vars are provided.">bound?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if all of the vars provided as arguments have any bound value, root or thread-local.
   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">vars</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span>#(<span class="java-class">.isBound</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Var</span></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">vars</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/thread-bound?" title="Returns true if all of the vars provided as arguments have thread-local bindings.
   Implies that set!&apos;ing the provided vars will succeed.  Returns true if no vars are provided.">thread-bound?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if all of the vars provided as arguments have thread-local bindings.
   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">vars</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span>#(<span class="java-class">.getThreadBinding</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Var</span></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">vars</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/make-hierarchy" title="Creates a hierarchy object for use with derive, isa? etc.">make-hierarchy</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates a hierarchy object for use with derive, isa? etc."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[]</span><span class="whitespace"> </span><span>{<span class="keyword">:parents</span><span class="whitespace"> </span><span>{}</span><span class="whitespace"> </span><span class="keyword">:descendants</span><span class="whitespace"> </span><span>{}</span><span class="whitespace"> </span><span class="keyword">:ancestors</span><span class="whitespace"> </span><span>{}</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace">
</span><span class="whitespace">     </span><span class="symbol">global-hierarchy</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/make-hierarchy" title="Creates a hierarchy object for use with derive, isa? etc.">make-hierarchy</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not-empty" title="If coll is empty, returns nil, else coll">not-empty</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"If coll is empty, returns nil, else coll"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bases" title="Returns the immediate superclass and direct interfaces of c, if any">bases</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the immediate superclass and direct interfaces of c, if any"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Class</span></span><span class="whitespace"> </span><span class="symbol">c</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span>(<span class="java-class">.getInterfaces</span><span class="whitespace"> </span><span class="symbol">c</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="java-class">.getSuperclass</span><span class="whitespace"> </span><span class="symbol">c</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">i</span>)</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/supers" title="Returns the immediate and indirect superclasses and interfaces of c, if any">supers</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the immediate and indirect superclasses and interfaces of c, if any"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Class</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class" title="Returns the Class of x">class</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bases" title="Returns the immediate superclass and direct interfaces of c, if any">bases</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class" title="Returns the Class of x">class</a></span>)</span>)</span><span class="whitespace"> </span><span class="symbol">cs</span><span class="whitespace"> </span><span class="symbol">ret</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">cs</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">c</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">cs</span>)</span><span class="whitespace"> </span><span class="symbol">bs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bases" title="Returns the immediate superclass and direct interfaces of c, if any">bases</a></span><span class="whitespace"> </span><span class="symbol">c</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="symbol">into1</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">bs</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">into1</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/disj" title="disj[oin]. Returns a new set of the same (hashed/sorted) type, that
  does not contain key(s).">disj</a></span><span class="whitespace"> </span><span class="symbol">cs</span><span class="whitespace"> </span><span class="symbol">c</span>)</span><span class="whitespace"> </span><span class="symbol">bs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not-empty" title="If coll is empty, returns nil, else coll">not-empty</a></span><span class="whitespace"> </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/isa?" title="Returns true if (= child parent), or child is directly or indirectly derived from
  parent, either via a Java type inheritance relationship or a
  relationship established via derive. h must be a hierarchy obtained
  from make-hierarchy, if not supplied defaults to the global
  hierarchy">isa?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if (= child parent), or child is directly or indirectly derived from
  parent, either via a Java type inheritance relationship or a
  relationship established via derive. h must be a hierarchy obtained
  from make-hierarchy, if not supplied defaults to the global
  hierarchy"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">child</span><span class="whitespace"> </span><span class="symbol">parent</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/isa?" title="Returns true if (= child parent), or child is directly or indirectly derived from
  parent, either via a Java type inheritance relationship or a
  relationship established via derive. h must be a hierarchy obtained
  from make-hierarchy, if not supplied defaults to the global
  hierarchy">isa?</a></span><span class="whitespace"> </span><span class="symbol">global-hierarchy</span><span class="whitespace"> </span><span class="symbol">child</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">child</span><span class="whitespace"> </span><span class="symbol">parent</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">child</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class?" title="Returns true if x is an instance of Class">class?</a></span><span class="whitespace"> </span><span class="symbol">parent</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class?" title="Returns true if x is an instance of Class">class?</a></span><span class="whitespace"> </span><span class="symbol">child</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span>^<span class="java-class">Class</span></span><span class="whitespace"> </span><span class="symbol">parent</span><span class="whitespace"> </span><span class="symbol">isAssignableFrom</span><span class="whitespace"> </span><span class="symbol">child</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span>(<span>(<span class="keyword">:ancestors</span><span class="whitespace"> </span><span class="symbol">h</span>)</span><span class="whitespace"> </span><span class="symbol">child</span>)</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class?" title="Returns true if x is an instance of Class">class?</a></span><span class="whitespace"> </span><span class="symbol">child</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some" title="Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)">some</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span>(<span>(<span class="keyword">:ancestors</span><span class="whitespace"> </span><span class="symbol">h</span>)</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/supers" title="Returns the immediate and indirect superclasses and interfaces of c, if any">supers</a></span><span class="whitespace"> </span><span class="symbol">child</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">parent</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">child</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">parent</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">child</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace"> </span><span class="symbol">i</span><span class="whitespace"> </span><span class="unknown">0</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span class="symbol">ret</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">parent</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span class="symbol">ret</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/isa?" title="Returns true if (= child parent), or child is directly or indirectly derived from
  parent, either via a Java type inheritance relationship or a
  relationship established via derive. h must be a hierarchy obtained
  from make-hierarchy, if not supplied defaults to the global
  hierarchy">isa?</a></span><span class="whitespace"> </span><span class="symbol">h</span><span class="whitespace"> </span><span>(<span class="symbol">child</span><span class="whitespace"> </span><span class="symbol">i</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">parent</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/parents" title="Returns the immediate parents of tag, either via a Java type
  inheritance relationship or a relationship established via derive. h
  must be a hierarchy obtained from make-hierarchy, if not supplied
  defaults to the global hierarchy">parents</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the immediate parents of tag, either via a Java type
  inheritance relationship or a relationship established via derive. h
  must be a hierarchy obtained from make-hierarchy, if not supplied
  defaults to the global hierarchy"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">tag</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/parents" title="Returns the immediate parents of tag, either via a Java type
  inheritance relationship or a relationship established via derive. h
  must be a hierarchy obtained from make-hierarchy, if not supplied
  defaults to the global hierarchy">parents</a></span><span class="whitespace"> </span><span class="symbol">global-hierarchy</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">tag</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not-empty" title="If coll is empty, returns nil, else coll">not-empty</a></span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">tp</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span>(<span class="keyword">:parents</span><span class="whitespace"> </span><span class="symbol">h</span>)</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class?" title="Returns true if x is an instance of Class">class?</a></span><span class="whitespace"> </span><span class="symbol">tag</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="symbol">into1</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bases" title="Returns the immediate superclass and direct interfaces of c, if any">bases</a></span><span class="whitespace"> </span><span class="symbol">tag</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">tp</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span class="symbol">tp</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ancestors" title="Returns the immediate and indirect parents of tag, either via a Java type
  inheritance relationship or a relationship established via derive. h
  must be a hierarchy obtained from make-hierarchy, if not supplied
  defaults to the global hierarchy">ancestors</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the immediate and indirect parents of tag, either via a Java type
  inheritance relationship or a relationship established via derive. h
  must be a hierarchy obtained from make-hierarchy, if not supplied
  defaults to the global hierarchy"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">tag</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ancestors" title="Returns the immediate and indirect parents of tag, either via a Java type
  inheritance relationship or a relationship established via derive. h
  must be a hierarchy obtained from make-hierarchy, if not supplied
  defaults to the global hierarchy">ancestors</a></span><span class="whitespace"> </span><span class="symbol">global-hierarchy</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">tag</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not-empty" title="If coll is empty, returns nil, else coll">not-empty</a></span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ta</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span>(<span class="keyword">:ancestors</span><span class="whitespace"> </span><span class="symbol">h</span>)</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class?" title="Returns true if x is an instance of Class">class?</a></span><span class="whitespace"> </span><span class="symbol">tag</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">superclasses</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/set" title="Returns a set of the distinct elements of coll.">set</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/supers" title="Returns the immediate and indirect superclasses and interfaces of c, if any">supers</a></span><span class="whitespace"> </span><span class="symbol">tag</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="symbol">into1</span><span class="whitespace"> </span><span class="symbol">superclasses</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">ta</span><span class="whitespace">
</span><span class="whitespace">                          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span>(<span class="keyword">:ancestors</span><span class="whitespace"> </span><span class="symbol">h</span>)</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">superclasses</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span class="symbol">ta</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/descendants" title="Returns the immediate and indirect children of tag, through a
  relationship established via derive. h must be a hierarchy obtained
  from make-hierarchy, if not supplied defaults to the global
  hierarchy. Note: does not work on Java type inheritance
  relationships.">descendants</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the immediate and indirect children of tag, through a
  relationship established via derive. h must be a hierarchy obtained
  from make-hierarchy, if not supplied defaults to the global
  hierarchy. Note: does not work on Java type inheritance
  relationships."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">tag</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/descendants" title="Returns the immediate and indirect children of tag, through a
  relationship established via derive. h must be a hierarchy obtained
  from make-hierarchy, if not supplied defaults to the global
  hierarchy. Note: does not work on Java type inheritance
  relationships.">descendants</a></span><span class="whitespace"> </span><span class="symbol">global-hierarchy</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">tag</span>]</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class?" title="Returns true if x is an instance of Class">class?</a></span><span class="whitespace"> </span><span class="symbol">tag</span>)</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">java.lang.UnsupportedOperationException.</span><span class="whitespace"> </span><span class="string">"Can't get descendants of classes"</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not-empty" title="If coll is empty, returns nil, else coll">not-empty</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span>(<span class="keyword">:descendants</span><span class="whitespace"> </span><span class="symbol">h</span>)</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/derive" title="Establishes a parent/child relationship between parent and
  tag. Parent must be a namespace-qualified symbol or keyword and
  child can be either a namespace-qualified symbol or keyword or a
  class. h must be a hierarchy obtained from make-hierarchy, if not
  supplied defaults to, and modifies, the global hierarchy.">derive</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Establishes a parent/child relationship between parent and
  tag. Parent must be a namespace-qualified symbol or keyword and
  child can be either a namespace-qualified symbol or keyword or a
  class. h must be a hierarchy obtained from make-hierarchy, if not
  supplied defaults to, and modifies, the global hierarchy."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">tag</span><span class="whitespace"> </span><span class="symbol">parent</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/assert" title="Evaluates expr and throws an exception if it does not evaluate to
  logical true.">assert</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/namespace" title="Returns the namespace String of a symbol or keyword, or nil if not present.">namespace</a></span><span class="whitespace"> </span><span class="symbol">parent</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/assert" title="Evaluates expr and throws an exception if it does not evaluate to
  logical true.">assert</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class?" title="Returns true if x is an instance of Class">class?</a></span><span class="whitespace"> </span><span class="symbol">tag</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Named</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/namespace" title="Returns the namespace String of a symbol or keyword, or nil if not present.">namespace</a></span><span class="whitespace"> </span><span class="symbol">tag</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alter-var-root" title="Atomically alters the root binding of var v by applying f to its
  current value plus any args">alter-var-root</a></span><span class="whitespace"> </span><span>#'<span class="var-ref">global-hierarchy</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/derive" title="Establishes a parent/child relationship between parent and
  tag. Parent must be a namespace-qualified symbol or keyword and
  child can be either a namespace-qualified symbol or keyword or a
  class. h must be a hierarchy obtained from make-hierarchy, if not
  supplied defaults to, and modifies, the global hierarchy.">derive</a></span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span class="symbol">parent</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/assert" title="Evaluates expr and throws an exception if it does not evaluate to
  logical true.">assert</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not=" title="Same as (not (= obj1 obj2))">not=</a></span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/assert" title="Evaluates expr and throws an exception if it does not evaluate to
  logical true.">assert</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class?" title="Returns true if x is an instance of Class">class?</a></span><span class="whitespace"> </span><span class="symbol">tag</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Named</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/assert" title="Evaluates expr and throws an exception if it does not evaluate to
  logical true.">assert</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Named</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">tp</span><span class="whitespace"> </span><span>(<span class="keyword">:parents</span><span class="whitespace"> </span><span class="symbol">h</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">td</span><span class="whitespace"> </span><span>(<span class="keyword">:descendants</span><span class="whitespace"> </span><span class="symbol">h</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">ta</span><span class="whitespace"> </span><span>(<span class="keyword">:ancestors</span><span class="whitespace"> </span><span class="symbol">h</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">tf</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">source</span><span class="whitespace"> </span><span class="symbol">sources</span><span class="whitespace"> </span><span class="symbol">target</span><span class="whitespace"> </span><span class="symbol">targets</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">k</span>]</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace">
</span><span class="whitespace">                               </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">targets</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span>#{}</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">target</span><span class="whitespace"> </span><span>(<span class="symbol">targets</span><span class="whitespace"> </span><span class="symbol">target</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">source</span><span class="whitespace"> </span><span>(<span class="symbol">sources</span><span class="whitespace"> </span><span class="symbol">source</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span>(<span class="symbol">tp</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span>(<span class="symbol">ta</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">Exception.</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/print-str" title="print to a string, returning it">print-str</a></span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span class="string">"already has"</span><span class="whitespace"> </span><span class="symbol">parent</span><span class="whitespace"> </span><span class="string">"as ancestor"</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span>(<span class="symbol">ta</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">Exception.</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/print-str" title="print to a string, returning it">print-str</a></span><span class="whitespace"> </span><span class="string">"Cyclic derivation:"</span><span class="whitespace"> </span><span class="symbol">parent</span><span class="whitespace"> </span><span class="string">"has"</span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span class="string">"as ancestor"</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>{<span class="keyword">:parents</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span>(<span class="keyword">:parents</span><span class="whitespace"> </span><span class="symbol">h</span>)</span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">tp</span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span>#{}</span>)</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="keyword">:ancestors</span><span class="whitespace"> </span><span>(<span class="symbol">tf</span><span class="whitespace"> </span><span>(<span class="keyword">:ancestors</span><span class="whitespace"> </span><span class="symbol">h</span>)</span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span class="symbol">td</span><span class="whitespace"> </span><span class="symbol">parent</span><span class="whitespace"> </span><span class="symbol">ta</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="keyword">:descendants</span><span class="whitespace"> </span><span>(<span class="symbol">tf</span><span class="whitespace"> </span><span>(<span class="keyword">:descendants</span><span class="whitespace"> </span><span class="symbol">h</span>)</span><span class="whitespace"> </span><span class="symbol">parent</span><span class="whitespace"> </span><span class="symbol">ta</span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span class="symbol">td</span>)</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="symbol">h</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/declare" title="defs the supplied var names with no bindings, useful for making forward declarations.">declare</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/flatten" title="Takes any nested combination of sequential things (lists, vectors,
  etc.) and returns their contents as a single, flat sequence.
  (flatten nil) returns an empty sequence.">flatten</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/underive" title="Removes a parent/child relationship between parent and
  tag. h must be a hierarchy obtained from make-hierarchy, if not
  supplied defaults to, and modifies, the global hierarchy.">underive</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Removes a parent/child relationship between parent and
  tag. h must be a hierarchy obtained from make-hierarchy, if not
  supplied defaults to, and modifies, the global hierarchy."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">tag</span><span class="whitespace"> </span><span class="symbol">parent</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alter-var-root" title="Atomically alters the root binding of var v by applying f to its
  current value plus any args">alter-var-root</a></span><span class="whitespace"> </span><span>#'<span class="var-ref">global-hierarchy</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/underive" title="Removes a parent/child relationship between parent and
  tag. h must be a hierarchy obtained from make-hierarchy, if not
  supplied defaults to, and modifies, the global hierarchy.">underive</a></span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span class="symbol">parent</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">parentMap</span><span class="whitespace"> </span><span>(<span class="keyword">:parents</span><span class="whitespace"> </span><span class="symbol">h</span>)</span><span class="whitespace">
</span><span class="whitespace">	  </span><span class="symbol">childsParents</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="symbol">parentMap</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span><span class="whitespace">
</span><span class="whitespace">			  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/disj" title="disj[oin]. Returns a new set of the same (hashed/sorted) type, that
  does not contain key(s).">disj</a></span><span class="whitespace"> </span><span>(<span class="symbol">parentMap</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span><span class="whitespace"> </span><span>#{}</span>)</span><span class="whitespace">
</span><span class="whitespace">	  </span><span class="symbol">newParents</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not-empty" title="If coll is empty, returns nil, else coll">not-empty</a></span><span class="whitespace"> </span><span class="symbol">childsParents</span>)</span><span class="whitespace">
</span><span class="whitespace">		       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">parentMap</span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span class="symbol">childsParents</span>)</span><span class="whitespace">
</span><span class="whitespace">		       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dissoc" title="dissoc[iate]. Returns a new map of the same (hashed/sorted) type,
  that does not contain a mapping for key(s).">dissoc</a></span><span class="whitespace"> </span><span class="symbol">parentMap</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">	  </span><span class="symbol">deriv-seq</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/flatten" title="Takes any nested combination of sequential things (lists, vectors,
  etc.) and returns their contents as a single, flat sequence.
  (flatten nil) returns an empty sequence.">flatten</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interpose" title="Returns a lazy seq of the elements of coll separated by sep.
  Returns a stateful transducer when no collection is provided.">interpose</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">				       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">newParents</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span>(<span class="symbol">parentMap</span><span class="whitespace"> </span><span class="symbol">tag</span>)</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span><span class="whitespace">
</span><span class="whitespace">	</span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/derive" title="Establishes a parent/child relationship between parent and
  tag. Parent must be a namespace-qualified symbol or keyword and
  child can be either a namespace-qualified symbol or keyword or a
  class. h must be a hierarchy obtained from make-hierarchy, if not
  supplied defaults to, and modifies, the global hierarchy.">derive</a></span><span class="whitespace"> </span><span class="symbol">%1</span><span class="whitespace"> </span><span class="symbol">%2</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/make-hierarchy" title="Creates a hierarchy object for use with derive, isa? etc.">make-hierarchy</a></span>)</span><span class="whitespace">
</span><span class="whitespace">		</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition" title="Returns a lazy sequence of lists of n items each, at offsets step
  apart. If step is not supplied, defaults to n, i.e. the partitions
  do not overlap. If a pad collection is supplied, use its elements as
  necessary to complete last partition upto n items. In case there are
  not enough padding elements, return a partition with less than n items.">partition</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span class="symbol">deriv-seq</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">	</span><span class="symbol">h</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/distinct?" title="Returns true if no two of the arguments are =">distinct?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if no two of the arguments are ="</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">Boolean</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not=" title="Same as (not (= obj1 obj2))">not=</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>#{<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>}</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">etc</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">xs</span>]</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">xs</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span class="unknown">false</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="symbol">etc</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="unknown">true</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="unknown">false</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/resultset-seq" title="Creates and returns a lazy sequence of structmaps corresponding to
  the rows in the java.sql.ResultSet rs">resultset-seq</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Creates and returns a lazy sequence of structmaps corresponding to
  the rows in the java.sql.ResultSet rs"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">java.sql.ResultSet</span></span><span class="whitespace"> </span><span class="symbol">rs</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">rsmeta</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">rs</span><span class="whitespace"> </span><span>(<span class="symbol">getMetaData</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">idxs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/range" title="Returns a lazy seq of nums from start (inclusive) to end
  (exclusive), by step, where start defaults to 0, step to 1, and end to
  infinity. When step is equal to 0, returns an infinite sequence of
  start. When start is equal to end, returns empty list.">range</a></span><span class="whitespace"> </span><span class="unknown">1</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">rsmeta</span><span class="whitespace"> </span><span>(<span class="symbol">getColumnCount</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comp" title="Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.">comp</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword" title="Returns a Keyword with the given namespace and name.  Do not use :
  in the keyword strings, it will be added automatically.">keyword</a></span><span class="whitespace"> </span><span>#(<span class="java-class">.toLowerCase</span><span class="whitespace"> </span><span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">i</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">rsmeta</span><span class="whitespace"> </span><span>(<span class="symbol">getColumnLabel</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">idxs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">check-keys</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/distinct?" title="Returns true if no two of the arguments are =">distinct?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">Exception.</span><span class="whitespace"> </span><span class="string">"ResultSet must have unique column labels"</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">row-struct</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/create-struct" title="Returns a structure basis object.">create-struct</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">row-values</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">Integer</span></span><span class="whitespace"> </span><span class="symbol">i</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">rs</span><span class="whitespace"> </span><span>(<span class="symbol">getObject</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">idxs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">rows</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">thisfn</span><span class="whitespace"> </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="symbol">rs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/struct" title="Returns a new structmap instance with the keys of the
  structure-basis. vals must be supplied for basis keys in order -
  where values are not supplied they will default to nil.">struct</a></span><span class="whitespace"> </span><span class="symbol">row-struct</span><span class="whitespace"> </span><span>(<span class="symbol">row-values</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace"> </span><span>(<span class="symbol">thisfn</span>)</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">rows</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/iterator-seq" title="Returns a seq on a java.util.Iterator. Note that most collections
  providing iterators implement Iterable and thus support seq directly.
  Seqs cache values, thus iterator-seq should not be used on any
  iterator that repeatedly returns the same mutable object.">iterator-seq</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a seq on a java.util.Iterator. Note that most collections
  providing iterators implement Iterable and thus support seq directly.
  Seqs cache values, thus iterator-seq should not be used on any
  iterator that repeatedly returns the same mutable object."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">iter</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">chunkIteratorSeq</span></span><span class="whitespace"> </span><span class="symbol">iter</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/enumeration-seq" title="Returns a seq on a java.util.Enumeration">enumeration-seq</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a seq on a java.util.Enumeration"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">e</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">clojure.lang.EnumerationSeq/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">e</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/format" title="Formats a string using java.lang.String.format, see java.util.Formatter for format
  string syntax">format</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Formats a string using java.lang.String.format, see java.util.Formatter for format
  string syntax"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span>[<span class="symbol">fmt</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">String/<span class="symbol">format</span></span><span class="whitespace"> </span><span class="symbol">fmt</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/to-array" title="Returns an array of Objects containing the contents of coll, which
  can be any Collection.  Maps to java.util.Collection.toArray().">to-array</a></span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/printf" title="Prints formatted output, as per format">printf</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Prints formatted output, as per format"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">fmt</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/print" title="Prints the object(s) to the output stream that is the current value
  of *out*.  print and println produce output for human consumption.">print</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/format" title="Formats a string using java.lang.String.format, see java.util.Formatter for format
  string syntax">format</a></span><span class="whitespace"> </span><span class="symbol">fmt</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/declare" title="defs the supplied var names with no bindings, useful for making forward declarations.">declare</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/gen-class" title="When compiling, generates compiled bytecode for a class with the
  given package-qualified :name (which, as all names in these
  parameters, can be a string or symbol), and writes the .class file
  to the *compile-path* directory.  When not compiling, does
  nothing. The gen-class construct contains no implementation, as the
  implementation will be dynamically sought by the generated class in
  functions in an implementing Clojure namespace. Given a generated
  class org.mydomain.MyClass with a method named mymethod, gen-class
  will generate an implementation that looks for a function named by 
  (str prefix mymethod) (default prefix: &quot;-&quot;) in a
  Clojure namespace specified by :impl-ns
  (defaults to the current namespace). All inherited methods,
  generated methods, and init and main functions (see :methods, :init,
  and :main below) will be found similarly prefixed. By default, the
  static initializer for the generated class will attempt to load the
  Clojure support code for the class as a resource from the classpath,
  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This
  behavior can be controlled by :load-impl-ns

  Note that methods with a maximum of 18 parameters are supported.

  In all subsequent sections taking types, the primitive types can be
  referred to by their Java names (int, float etc), and classes in the
  java.lang package can be used without a package qualifier. All other
  classes must be fully qualified.

  Options should be a set of key/value pairs, all except for :name are optional:

  :name aname

  The package-qualified name of the class to be generated

  :extends aclass

  Specifies the superclass, the non-private methods of which will be
  overridden by the class. If not provided, defaults to Object.

  :implements [interface ...]

  One or more interfaces, the methods of which will be implemented by the class.

  :init name

  If supplied, names a function that will be called with the arguments
  to the constructor. Must return [ [superclass-constructor-args] state] 
  If not supplied, the constructor args are passed directly to
  the superclass constructor and the state will be nil

  :constructors {[param-types] [super-param-types], ...}

  By default, constructors are created for the generated class which
  match the signature(s) of the constructors for the superclass. This
  parameter may be used to explicitly specify constructors, each entry
  providing a mapping from a constructor signature to a superclass
  constructor signature. When you supply this, you must supply an :init
  specifier. 

  :post-init name

  If supplied, names a function that will be called with the object as
  the first argument, followed by the arguments to the constructor.
  It will be called every time an object of this class is created,
  immediately after all the inherited constructors have completed.
  Its return value is ignored.

  :methods [ [name [param-types] return-type], ...]

  The generated class automatically defines all of the non-private
  methods of its superclasses/interfaces. This parameter can be used
  to specify the signatures of additional methods of the generated
  class. Static methods can be specified with ^{:static true} in the
  signature&apos;s metadata. Do not repeat superclass/interface signatures
  here.

  :main boolean

  If supplied and true, a static public main function will be generated. It will
  pass each string of the String[] argument as a separate argument to
  a function called (str prefix main).

  :factory name

  If supplied, a (set of) public static factory function(s) will be
  created with the given name, and the same signature(s) as the
  constructor(s).
  
  :state name

  If supplied, a public final instance field with the given name will be
  created. You must supply an :init function in order to provide a
  value for the state. Note that, though final, the state can be a ref
  or agent, supporting the creation of Java objects with transactional
  or asynchronous mutation semantics.

  :exposes {protected-field-name {:get name :set name}, ...}

  Since the implementations of the methods of the generated class
  occur in Clojure functions, they have no access to the inherited
  protected fields of the superclass. This parameter can be used to
  generate public getter/setter methods exposing the protected field(s)
  for use in the implementation.

  :exposes-methods {super-method-name exposed-name, ...}

  It is sometimes necessary to call the superclass&apos; implementation of an
  overridden method.  Those methods may be exposed and referred in 
  the new method implementation by a local name.

  :prefix string

  Default: &quot;-&quot; Methods called e.g. Foo will be looked up in vars called
  prefixFoo in the implementing ns.

  :impl-ns name

  Default: the name of the current ns. Implementations of methods will be 
  looked up in this namespace.

  :load-impl-ns boolean

  Default: true. Causes the static initializer for the generated class
  to reference the load code for the implementing namespace. Should be
  true when implementing-ns is the default, false if you intend to
  load the code via some other method.">gen-class</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-loading-context">with-loading-context</a></span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">loading#</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Var</span><span class="whitespace"> </span><span>(<span class="symbol">pushThreadBindings</span><span class="whitespace"> </span><span>{<span class="java-class">clojure.lang.Compiler/<span class="symbol">LOADER</span></span><span class="whitespace">  </span><span class="whitespace">
</span><span class="whitespace">                                                 </span><span>(<span class="java-class">.getClassLoader</span><span class="whitespace"> </span><span>(<span class="java-class">.getClass</span><span class="whitespace"> </span><span>^<span class="java-class">Object</span></span><span class="whitespace"> </span><span class="symbol">loading#</span>)</span>)</span>}</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">try</span><span class="whitespace">
</span><span class="whitespace">         </span>~<span class="unknown">@body</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="symbol">finally</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="java-class">.</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Var</span><span class="whitespace"> </span><span>(<span class="symbol">popThreadBindings</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer 'clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">docstring?</span><span class="whitespace"> </span><span class="symbol">attr-map?</span><span class="whitespace"> </span><span class="symbol">references*</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">references</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">process-reference</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">kname</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span>`<span>(~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol" title="Returns a Symbol with the given namespace and name.">symbol</a></span><span class="whitespace"> </span><span class="string">"clojure.core"</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">clojure.core/name</a></span><span class="whitespace"> </span><span class="symbol">kname</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">             </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>'<span class="macro">quote</span></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">docstring</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">references</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">references</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">references</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">docstring</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">references</span>)</span><span class="whitespace"> </span><span class="symbol">references</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">docstring</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vary-meta" title="Returns an object of the same type and value as obj, with
  (apply f (meta obj) args) as its metadata.">vary-meta</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="symbol">docstring</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">metadata</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">references</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">references</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">references</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">metadata</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">references</span>)</span><span class="whitespace"> </span><span class="symbol">references</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">metadata</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vary-meta" title="Returns an object of the same type and value as obj, with
  (apply f (meta obj) args) as its metadata.">vary-meta</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/merge" title="Returns a map that consists of the rest of the maps conj-ed onto
  the first.  If a key occurs in more than one map, the mapping from
  the latter (left-to-right) will be the mapping in the result.">merge</a></span><span class="whitespace"> </span><span class="symbol">metadata</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">gen-class-clause</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filter" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">filter</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="keyword">:gen-class</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">references</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">gen-class-call</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">gen-class-clause</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list*" title="Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.">list*</a></span><span class="whitespace"> </span>`<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/gen-class" title="When compiling, generates compiled bytecode for a class with the
  given package-qualified :name (which, as all names in these
  parameters, can be a string or symbol), and writes the .class file
  to the *compile-path* directory.  When not compiling, does
  nothing. The gen-class construct contains no implementation, as the
  implementation will be dynamically sought by the generated class in
  functions in an implementing Clojure namespace. Given a generated
  class org.mydomain.MyClass with a method named mymethod, gen-class
  will generate an implementation that looks for a function named by 
  (str prefix mymethod) (default prefix: &quot;-&quot;) in a
  Clojure namespace specified by :impl-ns
  (defaults to the current namespace). All inherited methods,
  generated methods, and init and main functions (see :methods, :init,
  and :main below) will be found similarly prefixed. By default, the
  static initializer for the generated class will attempt to load the
  Clojure support code for the class as a resource from the classpath,
  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This
  behavior can be controlled by :load-impl-ns

  Note that methods with a maximum of 18 parameters are supported.

  In all subsequent sections taking types, the primitive types can be
  referred to by their Java names (int, float etc), and classes in the
  java.lang package can be used without a package qualifier. All other
  classes must be fully qualified.

  Options should be a set of key/value pairs, all except for :name are optional:

  :name aname

  The package-qualified name of the class to be generated

  :extends aclass

  Specifies the superclass, the non-private methods of which will be
  overridden by the class. If not provided, defaults to Object.

  :implements [interface ...]

  One or more interfaces, the methods of which will be implemented by the class.

  :init name

  If supplied, names a function that will be called with the arguments
  to the constructor. Must return [ [superclass-constructor-args] state] 
  If not supplied, the constructor args are passed directly to
  the superclass constructor and the state will be nil

  :constructors {[param-types] [super-param-types], ...}

  By default, constructors are created for the generated class which
  match the signature(s) of the constructors for the superclass. This
  parameter may be used to explicitly specify constructors, each entry
  providing a mapping from a constructor signature to a superclass
  constructor signature. When you supply this, you must supply an :init
  specifier. 

  :post-init name

  If supplied, names a function that will be called with the object as
  the first argument, followed by the arguments to the constructor.
  It will be called every time an object of this class is created,
  immediately after all the inherited constructors have completed.
  Its return value is ignored.

  :methods [ [name [param-types] return-type], ...]

  The generated class automatically defines all of the non-private
  methods of its superclasses/interfaces. This parameter can be used
  to specify the signatures of additional methods of the generated
  class. Static methods can be specified with ^{:static true} in the
  signature&apos;s metadata. Do not repeat superclass/interface signatures
  here.

  :main boolean

  If supplied and true, a static public main function will be generated. It will
  pass each string of the String[] argument as a separate argument to
  a function called (str prefix main).

  :factory name

  If supplied, a (set of) public static factory function(s) will be
  created with the given name, and the same signature(s) as the
  constructor(s).
  
  :state name

  If supplied, a public final instance field with the given name will be
  created. You must supply an :init function in order to provide a
  value for the state. Note that, though final, the state can be a ref
  or agent, supporting the creation of Java objects with transactional
  or asynchronous mutation semantics.

  :exposes {protected-field-name {:get name :set name}, ...}

  Since the implementations of the methods of the generated class
  occur in Clojure functions, they have no access to the inherited
  protected fields of the superclass. This parameter can be used to
  generate public getter/setter methods exposing the protected field(s)
  for use in the implementation.

  :exposes-methods {super-method-name exposed-name, ...}

  It is sometimes necessary to call the superclass&apos; implementation of an
  overridden method.  Those methods may be exposed and referred in 
  the new method implementation by a local name.

  :prefix string

  Default: &quot;-&quot; Methods called e.g. Foo will be looked up in vars called
  prefixFoo in the implementing ns.

  :impl-ns name

  Default: the name of the current ns. Implementations of methods will be 
  looked up in this namespace.

  :load-impl-ns boolean

  Default: true. Causes the static initializer for the generated class
  to reference the load code for the implementing namespace. Should be
  true when implementing-ns is the default, false if you intend to
  load the code via some other method.">gen-class</a></span><span class="whitespace"> </span><span class="keyword">:name</span><span class="whitespace"> </span><span>(<span class="java-class">.replace</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span class="string">-</span><span class="whitespace"> </span><span class="string">_</span>)</span><span class="whitespace"> </span><span class="keyword">:impl-ns</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="keyword">:main</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">gen-class-clause</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">references</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/remove" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns false. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">remove</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="keyword">:gen-class</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">references</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="comment">;ns-effect (clojure.core/in-ns name)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">name-metadata</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">do</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/in-ns" title="Sets *ns* to the namespace named by the symbol, creating it if needed.">clojure.core/in-ns</a></span><span class="whitespace"> </span><span>'~</span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace">
</span><span class="whitespace">       </span>~<span class="unparsed">@</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">name-metadata</span><span class="whitespace">
</span><span class="whitespace">           </span>`<span>(<span>(<span class="java-class">.resetMeta</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Namespace/<span class="symbol">find</span></span><span class="whitespace"> </span><span>'~</span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span>~<span class="symbol">name-metadata</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-loading-context">with-loading-context</a></span><span class="whitespace">
</span><span class="whitespace">        </span>~<span class="unparsed">@</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">gen-class-call</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span class="symbol">gen-class-call</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span>~<span class="unparsed">@</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not=" title="Same as (not (= obj1 obj2))">not=</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span>'<span class="symbol">clojure.core</span></span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not-any?" title="Returns false if (pred x) is logical true for any x in coll,
  else true.">not-any?</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="keyword">:refer-clojure</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">references</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span>`<span>(<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/refer" title="refers to all public vars of ns, subject to filters.
  filters can include at most one each of:

  :exclude list-of-symbols
  :only list-of-symbols
  :rename map-of-fromsymbol-tosymbol

  For each public interned var in the namespace named by the symbol,
  adds a mapping from the name of the var to the var to the current
  namespace.  Throws an exception if name is already mapped to
  something else in the current namespace. Filters can be used to
  select a subset, via inclusion or exclusion, or to provide a mapping
  to a symbol different from the var&apos;s name, in order to prevent
  clashes. Use :use in the ns macro in preference to calling this directly.">clojure.core/refer</a></span><span class="whitespace"> </span><span>'~</span><span>'<span class="symbol">clojure.core</span></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">process-reference</span><span class="whitespace"> </span><span class="symbol">references</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">.equals</span><span class="whitespace"> </span><span>'~</span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span>'<span class="symbol">clojure.core</span></span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">          </span><span class="unparsed">nil</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">do</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/dosync" title="Runs the exprs (in an implicit do) in a transaction that encompasses
  exprs and any nested calls.  Starts a transaction if none is already
  running on this thread. Any uncaught exception will abort the
  transaction and flow out of dosync. The exprs may be run more than
  once, but any effects on Refs will be atomic.">dosync</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/commute" title="Must be called in a transaction. Sets the in-transaction-value of
  ref to:

  (apply fun in-transaction-value-of-ref args)

  and returns the in-transaction-value of ref.

  At the commit point of the transaction, sets the value of ref to be:

  (apply fun most-recently-committed-value-of-ref args)

  Thus fun should be commutative, or, failing that, you must accept
  last-one-in-wins behavior.  commute allows for more concurrency than
  ref-set.">commute</a></span><span class="whitespace"> </span><span class="unknown">@#'*loaded-libs*</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>'~</span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>)</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/refer-clojure" title="Same as (refer &apos;clojure.core &lt;filters&gt;)">refer-clojure</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Same as (refer 'clojure.core <filters>)"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">filters</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/refer" title="refers to all public vars of ns, subject to filters.
  filters can include at most one each of:

  :exclude list-of-symbols
  :only list-of-symbols
  :rename map-of-fromsymbol-tosymbol

  For each public interned var in the namespace named by the symbol,
  adds a mapping from the name of the var to the var to the current
  namespace.  Throws an exception if name is already mapped to
  something else in the current namespace. Filters can be used to
  select a subset, via inclusion or exclusion, or to provide a mapping
  to a symbol different from the var&apos;s name, in order to prevent
  clashes. Use :use in the ns macro in preference to calling this directly.">clojure.core/refer</a></span><span class="whitespace"> </span><span>'~</span><span>'<span class="symbol">clojure.core</span></span><span class="whitespace"> </span>~<span class="unknown">@filters</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defonce" title="defs name to have the root value of the expr iff the named var has no root value,
  else expr is unevaluated">defonce</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"defs name to have the root value of the expr iff the named var has no root value,
  else expr is unevaluated"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">expr</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">v#</span><span class="whitespace"> </span><span>(<span class="macro">def</span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace"> </span><span>(<span class="java-class">.hasRoot</span><span class="whitespace"> </span><span class="symbol">v#</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">def</span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span>~<span class="symbol">expr</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;; require/use/load, contributed by Stephen C. Gilardi ;;;;;;;;;;;;;;;;;;</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defonce" title="defs name to have the root value of the expr iff the named var has no root value,
  else expr is unevaluated">defonce</a></span><span class="whitespace"> </span><span>^<span class="keyword">:dynamic</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"A ref to a sorted set of symbols representing loaded libs"</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="symbol">*loaded-libs*</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sorted-set" title="Returns a new sorted set with supplied keys.  Any equal keys are
  handled as if by repeated uses of conj.">sorted-set</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defonce" title="defs name to have the root value of the expr iff the named var has no root value,
  else expr is unevaluated">defonce</a></span><span class="whitespace"> </span><span>^<span class="keyword">:dynamic</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"A stack of paths currently being loaded by this thread"</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="symbol">*pending-paths*</span><span class="whitespace"> </span><span>()</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defonce" title="defs name to have the root value of the expr iff the named var has no root value,
  else expr is unevaluated">defonce</a></span><span class="whitespace"> </span><span>^<span class="keyword">:dynamic</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span>^<span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace"> </span><span class="keyword">:doc</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="string">"True while a verbose load is pending"</span>}</span></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="symbol">*loading-verbosely*</span><span class="whitespace"> </span><span class="unknown">false</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">throw-if</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Throws a CompilerException with a message if pred is true"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">fmt</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">pred</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">message</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/format" title="Formats a string using java.lang.String.format, see java.util.Formatter for format
  string syntax">format</a></span><span class="whitespace"> </span><span class="symbol">fmt</span><span class="whitespace"> </span><span class="symbol">args</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">exception</span><span class="whitespace"> </span><span>(<span class="symbol">Exception.</span><span class="whitespace"> </span><span class="symbol">message</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">raw-trace</span><span class="whitespace"> </span><span>(<span class="java-class">.getStackTrace</span><span class="whitespace"> </span><span class="symbol">exception</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">boring?</span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not=" title="Same as (not (= obj1 obj2))">not=</a></span><span class="whitespace"> </span><span>(<span class="java-class">.getMethodName</span><span class="whitespace"> </span><span>^<span class="java-class">StackTraceElement</span></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="string">"doInvoke"</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">trace</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/into-array" title="Returns an array with components set to the values in aseq. The array&apos;s
  component type is type if provided, or the type of the first value in
  aseq if present, or Object. All values in aseq must be compatible with
  the component type. Class objects for the primitive types can be obtained
  using, e.g., Integer/TYPE.">into-array</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop" title="Returns a lazy sequence of all but the first n items in coll.
  Returns a stateful transducer when no collection is provided.">drop</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop-while" title="Returns a lazy sequence of the items in coll starting from the
  first item for which (pred item) returns logical false.  Returns a
  stateful transducer when no collection is provided.">drop-while</a></span><span class="whitespace"> </span><span class="symbol">boring?</span><span class="whitespace"> </span><span class="symbol">raw-trace</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="java-class">.setStackTrace</span><span class="whitespace"> </span><span class="symbol">exception</span><span class="whitespace"> </span><span class="symbol">trace</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">clojure.lang.Compiler$CompilerException.</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*file*" title="The path of the file being evaluated, as a String.

  When there is no file, e.g. in the REPL, the value is not defined.">*file*</a></span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="java-class">.deref</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Compiler/<span class="symbol">LINE</span></span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="java-class">.deref</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Compiler/<span class="symbol">COLUMN</span></span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">exception</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">libspec?</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x is a libspec"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">prependss</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Prepends a symbol or a seq to coll"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/concat" title="Returns a lazy seq representing the concatenation of the elements in the supplied colls.">concat</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">root-resource</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the root directory path for a lib"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">String</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">lib</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">/</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="java-class">..</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">lib</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/replace" title="Given a map of replacement pairs and a vector/collection, returns a
  vector/seq with any elements = a key in smap replaced with the
  corresponding val in smap.  Returns a transducer when no collection
  is provided.">replace</a></span><span class="whitespace"> </span><span class="string">-</span><span class="whitespace"> </span><span class="string">_</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/replace" title="Given a map of replacement pairs and a vector/collection, returns a
  vector/seq with any elements = a key in smap replaced with the
  corresponding val in smap.  Returns a transducer when no collection
  is provided.">replace</a></span><span class="whitespace"> </span><span class="string">.</span><span class="whitespace"> </span><span class="string">/</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">root-directory</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the root resource path for a lib"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">lib</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">d</span><span class="whitespace"> </span><span>(<span class="symbol">root-resource</span><span class="whitespace"> </span><span class="symbol">lib</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/subs" title="Returns the substring of s beginning at start inclusive, and ending
  at end (defaults to length of string), exclusive.">subs</a></span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span>(<span class="java-class">.lastIndexOf</span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span class="string">"/"</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span class="keyword">:declared</span></span><span class="whitespace"> </span><span>^<span class="keyword">:redef</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">load-one</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Loads a lib given its name. If need-ns, ensures that the associated
  namespace exists after loading. If require, records the load so any
  duplicate loads can be skipped."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">lib</span><span class="whitespace"> </span><span class="symbol">need-ns</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/require" title="Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.

  Libs

  A &apos;lib&apos; is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib&apos;s
  name also locates its root directory within classpath using Java&apos;s
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.

  &apos;require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol &apos;x.y.z; it has the root directory
  &lt;classpath&gt;/x/y/, and its root resource is &lt;classpath&gt;/x/y/z.clj. The root
  resource should contain code to create the lib&apos;s namespace (usually by using
  the ns macro) and load any additional lib resources.

  Libspecs

  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.

  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib&apos;s namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.

  Prefix Lists

  It&apos;s common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing the
  prefix, the names that remain must not contain any periods.

  Flags

  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer

  Example:

  The following would load the libraries clojure.zip and clojure.set
  abbreviated as &apos;s&apos;.

  (require &apos;(clojure zip [set :as s]))">require</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span><span class="whitespace"> </span><span>(<span class="symbol">root-resource</span><span class="whitespace"> </span><span class="symbol">lib</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">throw-if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span class="symbol">need-ns</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find-ns" title="Returns the namespace named by the symbol or nil if it doesn&apos;t exist.">find-ns</a></span><span class="whitespace"> </span><span class="symbol">lib</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="string">"namespace '%s' not found after loading '%s'"</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">lib</span><span class="whitespace"> </span><span>(<span class="symbol">root-resource</span><span class="whitespace"> </span><span class="symbol">lib</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/require" title="Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.

  Libs

  A &apos;lib&apos; is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib&apos;s
  name also locates its root directory within classpath using Java&apos;s
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.

  &apos;require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol &apos;x.y.z; it has the root directory
  &lt;classpath&gt;/x/y/, and its root resource is &lt;classpath&gt;/x/y/z.clj. The root
  resource should contain code to create the lib&apos;s namespace (usually by using
  the ns macro) and load any additional lib resources.

  Libspecs

  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.

  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib&apos;s namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.

  Prefix Lists

  It&apos;s common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing the
  prefix, the names that remain must not contain any periods.

  Flags

  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer

  Example:

  The following would load the libraries clojure.zip and clojure.set
  abbreviated as &apos;s&apos;.

  (require &apos;(clojure zip [set :as s]))">require</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/dosync" title="Runs the exprs (in an implicit do) in a transaction that encompasses
  exprs and any nested calls.  Starts a transaction if none is already
  running on this thread. Any uncaught exception will abort the
  transaction and flow out of dosync. The exprs may be run more than
  once, but any effects on Refs will be atomic.">dosync</a></span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/commute" title="Must be called in a transaction. Sets the in-transaction-value of
  ref to:

  (apply fun in-transaction-value-of-ref args)

  and returns the in-transaction-value of ref.

  At the commit point of the transaction, sets the value of ref to be:

  (apply fun most-recently-committed-value-of-ref args)

  Thus fun should be commutative, or, failing that, you must accept
  last-one-in-wins behavior.  commute allows for more concurrency than
  ref-set.">commute</a></span><span class="whitespace"> </span><span class="symbol">*loaded-libs*</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">lib</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">load-all</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Loads a lib given its name and forces a load of any libs it directly or
  indirectly loads. If need-ns, ensures that the associated namespace
  exists after loading. If require, records the load so any duplicate loads
  can be skipped."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">lib</span><span class="whitespace"> </span><span class="symbol">need-ns</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/require" title="Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.

  Libs

  A &apos;lib&apos; is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib&apos;s
  name also locates its root directory within classpath using Java&apos;s
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.

  &apos;require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol &apos;x.y.z; it has the root directory
  &lt;classpath&gt;/x/y/, and its root resource is &lt;classpath&gt;/x/y/z.clj. The root
  resource should contain code to create the lib&apos;s namespace (usually by using
  the ns macro) and load any additional lib resources.

  Libspecs

  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.

  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib&apos;s namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.

  Prefix Lists

  It&apos;s common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing the
  prefix, the names that remain must not contain any periods.

  Flags

  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer

  Example:

  The following would load the libraries clojure.zip and clojure.set
  abbreviated as &apos;s&apos;.

  (require &apos;(clojure zip [set :as s]))">require</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/dosync" title="Runs the exprs (in an implicit do) in a transaction that encompasses
  exprs and any nested calls.  Starts a transaction if none is already
  running on this thread. Any uncaught exception will abort the
  transaction and flow out of dosync. The exprs may be run more than
  once, but any effects on Refs will be atomic.">dosync</a></span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/commute" title="Must be called in a transaction. Sets the in-transaction-value of
  ref to:

  (apply fun in-transaction-value-of-ref args)

  and returns the in-transaction-value of ref.

  At the commit point of the transaction, sets the value of ref to be:

  (apply fun most-recently-committed-value-of-ref args)

  Thus fun should be commutative, or, failing that, you must accept
  last-one-in-wins behavior.  commute allows for more concurrency than
  ref-set.">commute</a></span><span class="whitespace"> </span><span class="symbol">*loaded-libs*</span><span class="whitespace"> </span><span>#(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">%1</span><span class="whitespace"> </span><span class="symbol">%2</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/binding" title="binding =&gt; var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.">binding</a></span><span class="whitespace"> </span><span>[<span class="symbol">*loaded-libs*</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ref" title="Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.">ref</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sorted-set" title="Returns a new sorted set with supplied keys.  Any equal keys are
  handled as if by repeated uses of conj.">sorted-set</a></span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="symbol">load-one</span><span class="whitespace"> </span><span class="symbol">lib</span><span class="whitespace"> </span><span class="symbol">need-ns</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/require" title="Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.

  Libs

  A &apos;lib&apos; is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib&apos;s
  name also locates its root directory within classpath using Java&apos;s
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.

  &apos;require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol &apos;x.y.z; it has the root directory
  &lt;classpath&gt;/x/y/, and its root resource is &lt;classpath&gt;/x/y/z.clj. The root
  resource should contain code to create the lib&apos;s namespace (usually by using
  the ns macro) and load any additional lib resources.

  Libspecs

  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.

  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib&apos;s namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.

  Prefix Lists

  It&apos;s common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing the
  prefix, the names that remain must not contain any periods.

  Flags

  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer

  Example:

  The following would load the libraries clojure.zip and clojure.set
  abbreviated as &apos;s&apos;.

  (require &apos;(clojure zip [set :as s]))">require</a></span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="unknown">@*loaded-libs*</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">load-lib</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Loads a lib with options"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">prefix</span><span class="whitespace"> </span><span class="symbol">lib</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">options</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">throw-if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span class="symbol">prefix</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace"> </span><span>(<span class="java-class">.indexOf</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">lib</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span class="string">.</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="string">"Found lib name '%s' containing period with prefix '%s'.  lib names inside prefix lists must not contain periods"</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">lib</span>)</span><span class="whitespace"> </span><span class="symbol">prefix</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">lib</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">prefix</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol" title="Returns a Symbol with the given namespace and name.">symbol</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="symbol">prefix</span><span class="whitespace"> </span><span class="string">.</span><span class="whitespace"> </span><span class="symbol">lib</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">lib</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">opts</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/hash-map" title="keyval =&gt; key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.">hash-map</a></span><span class="whitespace"> </span><span class="symbol">options</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span class="symbol">as</span><span class="whitespace"> </span><span class="symbol">reload</span><span class="whitespace"> </span><span class="symbol">reload-all</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/require" title="Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.

  Libs

  A &apos;lib&apos; is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib&apos;s
  name also locates its root directory within classpath using Java&apos;s
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.

  &apos;require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol &apos;x.y.z; it has the root directory
  &lt;classpath&gt;/x/y/, and its root resource is &lt;classpath&gt;/x/y/z.clj. The root
  resource should contain code to create the lib&apos;s namespace (usually by using
  the ns macro) and load any additional lib resources.

  Libspecs

  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.

  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib&apos;s namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.

  Prefix Lists

  It&apos;s common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing the
  prefix, the names that remain must not contain any periods.

  Flags

  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer

  Example:

  The following would load the libraries clojure.zip and clojure.set
  abbreviated as &apos;s&apos;.

  (require &apos;(clojure zip [set :as s]))">require</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/use" title="Like &apos;require, but also refers to each lib&apos;s namespace using
  clojure.core/refer. Use :use in the ns macro in preference to calling
  this directly.

  &apos;use accepts additional options in libspecs: :exclude, :only, :rename.
  The arguments and semantics for :exclude, :only, and :rename are the same
  as those documented for clojure.core/refer.">use</a></span><span class="whitespace"> </span><span class="symbol">verbose</span>]</span>}</span><span class="whitespace"> </span><span class="symbol">opts</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">loaded</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span class="unknown">@*loaded-libs*</span><span class="whitespace"> </span><span class="symbol">lib</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace"> </span><span class="symbol">reload-all</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">load-all</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span class="symbol">reload</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/require" title="Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.

  Libs

  A &apos;lib&apos; is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib&apos;s
  name also locates its root directory within classpath using Java&apos;s
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.

  &apos;require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol &apos;x.y.z; it has the root directory
  &lt;classpath&gt;/x/y/, and its root resource is &lt;classpath&gt;/x/y/z.clj. The root
  resource should contain code to create the lib&apos;s namespace (usually by using
  the ns macro) and load any additional lib resources.

  Libspecs

  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.

  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib&apos;s namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.

  Prefix Lists

  It&apos;s common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing the
  prefix, the names that remain must not contain any periods.

  Flags

  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer

  Example:

  The following would load the libraries clojure.zip and clojure.set
  abbreviated as &apos;s&apos;.

  (require &apos;(clojure zip [set :as s]))">require</a></span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span class="symbol">loaded</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">load-one</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">need-ns</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span class="symbol">as</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/use" title="Like &apos;require, but also refers to each lib&apos;s namespace using
  clojure.core/refer. Use :use in the ns macro in preference to calling
  this directly.

  &apos;use accepts additional options in libspecs: :exclude, :only, :rename.
  The arguments and semantics for :exclude, :only, and :rename are the same
  as those documented for clojure.core/refer.">use</a></span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">filter-opts</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/select-keys" title="Returns a map containing only those entries in map whose key is in keys">select-keys</a></span><span class="whitespace"> </span><span class="symbol">opts</span><span class="whitespace"> </span><span>'<span>(<span class="keyword">:exclude</span><span class="whitespace"> </span><span class="keyword">:only</span><span class="whitespace"> </span><span class="keyword">:rename</span><span class="whitespace"> </span><span class="keyword">:refer</span>)</span></span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">undefined-on-entry</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find-ns" title="Returns the namespace named by the symbol or nil if it doesn&apos;t exist.">find-ns</a></span><span class="whitespace"> </span><span class="symbol">lib</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/binding" title="binding =&gt; var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.">binding</a></span><span class="whitespace"> </span><span>[<span class="symbol">*loading-verbosely*</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span class="symbol">*loading-verbosely*</span><span class="whitespace"> </span><span class="symbol">verbose</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">try</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span><span class="whitespace"> </span><span class="symbol">lib</span><span class="whitespace"> </span><span class="symbol">need-ns</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/require" title="Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.

  Libs

  A &apos;lib&apos; is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib&apos;s
  name also locates its root directory within classpath using Java&apos;s
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.

  &apos;require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol &apos;x.y.z; it has the root directory
  &lt;classpath&gt;/x/y/, and its root resource is &lt;classpath&gt;/x/y/z.clj. The root
  resource should contain code to create the lib&apos;s namespace (usually by using
  the ns macro) and load any additional lib resources.

  Libspecs

  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.

  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib&apos;s namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.

  Prefix Lists

  It&apos;s common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing the
  prefix, the names that remain must not contain any periods.

  Flags

  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer

  Example:

  The following would load the libraries clojure.zip and clojure.set
  abbreviated as &apos;s&apos;.

  (require &apos;(clojure zip [set :as s]))">require</a></span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="symbol">catch</span><span class="whitespace"> </span><span class="java-class">Exception</span><span class="whitespace"> </span><span class="symbol">e</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">undefined-on-entry</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/remove-ns" title="Removes the namespace named by the symbol. Use with caution.
  Cannot be used to remove the clojure namespace.">remove-ns</a></span><span class="whitespace"> </span><span class="symbol">lib</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span class="symbol">e</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="symbol">throw-if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span class="symbol">need-ns</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find-ns" title="Returns the namespace named by the symbol or nil if it doesn&apos;t exist.">find-ns</a></span><span class="whitespace"> </span><span class="symbol">lib</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="string">"namespace '%s' not found"</span><span class="whitespace"> </span><span class="symbol">lib</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span class="symbol">need-ns</span><span class="whitespace"> </span><span class="symbol">*loading-verbosely*</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/printf" title="Prints formatted output, as per format">printf</a></span><span class="whitespace"> </span><span class="string">"(clojure.core/in-ns '%s)\n"</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-name" title="Returns the name of the namespace, a symbol.">ns-name</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*ns*" title="A clojure.lang.Namespace object representing the current namespace.">*ns*</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">as</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">*loading-verbosely*</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/printf" title="Prints formatted output, as per format">printf</a></span><span class="whitespace"> </span><span class="string">"(clojure.core/alias '%s '%s)\n"</span><span class="whitespace"> </span><span class="symbol">as</span><span class="whitespace"> </span><span class="symbol">lib</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alias" title="Add an alias in the current namespace to another
  namespace. Arguments are two symbols: the alias to be used, and
  the symbolic name of the target namespace. Use :as in the ns macro in preference
  to calling this directly.">alias</a></span><span class="whitespace"> </span><span class="symbol">as</span><span class="whitespace"> </span><span class="symbol">lib</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/use" title="Like &apos;require, but also refers to each lib&apos;s namespace using
  clojure.core/refer. Use :use in the ns macro in preference to calling
  this directly.

  &apos;use accepts additional options in libspecs: :exclude, :only, :rename.
  The arguments and semantics for :exclude, :only, and :rename are the same
  as those documented for clojure.core/refer.">use</a></span><span class="whitespace"> </span><span>(<span class="keyword">:refer</span><span class="whitespace"> </span><span class="symbol">filter-opts</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">*loading-verbosely*</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/printf" title="Prints formatted output, as per format">printf</a></span><span class="whitespace"> </span><span class="string">"(clojure.core/refer '%s"</span><span class="whitespace"> </span><span class="symbol">lib</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/doseq" title="Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by &quot;for&quot;.  Does not retain
  the head of the sequence. Returns nil.">doseq</a></span><span class="whitespace"> </span><span>[<span class="symbol">opt</span><span class="whitespace"> </span><span class="symbol">filter-opts</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/printf" title="Prints formatted output, as per format">printf</a></span><span class="whitespace"> </span><span class="string">" %s '%s"</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/key" title="Returns the key of the map entry.">key</a></span><span class="whitespace"> </span><span class="symbol">opt</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/print-str" title="print to a string, returning it">print-str</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">opt</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/printf" title="Prints formatted output, as per format">printf</a></span><span class="whitespace"> </span><span class="string">")\n"</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/refer" title="refers to all public vars of ns, subject to filters.
  filters can include at most one each of:

  :exclude list-of-symbols
  :only list-of-symbols
  :rename map-of-fromsymbol-tosymbol

  For each public interned var in the namespace named by the symbol,
  adds a mapping from the name of the var to the var to the current
  namespace.  Throws an exception if name is already mapped to
  something else in the current namespace. Filters can be used to
  select a subset, via inclusion or exclusion, or to provide a mapping
  to a symbol different from the var&apos;s name, in order to prevent
  clashes. Use :use in the ns macro in preference to calling this directly.">refer</a></span><span class="whitespace"> </span><span class="symbol">lib</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/mapcat" title="Returns the result of applying concat to the result of applying map
  to f and colls.  Thus function f should return a collection. Returns
  a transducer when no collections are provided">mapcat</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">filter-opts</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">load-libs</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Loads libs, interpreting libspecs, prefix lists, and flags for
  forwarding to load-lib"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">flags</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filter" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">filter</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace"> </span><span class="symbol">args</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">opts</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interleave" title="Returns a lazy seq of the first item in each coll, then the second etc.">interleave</a></span><span class="whitespace"> </span><span class="symbol">flags</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/repeat" title="Returns a lazy (infinite!, or length n if supplied) sequence of xs.">repeat</a></span><span class="whitespace"> </span><span class="unknown">true</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">args</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filter" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">filter</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/complement" title="Takes a fn f and returns a fn that takes the same arguments as f,
  has the same effects, if any, and returns the opposite truth value.">complement</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span>)</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="comment">; check for unsupported options</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">supported</span><span class="whitespace"> </span><span>#{<span class="keyword">:as</span><span class="whitespace"> </span><span class="keyword">:reload</span><span class="whitespace"> </span><span class="keyword">:reload-all</span><span class="whitespace"> </span><span class="keyword">:require</span><span class="whitespace"> </span><span class="keyword">:use</span><span class="whitespace"> </span><span class="keyword">:verbose</span><span class="whitespace"> </span><span class="keyword">:refer</span>}</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">unsupported</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/remove" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns false. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">remove</a></span><span class="whitespace"> </span><span class="symbol">supported</span><span class="whitespace"> </span><span class="symbol">flags</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">throw-if</span><span class="whitespace"> </span><span class="symbol">unsupported</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Unsupported option(s) supplied: "</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interpose" title="Returns a lazy seq of the elements of coll separated by sep.
  Returns a stateful transducer when no collection is provided.">interpose</a></span><span class="whitespace"> </span><span class="string">,</span><span class="whitespace"> </span><span class="symbol">unsupported</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="comment">; check a load target was specified</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">throw-if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace"> </span><span class="string">"Nothing specified to load"</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/doseq" title="Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by &quot;for&quot;.  Does not retain
  the head of the sequence. Returns nil.">doseq</a></span><span class="whitespace"> </span><span>[<span class="symbol">arg</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="symbol">libspec?</span><span class="whitespace"> </span><span class="symbol">arg</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">load-lib</span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace"> </span><span>(<span class="symbol">prependss</span><span class="whitespace"> </span><span class="symbol">arg</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">prefix</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span class="symbol">arg</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="symbol">throw-if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">prefix</span>)</span><span class="whitespace"> </span><span class="string">"prefix cannot be nil"</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/doseq" title="Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by &quot;for&quot;.  Does not retain
  the head of the sequence. Returns nil.">doseq</a></span><span class="whitespace"> </span><span>[<span class="symbol">arg</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">load-lib</span><span class="whitespace"> </span><span class="symbol">prefix</span><span class="whitespace"> </span><span>(<span class="symbol">prependss</span><span class="whitespace"> </span><span class="symbol">arg</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">check-cyclic-dependency</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Detects and rejects non-trivial cyclic load dependencies. The
  exception message shows the dependency chain with the cycle
  highlighted. Ignores the trivial case of a file attempting to load
  itself because that can occur when a gen-class'd class loads its
  implementation."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">path</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some" title="Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)">some</a></span><span class="whitespace"> </span><span>#{<span class="symbol">path</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">*pending-paths*</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">pending</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">path</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"[ "</span><span class="whitespace"> </span><span class="symbol">%</span><span class="whitespace"> </span><span class="string">" ]"</span>)</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">path</span><span class="whitespace"> </span><span class="symbol">*pending-paths*</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">chain</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interpose" title="Returns a lazy seq of the elements of coll separated by sep.
  Returns a stateful transducer when no collection is provided.">interpose</a></span><span class="whitespace"> </span><span class="string">"->"</span><span class="whitespace"> </span><span class="symbol">pending</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">throw-if</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace"> </span><span class="string">"Cyclic load dependency: %s"</span><span class="whitespace"> </span><span class="symbol">chain</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;; Public</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/require" title="Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.

  Libs

  A &apos;lib&apos; is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib&apos;s
  name also locates its root directory within classpath using Java&apos;s
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.

  &apos;require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol &apos;x.y.z; it has the root directory
  &lt;classpath&gt;/x/y/, and its root resource is &lt;classpath&gt;/x/y/z.clj. The root
  resource should contain code to create the lib&apos;s namespace (usually by using
  the ns macro) and load any additional lib resources.

  Libspecs

  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.

  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib&apos;s namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.

  Prefix Lists

  It&apos;s common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing the
  prefix, the names that remain must not contain any periods.

  Flags

  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer

  Example:

  The following would load the libraries clojure.zip and clojure.set
  abbreviated as &apos;s&apos;.

  (require &apos;(clojure zip [set :as s]))">require</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.

  Libs

  A 'lib' is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib's
  name also locates its root directory within classpath using Java's
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.

  'require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol 'x.y.z; it has the root directory
  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root
  resource should contain code to create the lib's namespace (usually by using
  the ns macro) and load any additional lib resources.

  Libspecs

  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.

  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib's namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.

  Prefix Lists

  It's common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing the
  prefix, the names that remain must not contain any periods.

  Flags

  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer

  Example:

  The following would load the libraries clojure.zip and clojure.set
  abbreviated as 's'.

  (require '(clojure zip [set :as s]))"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">load-libs</span><span class="whitespace"> </span><span class="keyword">:require</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/use" title="Like &apos;require, but also refers to each lib&apos;s namespace using
  clojure.core/refer. Use :use in the ns macro in preference to calling
  this directly.

  &apos;use accepts additional options in libspecs: :exclude, :only, :rename.
  The arguments and semantics for :exclude, :only, and :rename are the same
  as those documented for clojure.core/refer.">use</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Like 'require, but also refers to each lib's namespace using
  clojure.core/refer. Use :use in the ns macro in preference to calling
  this directly.

  'use accepts additional options in libspecs: :exclude, :only, :rename.
  The arguments and semantics for :exclude, :only, and :rename are the same
  as those documented for clojure.core/refer."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">load-libs</span><span class="whitespace"> </span><span class="keyword">:require</span><span class="whitespace"> </span><span class="keyword">:use</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/loaded-libs" title="Returns a sorted set of symbols naming the currently loaded libs">loaded-libs</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a sorted set of symbols naming the currently loaded libs"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[]</span><span class="whitespace"> </span><span class="unknown">@*loaded-libs*</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:redef</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">paths</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/doseq" title="Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by &quot;for&quot;.  Does not retain
  the head of the sequence. Returns nil.">doseq</a></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">path</span><span class="whitespace"> </span><span class="symbol">paths</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">path</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">.startsWith</span><span class="whitespace"> </span><span class="symbol">path</span><span class="whitespace"> </span><span class="string">"/"</span>)</span><span class="whitespace">
</span><span class="whitespace">                          </span><span class="symbol">path</span><span class="whitespace">
</span><span class="whitespace">                          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span>(<span class="symbol">root-directory</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-name" title="Returns the name of the namespace, a symbol.">ns-name</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*ns*" title="A clojure.lang.Namespace object representing the current namespace.">*ns*</a></span>)</span>)</span><span class="whitespace"> </span><span class="string">/</span><span class="whitespace"> </span><span class="symbol">path</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">*loading-verbosely*</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/printf" title="Prints formatted output, as per format">printf</a></span><span class="whitespace"> </span><span class="string">"(clojure.core/load \"%s\")\n"</span><span class="whitespace"> </span><span class="symbol">path</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/flush" title="Flushes the output stream that is the current value of
  *out*">flush</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">check-cyclic-dependency</span><span class="whitespace"> </span><span class="symbol">path</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">path</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">*pending-paths*</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/binding" title="binding =&gt; var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.">binding</a></span><span class="whitespace"> </span><span>[<span class="symbol">*pending-paths*</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">*pending-paths*</span><span class="whitespace"> </span><span class="symbol">path</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">load</span></span><span class="whitespace"> </span><span>(<span class="java-class">.substring</span><span class="whitespace"> </span><span class="symbol">path</span><span class="whitespace"> </span><span class="unknown">1</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/compile" title="Compiles the namespace named by the symbol lib into a set of
  classfiles. The source for the lib must be in a proper
  classpath-relative directory. The output files will go into the
  directory specified by *compile-path*, and that directory too must
  be in the classpath.">compile</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Compiles the namespace named by the symbol lib into a set of
  classfiles. The source for the lib must be in a proper
  classpath-relative directory. The output files will go into the
  directory specified by *compile-path*, and that directory too must
  be in the classpath."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">lib</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/binding" title="binding =&gt; var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.">binding</a></span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*compile-files*" title="Set to true when compiling files, false otherwise.">*compile-files*</a></span><span class="whitespace"> </span><span class="unknown">true</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">load-one</span><span class="whitespace"> </span><span class="symbol">lib</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace"> </span><span class="unknown">true</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="symbol">lib</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;;;; nested associative ops ;;;;;;;;;;;</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get-in" title="Returns the value in a nested associative structure,
  where ks is a sequence of keys. Returns nil if the key
  is not present, or the not-found value if supplied.">get-in</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns the value in a nested associative structure,
  where ks is a sequence of keys. Returns nil if the key
  is not present, or the not-found value if supplied."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">ks</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">ks</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">ks</span><span class="whitespace"> </span><span class="symbol">not-found</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">sentinel</span><span class="whitespace"> </span><span>(<span class="symbol">Object.</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">ks</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">ks</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span><span class="whitespace"> </span><span class="symbol">sentinel</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identical?" title="Tests if 2 arguments are the same object">identical?</a></span><span class="whitespace"> </span><span class="symbol">sentinel</span><span class="whitespace"> </span><span class="symbol">m</span>)</span><span class="whitespace">
</span><span class="whitespace">             </span><span class="symbol">not-found</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">sentinel</span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">m</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc-in" title="Associates a value in a nested associative structure, where ks is a
  sequence of keys and v is the new value and returns a new nested structure.
  If any levels do not exist, hash-maps will be created.">assoc-in</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Associates a value in a nested associative structure, where ks is a
  sequence of keys and v is the new value and returns a new nested structure.
  If any levels do not exist, hash-maps will be created."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">ks</span>]</span><span class="whitespace"> </span><span class="symbol">v</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">ks</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc-in" title="Associates a value in a nested associative structure, where ks is a
  sequence of keys and v is the new value and returns a new nested structure.
  If any levels do not exist, hash-maps will be created.">assoc-in</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace"> </span><span class="symbol">ks</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/update-in" title="&apos;Updates&apos; a value in a nested associative structure, where ks is a
  sequence of keys and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  nested structure.  If any levels do not exist, hash-maps will be
  created.">update-in</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"'Updates' a value in a nested associative structure, where ks is a
  sequence of keys and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  nested structure.  If any levels do not exist, hash-maps will be
  created."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">m</span><span class="whitespace"> </span><span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">ks</span>]</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="symbol">ks</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/update-in" title="&apos;Updates&apos; a value in a nested associative structure, where ks is a
  sequence of keys and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  nested structure.  If any levels do not exist, hash-maps will be
  created.">update-in</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace"> </span><span class="symbol">ks</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/update" title="&apos;Updates&apos; a value in an associative structure, where k is a
  key and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  structure.  If the key does not exist, nil is passed as the old value.">update</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"'Updates' a value in an associative structure, where k is a
  key and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  structure.  If the key does not exist, nil is passed as the old value."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">f</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/empty?" title="Returns true if coll has no items - same as (not (seq coll)).
  Please use the idiom (seq x) rather than (not (empty? x))">empty?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if coll has no items - same as (not (seq coll)).
  Please use the idiom (seq x) rather than (not (empty? x))"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/coll?" title="Returns true if x implements IPersistentCollection">coll?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x implements IPersistentCollection"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IPersistentCollection</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list?" title="Returns true if x implements IPersistentList">list?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x implements IPersistentList"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IPersistentList</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ifn?" title="Returns true if x implements IFn. Note that many data structures
  (e.g. sets and maps) implement IFn">ifn?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x implements IFn. Note that many data structures
  (e.g. sets and maps) implement IFn"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IFn</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/fn?" title="Returns true if x implements Fn, i.e. is an object created via fn.">fn?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x implements Fn, i.e. is an object created via fn."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Fn</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/associative?" title="Returns true if coll implements Associative">associative?</a></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="string">"Returns true if coll implements Associative"</span><span class="whitespace">
</span><span class="whitespace"> </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Associative</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sequential?" title="Returns true if coll implements Sequential">sequential?</a></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="string">"Returns true if coll implements Sequential"</span><span class="whitespace">
</span><span class="whitespace"> </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Sequential</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sorted?" title="Returns true if coll implements Sorted">sorted?</a></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="string">"Returns true if coll implements Sorted"</span><span class="whitespace">
</span><span class="whitespace"> </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Sorted</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/counted?" title="Returns true if coll implements count in constant time">counted?</a></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="string">"Returns true if coll implements count in constant time"</span><span class="whitespace">
</span><span class="whitespace"> </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Counted</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reversible?" title="Returns true if coll implements Reversible">reversible?</a></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="string">"Returns true if coll implements Reversible"</span><span class="whitespace">
</span><span class="whitespace"> </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.Reversible</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span class="keyword">:dynamic</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"bound in a repl thread to the most recent value printed"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*1" title="bound in a repl thread to the most recent value printed">*1</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span class="keyword">:dynamic</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"bound in a repl thread to the second most recent value printed"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*2" title="bound in a repl thread to the second most recent value printed">*2</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span class="keyword">:dynamic</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"bound in a repl thread to the third most recent value printed"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*3" title="bound in a repl thread to the third most recent value printed">*3</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span class="keyword">:dynamic</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"bound in a repl thread to the most recent exception caught by the repl"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*e" title="bound in a repl thread to the most recent exception caught by the repl">*e</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/trampoline" title="trampoline can be used to convert algorithms requiring mutual
  recursion without stack consumption. Calls f with supplied args, if
  any. If f returns a fn, calls that fn with no arguments, and
  continues to repeat, until the return value is not a fn, then
  returns that non-fn value. Note that if you want to return a fn as a
  final value, you must wrap it in some data structure and unpack it
  after trampoline returns.">trampoline</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"trampoline can be used to convert algorithms requiring mutual
  recursion without stack consumption. Calls f with supplied args, if
  any. If f returns a fn, calls that fn with no arguments, and
  continues to repeat, until the return value is not a fn, then
  returns that non-fn value. Note that if you want to return a fn as a
  final value, you must wrap it in some data structure and unpack it
  after trampoline returns."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="symbol">f</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/fn?" title="Returns true if x implements Fn, i.e. is an object created via fn.">fn?</a></span><span class="whitespace"> </span><span class="symbol">ret</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span class="symbol">ret</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">ret</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/trampoline" title="trampoline can be used to convert algorithms requiring mutual
  recursion without stack consumption. Calls f with supplied args, if
  any. If f returns a fn, calls that fn with no arguments, and
  continues to repeat, until the return value is not a fn, then
  returns that non-fn value. Note that if you want to return a fn as a
  final value, you must wrap it in some data structure and unpack it
  after trampoline returns.">trampoline</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/intern" title="Finds or creates a var named by the symbol name in the namespace
  ns (which can be a symbol or a namespace), setting its root binding
  to val if supplied. The namespace must exist. The var will adopt any
  metadata from the name symbol.  Returns the var.">intern</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Finds or creates a var named by the symbol name in the namespace
  ns (which can be a symbol or a namespace), setting its root binding
  to val if supplied. The namespace must exist. The var will adopt any
  metadata from the name symbol.  Returns the var."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Symbol</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Var/<span class="symbol">intern</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/the-ns" title="If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.">the-ns</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span>(<span class="java-class">.setMeta</span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span class="symbol">v</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Var/<span class="symbol">intern</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/the-ns" title="If passed a namespace, returns it. Else, when passed a symbol,
  returns the namespace named by it, throwing an exception if not
  found.">the-ns</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span>(<span class="java-class">.setMeta</span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span class="symbol">v</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/while" title="Repeatedly executes body while test expression is true. Presumes
  some side-effect will cause test to become false/nil. Returns nil">while</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Repeatedly executes body while test expression is true. Presumes
  some side-effect will cause test to become false/nil. Returns nil"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace">
</span><span class="whitespace">       </span>~<span class="unknown">@body</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">recur</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/memoize" title="Returns a memoized version of a referentially transparent function. The
  memoized version of the function keeps a cache of the mapping from arguments
  to results and, when calls with the same arguments are repeated often, has
  higher performance at the expense of higher memory use.">memoize</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a memoized version of a referentially transparent function. The
  memoized version of the function keeps a cache of the mapping from arguments
  to results and, when calls with the same arguments are repeated often, has
  higher performance at the expense of higher memory use."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">f</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">mem</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span>{}</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">e</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find" title="Returns the map entry for key, or nil if key not present.">find</a></span><span class="whitespace"> </span><span class="unknown">@mem</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">e</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/swap!" title="Atomically swaps the value of atom to be:
  (apply f current-value-of-atom args). Note that f may be called
  multiple times, and thus should be free of side effects.  Returns
  the value that was swapped in.">swap!</a></span><span class="whitespace"> </span><span class="symbol">mem</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">args</span><span class="whitespace"> </span><span class="symbol">ret</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/condp" title="Takes a binary predicate, an expression, and a set of clauses.
  Each clause can take the form of either:

  test-expr result-expr

  test-expr :&gt;&gt; result-fn

  Note :&gt;&gt; is an ordinary keyword.

  For each clause, (pred test-expr expr) is evaluated. If it returns
  logical true, the clause is a match. If a binary clause matches, the
  result-expr is returned, if a ternary clause matches, its result-fn,
  which must be a unary function, is called with the result of the
  predicate as its argument, the result of that call being the return
  value of condp. A single default expression can follow the clauses,
  and its value will be returned if no clause matches. If no default
  expression is provided and no clause matches, an
  IllegalArgumentException is thrown.">condp</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a binary predicate, an expression, and a set of clauses.
  Each clause can take the form of either:

  test-expr result-expr

  test-expr :>> result-fn

  Note :>> is an ordinary keyword.

  For each clause, (pred test-expr expr) is evaluated. If it returns
  logical true, the clause is a match. If a binary clause matches, the
  result-expr is returned, if a ternary clause matches, its result-fn,
  which must be a unary function, is called with the result of the
  predicate as its argument, the result of that call being the return
  value of condp. A single default expression can follow the clauses,
  and its value will be returned if no clause matches. If no default
  expression is provided and no clause matches, an
  IllegalArgumentException is thrown."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">expr</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">clauses</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">gpred</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"pred__"</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">gexpr</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span><span class="whitespace"> </span><span class="string">"expr__"</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">emit</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">emit</span><span class="whitespace"> </span><span>[<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">expr</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>[<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">clause</span>]</span><span class="whitespace"> </span><span class="symbol">more</span>]</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/split-at" title="Returns a vector of [(take n coll) (drop n coll)]">split-at</a></span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="keyword">:>></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span><span class="whitespace"> </span><span class="unknown">3</span><span class="whitespace"> </span><span class="unknown">2</span>)</span><span class="whitespace"> </span><span class="symbol">args</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span class="symbol">n</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">clause</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace"> </span>`<span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"No matching clause: "</span><span class="whitespace"> </span>~<span class="symbol">expr</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="unknown">1</span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span class="symbol">n</span>)</span><span class="whitespace"> </span>`<span>(<span class="macro">if</span><span class="whitespace"> </span><span>(~<span class="symbol">pred</span><span class="whitespace"> </span>~<span class="symbol">a</span><span class="whitespace"> </span>~<span class="symbol">expr</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span>~<span class="symbol">b</span><span class="whitespace">
</span><span class="whitespace">                             </span>~<span>(<span class="symbol">emit</span><span class="whitespace"> </span><span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">expr</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="keyword">:else</span><span class="whitespace"> </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">p#</span><span class="whitespace"> </span><span>(~<span class="symbol">pred</span><span class="whitespace"> </span>~<span class="symbol">a</span><span class="whitespace"> </span>~<span class="symbol">expr</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(~<span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">p#</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span>~<span>(<span class="symbol">emit</span><span class="whitespace"> </span><span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">expr</span><span class="whitespace"> </span><span class="symbol">more</span>)</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">gpred</span><span class="whitespace"> </span>~<span class="symbol">pred</span><span class="whitespace">
</span><span class="whitespace">           </span>~<span class="symbol">gexpr</span><span class="whitespace"> </span>~<span class="symbol">expr</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span>~<span>(<span class="symbol">emit</span><span class="whitespace"> </span><span class="symbol">gpred</span><span class="whitespace"> </span><span class="symbol">gexpr</span><span class="whitespace"> </span><span class="symbol">clauses</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; var documentation ;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alter-meta!" title="Atomically sets the metadata for a namespace/var/ref/agent/atom to be:

  (apply f its-current-meta args)

  f must be free of side-effects">alter-meta!</a></span><span class="whitespace"> </span><span>#'<span class="var-ref">*agent*</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>)</span><span class="whitespace">
</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alter-meta!" title="Atomically sets the metadata for a namespace/var/ref/agent/atom to be:

  (apply f its-current-meta args)

  f must be free of side-effects">alter-meta!</a></span><span class="whitespace"> </span><span>#'<span class="var-ref">in-ns</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>)</span><span class="whitespace">
</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alter-meta!" title="Atomically sets the metadata for a namespace/var/ref/agent/atom to be:

  (apply f its-current-meta args)

  f must be free of side-effects">alter-meta!</a></span><span class="whitespace"> </span><span>#'<span class="var-ref">load-file</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span>{<span class="keyword">:private</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">docstring</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alter-meta!" title="Atomically sets the metadata for a namespace/var/ref/agent/atom to be:

  (apply f its-current-meta args)

  f must be free of side-effects">alter-meta!</a></span><span class="whitespace"> </span><span>(<span class="macro">var</span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/merge" title="Returns a map that consists of the rest of the maps conj-ed onto
  the first.  If a key occurs in more than one map, the mapping from
  the latter (left-to-right) will be the mapping in the result.">merge</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="keyword">:doc</span><span class="whitespace"> </span>~<span class="symbol">docstring</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*file*" title="The path of the file being evaluated, as a String.

  When there is no file, e.g. in the REPL, the value is not defined.">*file*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"The path of the file being evaluated, as a String.

  When there is no file, e.g. in the REPL, the value is not defined."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*command-line-args*" title="A sequence of the supplied command line arguments, or nil if
  none were supplied">*command-line-args*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"A sequence of the supplied command line arguments, or nil if
  none were supplied"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*warn-on-reflection*" title="When set to true, the compiler will emit warnings when reflection is
  needed to resolve Java method calls or field accesses.

  Defaults to false.">*warn-on-reflection*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"When set to true, the compiler will emit warnings when reflection is
  needed to resolve Java method calls or field accesses.

  Defaults to false."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*compile-path*" title="Specifies the directory where &apos;compile&apos; will write out .class
  files. This directory must be in the classpath for &apos;compile&apos; to
  work.

  Defaults to &quot;classes&quot;">*compile-path*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Specifies the directory where 'compile' will write out .class
  files. This directory must be in the classpath for 'compile' to
  work.

  Defaults to \"classes\""</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*compile-files*" title="Set to true when compiling files, false otherwise.">*compile-files*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Set to true when compiling files, false otherwise."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*unchecked-math*" title="While bound to true, compilations of +, -, *, inc, dec and the
  coercions will be done without overflow checks. While bound
  to :warn-on-boxed, same behavior as true, and a warning is emitted
  when compilation uses boxed math. Default: false.">*unchecked-math*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"While bound to true, compilations of +, -, *, inc, dec and the
  coercions will be done without overflow checks. While bound
  to :warn-on-boxed, same behavior as true, and a warning is emitted
  when compilation uses boxed math. Default: false."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*compiler-options*" title="A map of keys to options.
  Note, when binding dynamically make sure to merge with previous value.
  Supported options:
  :elide-meta - a collection of metadata keys to elide during compilation.
  :disable-locals-clearing - set to true to disable clearing, useful for using a debugger
  Alpha, subject to change.">*compiler-options*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"A map of keys to options.
  Note, when binding dynamically make sure to merge with previous value.
  Supported options:
  :elide-meta - a collection of metadata keys to elide during compilation.
  :disable-locals-clearing - set to true to disable clearing, useful for using a debugger
  Alpha, subject to change."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.4"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*ns*" title="A clojure.lang.Namespace object representing the current namespace.">*ns*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"A clojure.lang.Namespace object representing the current namespace."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*in*" title="A java.io.Reader object representing standard input for read operations.

  Defaults to System/in, wrapped in a LineNumberingPushbackReader">*in*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"A java.io.Reader object representing standard input for read operations.

  Defaults to System/in, wrapped in a LineNumberingPushbackReader"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*out*" title="A java.io.Writer object representing standard output for print operations.

  Defaults to System/out, wrapped in an OutputStreamWriter">*out*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"A java.io.Writer object representing standard output for print operations.

  Defaults to System/out, wrapped in an OutputStreamWriter"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*err*" title="A java.io.Writer object representing standard error for print operations.

  Defaults to System/err, wrapped in a PrintWriter">*err*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"A java.io.Writer object representing standard error for print operations.

  Defaults to System/err, wrapped in a PrintWriter"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*flush-on-newline*" title="When set to true, output will be flushed whenever a newline is printed.

  Defaults to true.">*flush-on-newline*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"When set to true, output will be flushed whenever a newline is printed.

  Defaults to true."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*print-meta*" title="If set to logical true, when printing an object, its metadata will also
  be printed in a form that can be read back by the reader.

  Defaults to false.">*print-meta*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"If set to logical true, when printing an object, its metadata will also
  be printed in a form that can be read back by the reader.

  Defaults to false."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*print-dup*" title="When set to logical true, objects will be printed in a way that preserves
  their type when read in later.

  Defaults to false.">*print-dup*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"When set to logical true, objects will be printed in a way that preserves
  their type when read in later.

  Defaults to false."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*print-readably*" title="When set to logical false, strings and characters will be printed with
  non-alphanumeric characters converted to the appropriate escape sequences.

  Defaults to true">*print-readably*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"When set to logical false, strings and characters will be printed with
  non-alphanumeric characters converted to the appropriate escape sequences.

  Defaults to true"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*read-eval*" title="Defaults to true (or value specified by system property, see below)
  ***This setting implies that the full power of the reader is in play,
  including syntax that can cause code to execute. It should never be
  used with untrusted sources. See also: clojure.edn/read.***

  When set to logical false in the thread-local binding,
  the eval reader (#=) and record/type literal syntax are disabled in read/load.
  Example (will fail): (binding [*read-eval* false] (read-string &quot;#=(* 2 21)&quot;))

  The default binding can be controlled by the system property
  &apos;clojure.read.eval&apos; System properties can be set on the command line
  like this:

  java -Dclojure.read.eval=false ...

  The system property can also be set to &apos;unknown&apos; via
  -Dclojure.read.eval=unknown, in which case the default binding
  is :unknown and all reads will fail in contexts where *read-eval*
  has not been explicitly bound to either true or false. This setting
  can be a useful diagnostic tool to ensure that all of your reads
  occur in considered contexts. You can also accomplish this in a
  particular scope by binding *read-eval* to :unknown
  ">*read-eval*</a></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="string">"Defaults to true (or value specified by system property, see below)
  ***This setting implies that the full power of the reader is in play,
  including syntax that can cause code to execute. It should never be
  used with untrusted sources. See also: clojure.edn/read.***

  When set to logical false in the thread-local binding,
  the eval reader (#=) and record/type literal syntax are disabled in read/load.
  Example (will fail): (binding [*read-eval* false] (read-string \"#=(* 2 21)\"))

  The default binding can be controlled by the system property
  'clojure.read.eval' System properties can be set on the command line
  like this:

  java -Dclojure.read.eval=false ...

  The system property can also be set to 'unknown' via
  -Dclojure.read.eval=unknown, in which case the default binding
  is :unknown and all reads will fail in contexts where *read-eval*
  has not been explicitly bound to either true or false. This setting
  can be a useful diagnostic tool to ensure that all of your reads
  occur in considered contexts. You can also accomplish this in a
  particular scope by binding *read-eval* to :unknown
  "</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/future?" title="Returns true if x is a future">future?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if x is a future"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">java.util.concurrent.Future</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/future-done?" title="Returns true if future f is done">future-done?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if future f is done"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">java.util.concurrent.Future</span></span><span class="whitespace"> </span><span class="symbol">f</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.isDone</span><span class="whitespace"> </span><span class="symbol">f</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/letfn" title="fnspec ==&gt; (fname [params*] exprs) or (fname ([params*] exprs)+)

  Takes a vector of function specs and a body, and generates a set of
  bindings of functions to their names. All of the names are available
  in all of the definitions of the functions, as well as the body.">letfn</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)

  Takes a vector of function specs and a body, and generates a set of
  bindings of functions to their names. All of the names are available
  in all of the definitions of the functions, as well as the body."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">, </span><span class="keyword">:forms</span><span class="whitespace"> </span><span>'<span>[<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/letfn" title="fnspec ==&gt; (fname [params*] exprs) or (fname ([params*] exprs)+)

  Takes a vector of function specs and a body, and generates a set of
  bindings of functions to their names. All of the names are available
  in all of the definitions of the functions, as well as the body.">letfn</a></span><span class="whitespace"> </span><span>[<span class="symbol">fnspecs*</span>]</span><span class="whitespace"> </span><span class="symbol">exprs*</span>)</span>]</span></span><span class="whitespace">,</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:special-form</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">, </span><span class="keyword">:url</span><span class="whitespace"> </span><span class="unparsed">nil</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">fnspecs</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="symbol">letfn*</span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vec" title="Creates a new vector containing the contents of coll. Java arrays
  will be aliased and should not be modified.">vec</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interleave" title="Returns a lazy seq of the first item in each coll, then the second etc.">interleave</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fnspecs</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span>`<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">fnspecs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span>~<span class="unknown">@body</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/fnil" title="Takes a function f, and returns a function that calls f, replacing
  a nil first argument to f with the supplied value x. Higher arity
  versions can replace arguments in the second and third
  positions (y, z). Note that the function f can take any number of
  arguments, not just the one(s) being nil-patched.">fnil</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a function f, and returns a function that calls f, replacing
  a nil first argument to f with the supplied value x. Higher arity
  versions can replace arguments in the second and third
  positions (y, z). Note that the function f can take any number of
  arguments, not just the one(s) being nil-patched."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">a</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">a</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span class="symbol">b</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">ds</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">ds</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">b</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span class="symbol">c</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">ds</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">ds</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">b</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">c</span>)</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">c</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span>[<span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">ds</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">c</span>)</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">c</span>)</span><span class="whitespace"> </span><span class="symbol">ds</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;; case ;;;;;;;;;;;;;</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">shift-mask</span><span class="whitespace"> </span><span>[<span class="symbol">shift</span><span class="whitespace"> </span><span class="symbol">mask</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-shift-right" title="Bitwise shift right">bit-shift-right</a></span><span class="whitespace"> </span><span class="symbol">shift</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-and" title="Bitwise and">bit-and</a></span><span class="whitespace"> </span><span class="symbol">mask</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span class="keyword">:private</span></span><span class="whitespace"> </span><span class="symbol">max-mask-bits</span><span class="whitespace"> </span><span class="unknown">13</span>)</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span class="keyword">:private</span></span><span class="whitespace"> </span><span class="symbol">max-switch-table-size</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-shift-left" title="Bitwise shift left">bit-shift-left</a></span><span class="whitespace"> </span><span class="unknown">1</span><span class="whitespace"> </span><span class="symbol">max-mask-bits</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">maybe-min-hash</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"takes a collection of hashes and returns [shift mask] or nil if none found"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">hashes</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filter" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">filter</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">m</span>]</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/distinct?" title="Returns true if no two of the arguments are =">distinct?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="symbol">shift-mask</span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">hashes</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/for" title="List comprehension. Takes a vector of one or more
   binding-form/collection-expr pairs, each followed by zero or more
   modifiers, and yields a lazy sequence of evaluations of expr.
   Collections are iterated in a nested fashion, rightmost fastest,
   and nested coll-exprs can refer to bindings created in prior
   binding-forms.  Supported modifiers are: :let [binding-form expr ...],
   :while test, :when test.

  (take 100 (for [x (range 100000000) y (range 1000000) :while (&lt; y x)] [x y]))">for</a></span><span class="whitespace"> </span><span>[<span class="symbol">mask</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dec" title="Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec&apos;">dec</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/bit-shift-left" title="Bitwise shift left">bit-shift-left</a></span><span class="whitespace"> </span><span class="unknown">1</span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/range" title="Returns a lazy seq of nums from start (inclusive) to end
  (exclusive), by step, where start defaults to 0, step to 1, and end to
  infinity. When step is equal to 0, returns an infinite sequence of
  start. When start is equal to end, returns empty list.">range</a></span><span class="whitespace"> </span><span class="unknown">1</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">max-mask-bits</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="symbol">shift</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/range" title="Returns a lazy seq of nums from start (inclusive) to end
  (exclusive), by step, where start defaults to 0, step to 1, and end to
  infinity. When step is equal to 0, returns an infinite sequence of
  start. When start is equal to end, returns empty list.">range</a></span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span class="unknown">31</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>[<span class="symbol">shift</span><span class="whitespace"> </span><span class="symbol">mask</span>]</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">case-map</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Transforms a sequence of test constants and a corresponding sequence of then
  expressions into a sorted map to be consumed by case*. The form of the map
  entries are {(case-f test) [(test-f test) then]}."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">case-f</span><span class="whitespace"> </span><span class="symbol">test-f</span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">into1</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sorted-map" title="keyval =&gt; key val
  Returns a new sorted map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.">sorted-map</a></span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/zipmap" title="Returns a map with the keys mapped to the corresponding vals.">zipmap</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">case-f</span><span class="whitespace"> </span><span class="symbol">tests</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector" title="Creates a new vector containing the args.">vector</a></span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">test-f</span><span class="whitespace"> </span><span class="symbol">tests</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">thens</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">fits-table?</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if the collection of ints can fit within the
  max-table-switch-size, false otherwise."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ints" title="Casts to int[]">ints</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/-" title="If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Does not auto-promote
  longs, will throw on overflow. See also: -&apos;">-</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/max" title="Returns the greatest of the nums.">max</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ints" title="Casts to int[]">ints</a></span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/min" title="Returns the least of the nums.">min</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ints" title="Casts to int[]">ints</a></span>)</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">max-switch-table-size</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">prep-ints</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a sequence of int-sized test constants and a corresponding sequence of
  then expressions. Returns a tuple of [shift mask case-map switch-type] where
  case-map is a map of int case values to [test then] tuples, and switch-type
  is either :sparse or :compact."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="symbol">fits-table?</span><span class="whitespace"> </span><span class="symbol">tests</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="comment">; compact case ints, no shift-mask</span><span class="whitespace">
</span><span class="whitespace">    </span><span>[<span class="unknown">0</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span>(<span class="symbol">case-map</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>)</span><span class="whitespace"> </span><span class="keyword">:compact</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">shift</span><span class="whitespace"> </span><span class="symbol">mask</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">maybe-min-hash</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span class="symbol">tests</span>)</span>)</span><span class="whitespace"> </span><span>[<span class="unknown">0</span><span class="whitespace"> </span><span class="unknown">0</span>]</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/zero?" title="Returns true if num is zero, else false">zero?</a></span><span class="whitespace"> </span><span class="symbol">mask</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="comment">; sparse case ints, no shift-mask</span><span class="whitespace">
</span><span class="whitespace">        </span><span>[<span class="unknown">0</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span>(<span class="symbol">case-map</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>)</span><span class="whitespace"> </span><span class="keyword">:sparse</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="comment">; compact case ints, with shift-mask</span><span class="whitespace">
</span><span class="whitespace">        </span><span>[<span class="symbol">shift</span><span class="whitespace"> </span><span class="symbol">mask</span><span class="whitespace"> </span><span>(<span class="symbol">case-map</span><span class="whitespace"> </span><span>#(<span class="symbol">shift-mask</span><span class="whitespace"> </span><span class="symbol">shift</span><span class="whitespace"> </span><span class="symbol">mask</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>)</span><span class="whitespace"> </span><span class="keyword">:compact</span>]</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">merge-hash-collisions</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a case expression, default expression, and a sequence of test constants
  and a corresponding sequence of then expressions. Returns a tuple of
  [tests thens skip-check-set] where no tests have the same hash. Each set of
  input test constants with the same hash is replaced with a single test
  constant (the case int), and their respective thens are combined into:
  (condp = expr
    test-1 then-1
    ...
    test-n then-n
    default).
  The skip-check is a set of case ints for which post-switch equivalence
  checking must not be done (the cases holding the above condp thens)."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">expr-sym</span><span class="whitespace"> </span><span class="symbol">default</span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">buckets</span><span class="whitespace"> </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span>{}</span><span class="whitespace"> </span><span class="symbol">ks</span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">vs</span><span class="whitespace"> </span><span class="symbol">thens</span>]</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span class="symbol">ks</span><span class="whitespace"> </span><span class="symbol">vs</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="macro">recur</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/update" title="&apos;Updates&apos; a value in an associative structure, where k is a
  key and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  structure.  If the key does not exist, nil is passed as the old value.">update</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.Util/<span class="symbol">hash</span></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/fnil" title="Takes a function f, and returns a function that calls f, replacing
  a nil first argument to f with the supplied value x. Higher arity
  versions can replace arguments in the second and third
  positions (y, z). Note that the function f can take any number of
  arguments, not just the one(s) being nil-patched.">fnil</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>[]</span>)</span><span class="whitespace"> </span><span>[<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">vs</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ks</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">vs</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span class="symbol">m</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">assoc-multi</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">bucket</span>]</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">testexprs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/concat" title="Returns a lazy seq representing the concatenation of the elements in the supplied colls.">concat</a></span><span class="whitespace"> </span><span class="symbol">bucket</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span class="symbol">expr</span><span class="whitespace"> </span>`<span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/condp" title="Takes a binary predicate, an expression, and a set of clauses.
  Each clause can take the form of either:

  test-expr result-expr

  test-expr :&gt;&gt; result-fn

  Note :&gt;&gt; is an ordinary keyword.

  For each clause, (pred test-expr expr) is evaluated. If it returns
  logical true, the clause is a match. If a binary clause matches, the
  result-expr is returned, if a ternary clause matches, its result-fn,
  which must be a unary function, is called with the result of the
  predicate as its argument, the result of that call being the return
  value of condp. A single default expression can follow the clauses,
  and its value will be returned if no clause matches. If no default
  expression is provided and no clause matches, an
  IllegalArgumentException is thrown.">condp</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span>~<span class="symbol">expr-sym</span><span class="whitespace"> </span>~<span class="unknown">@testexprs</span><span class="whitespace"> </span>~<span class="symbol">default</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">expr</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">hmap</span><span class="whitespace"> </span><span>(<span class="symbol">reduce1</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span>[<span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">bucket</span>]</span>]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/==" title="Returns non-nil if nums all have the equivalent
  value (type-independent), otherwise false">==</a></span><span class="whitespace"> </span><span class="unknown">1</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">bucket</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ffirst" title="Same as (first (first x))">ffirst</a></span><span class="whitespace"> </span><span class="symbol">bucket</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">bucket</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="symbol">assoc-multi</span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">h</span><span class="whitespace"> </span><span class="symbol">bucket</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span>{}</span><span class="whitespace"> </span><span class="symbol">buckets</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">skip-check</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;&gt;" title="Threads the expr through the forms. Inserts x as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  last item in second form, etc.">->></a></span><span class="whitespace"> </span><span class="symbol">buckets</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filter" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">filter</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span><span class="unknown">1</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/second" title="Same as (first (next x))">second</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span>)</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="symbol">into1</span><span class="whitespace"> </span><span>#{}</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>[<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span><span class="whitespace"> </span><span class="symbol">hmap</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vals" title="Returns a sequence of the map&apos;s values, in the same order as (seq map).">vals</a></span><span class="whitespace"> </span><span class="symbol">hmap</span>)</span><span class="whitespace"> </span><span class="symbol">skip-check</span>]</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">prep-hashes</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a sequence of test constants and a corresponding sequence of then
  expressions. Returns a tuple of [shift mask case-map switch-type skip-check]
  where case-map is a map of int case values to [test then] tuples, switch-type
  is either :sparse or :compact, and skip-check is a set of case ints for which
  post-switch equivalence checking must not be done (occurs with hash
  collisions)."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">expr-sym</span><span class="whitespace"> </span><span class="symbol">default</span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">hashcode</span><span class="whitespace"> </span><span>#(<span class="java-class">clojure.lang.Util/<span class="symbol">hash</span></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">hashes</span><span class="whitespace"> </span><span>(<span class="symbol">into1</span><span class="whitespace"> </span><span>#{}</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">hashcode</span><span class="whitespace"> </span><span class="symbol">tests</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/==" title="Returns non-nil if nums all have the equivalent
  value (type-independent), otherwise false">==</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">tests</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">hashes</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="symbol">fits-table?</span><span class="whitespace"> </span><span class="symbol">hashes</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="comment">; compact case ints, no shift-mask</span><span class="whitespace">
</span><span class="whitespace">        </span><span>[<span class="unknown">0</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span>(<span class="symbol">case-map</span><span class="whitespace"> </span><span class="symbol">hashcode</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identity" title="Returns its argument.">identity</a></span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>)</span><span class="whitespace"> </span><span class="keyword">:compact</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">shift</span><span class="whitespace"> </span><span class="symbol">mask</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">maybe-min-hash</span><span class="whitespace"> </span><span class="symbol">hashes</span>)</span><span class="whitespace"> </span><span>[<span class="unknown">0</span><span class="whitespace"> </span><span class="unknown">0</span>]</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/zero?" title="Returns true if num is zero, else false">zero?</a></span><span class="whitespace"> </span><span class="symbol">mask</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="comment">; sparse case ints, no shift-mask</span><span class="whitespace">
</span><span class="whitespace">            </span><span>[<span class="unknown">0</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span>(<span class="symbol">case-map</span><span class="whitespace"> </span><span class="symbol">hashcode</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identity" title="Returns its argument.">identity</a></span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>)</span><span class="whitespace"> </span><span class="keyword">:sparse</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="comment">; compact case ints, with shift-mask</span><span class="whitespace">
</span><span class="whitespace">            </span><span>[<span class="symbol">shift</span><span class="whitespace"> </span><span class="symbol">mask</span><span class="whitespace"> </span><span>(<span class="symbol">case-map</span><span class="whitespace"> </span><span>#(<span class="symbol">shift-mask</span><span class="whitespace"> </span><span class="symbol">shift</span><span class="whitespace"> </span><span class="symbol">mask</span><span class="whitespace"> </span><span>(<span class="symbol">hashcode</span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identity" title="Returns its argument.">identity</a></span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>)</span><span class="whitespace"> </span><span class="keyword">:compact</span>]</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="comment">; resolve hash collisions and try again</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span><span class="whitespace"> </span><span class="symbol">skip-check</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">merge-hash-collisions</span><span class="whitespace"> </span><span class="symbol">expr-sym</span><span class="whitespace"> </span><span class="symbol">default</span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>[<span class="symbol">shift</span><span class="whitespace"> </span><span class="symbol">mask</span><span class="whitespace"> </span><span class="symbol">case-map</span><span class="whitespace"> </span><span class="symbol">switch-type</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">prep-hashes</span><span class="whitespace"> </span><span class="symbol">expr-sym</span><span class="whitespace"> </span><span class="symbol">default</span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">skip-check</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/zero?" title="Returns true if num is zero, else false">zero?</a></span><span class="whitespace"> </span><span class="symbol">mask</span>)</span><span class="whitespace">
</span><span class="whitespace">                         </span><span class="symbol">skip-check</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="symbol">into1</span><span class="whitespace"> </span><span>#{}</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="symbol">shift-mask</span><span class="whitespace"> </span><span class="symbol">shift</span><span class="whitespace"> </span><span class="symbol">mask</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">skip-check</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>[<span class="symbol">shift</span><span class="whitespace"> </span><span class="symbol">mask</span><span class="whitespace"> </span><span class="symbol">case-map</span><span class="whitespace"> </span><span class="symbol">switch-type</span><span class="whitespace"> </span><span class="symbol">skip-check</span>]</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/case" title="Takes an expression, and a set of clauses.

  Each clause can take the form of either:

  test-constant result-expr

  (test-constant1 ... test-constantN)  result-expr

  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.

  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type.">case</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes an expression, and a set of clauses.

  Each clause can take the form of either:

  test-constant result-expr

  (test-constant1 ... test-constantN)  result-expr

  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.

  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span>}</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">e</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">clauses</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ge</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span>)</span><span class="whitespace"> </span><span>{<span class="keyword">:tag</span><span class="whitespace"> </span><span class="java-class">Object</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">default</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/odd?" title="Returns true if n is odd, throws an exception if n is not an integer">odd?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">clauses</span>)</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/last" title="Return the last item in coll, in linear time">last</a></span><span class="whitespace"> </span><span class="symbol">clauses</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span>`<span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"No matching clause: "</span><span class="whitespace"> </span>~<span class="symbol">ge</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&gt;" title="Returns non-nil if nums are in monotonically decreasing order,
  otherwise false.">></a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">clauses</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">ge</span><span class="whitespace"> </span>~<span class="symbol">e</span>]</span><span class="whitespace"> </span>~<span class="symbol">default</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">pairs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition" title="Returns a lazy sequence of lists of n items each, at offsets step
  apart. If step is not supplied, defaults to n, i.e. the partitions
  do not overlap. If a pad collection is supplied, use its elements as
  necessary to complete last partition upto n items. In case there are
  not enough padding elements, return a partition with less than n items.">partition</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span class="symbol">clauses</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">assoc-test</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">assoc-test</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="symbol">expr</span>]</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Duplicate case test constant: "</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="symbol">expr</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">pairs</span><span class="whitespace"> </span><span>(<span class="symbol">reduce1</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="symbol">expr</span>]</span>]</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="symbol">reduce1</span><span class="whitespace"> </span><span>#(<span class="symbol">assoc-test</span><span class="whitespace"> </span><span class="symbol">%1</span><span class="whitespace"> </span><span class="symbol">%2</span><span class="whitespace"> </span><span class="symbol">expr</span>)</span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="symbol">assoc-test</span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="symbol">expr</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>{}</span><span class="whitespace"> </span><span class="symbol">pairs</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">tests</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span><span class="whitespace"> </span><span class="symbol">pairs</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">thens</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vals" title="Returns a sequence of the map&apos;s values, in the same order as (seq map).">vals</a></span><span class="whitespace"> </span><span class="symbol">pairs</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">mode</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span>#(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/integer?" title="Returns true if n is an integer">integer?</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;=" title="Returns non-nil if nums are in monotonically non-decreasing order,
  otherwise false."><=</a></span><span class="whitespace"> </span><span class="java-class">Integer/<span class="symbol">MIN_VALUE</span></span><span class="whitespace"> </span><span class="symbol">%</span><span class="whitespace"> </span><span class="java-class">Integer/<span class="symbol">MAX_VALUE</span></span>)</span>)</span><span class="whitespace"> </span><span class="symbol">tests</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="keyword">:ints</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace"> </span><span class="symbol">tests</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="keyword">:identity</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="keyword">:else</span><span class="whitespace"> </span><span class="keyword">:hashes</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/condp" title="Takes a binary predicate, an expression, and a set of clauses.
  Each clause can take the form of either:

  test-expr result-expr

  test-expr :&gt;&gt; result-fn

  Note :&gt;&gt; is an ordinary keyword.

  For each clause, (pred test-expr expr) is evaluated. If it returns
  logical true, the clause is a match. If a binary clause matches, the
  result-expr is returned, if a ternary clause matches, its result-fn,
  which must be a unary function, is called with the result of the
  predicate as its argument, the result of that call being the return
  value of condp. A single default expression can follow the clauses,
  and its value will be returned if no clause matches. If no default
  expression is provided and no clause matches, an
  IllegalArgumentException is thrown.">condp</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">mode</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="keyword">:ints</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">shift</span><span class="whitespace"> </span><span class="symbol">mask</span><span class="whitespace"> </span><span class="symbol">imap</span><span class="whitespace"> </span><span class="symbol">switch-type</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">prep-ints</span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">ge</span><span class="whitespace"> </span>~<span class="symbol">e</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">case*</span><span class="whitespace"> </span>~<span class="symbol">ge</span><span class="whitespace"> </span>~<span class="symbol">shift</span><span class="whitespace"> </span>~<span class="symbol">mask</span><span class="whitespace"> </span>~<span class="symbol">default</span><span class="whitespace"> </span>~<span class="symbol">imap</span><span class="whitespace"> </span>~<span class="symbol">switch-type</span><span class="whitespace"> </span><span class="keyword">:int</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="keyword">:hashes</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">shift</span><span class="whitespace"> </span><span class="symbol">mask</span><span class="whitespace"> </span><span class="symbol">imap</span><span class="whitespace"> </span><span class="symbol">switch-type</span><span class="whitespace"> </span><span class="symbol">skip-check</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">prep-hashes</span><span class="whitespace"> </span><span class="symbol">ge</span><span class="whitespace"> </span><span class="symbol">default</span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">ge</span><span class="whitespace"> </span>~<span class="symbol">e</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">case*</span><span class="whitespace"> </span>~<span class="symbol">ge</span><span class="whitespace"> </span>~<span class="symbol">shift</span><span class="whitespace"> </span>~<span class="symbol">mask</span><span class="whitespace"> </span>~<span class="symbol">default</span><span class="whitespace"> </span>~<span class="symbol">imap</span><span class="whitespace"> </span>~<span class="symbol">switch-type</span><span class="whitespace"> </span><span class="keyword">:hash-equiv</span><span class="whitespace"> </span>~<span class="symbol">skip-check</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="keyword">:identity</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">shift</span><span class="whitespace"> </span><span class="symbol">mask</span><span class="whitespace"> </span><span class="symbol">imap</span><span class="whitespace"> </span><span class="symbol">switch-type</span><span class="whitespace"> </span><span class="symbol">skip-check</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">prep-hashes</span><span class="whitespace"> </span><span class="symbol">ge</span><span class="whitespace"> </span><span class="symbol">default</span><span class="whitespace"> </span><span class="symbol">tests</span><span class="whitespace"> </span><span class="symbol">thens</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">ge</span><span class="whitespace"> </span>~<span class="symbol">e</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">case*</span><span class="whitespace"> </span>~<span class="symbol">ge</span><span class="whitespace"> </span>~<span class="symbol">shift</span><span class="whitespace"> </span>~<span class="symbol">mask</span><span class="whitespace"> </span>~<span class="symbol">default</span><span class="whitespace"> </span>~<span class="symbol">imap</span><span class="whitespace"> </span>~<span class="symbol">switch-type</span><span class="whitespace"> </span><span class="keyword">:hash-identity</span><span class="whitespace"> </span>~<span class="symbol">skip-check</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;; redefine reduce with internal-reduce</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; helper files ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span class="whitespace">
</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alter-meta!" title="Atomically sets the metadata for a namespace/var/ref/agent/atom to be:

  (apply f its-current-meta args)

  f must be free of side-effects">alter-meta!</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find-ns" title="Returns the namespace named by the symbol or nil if it doesn&apos;t exist.">find-ns</a></span><span class="whitespace"> </span><span>'<span class="symbol">clojure.core</span></span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="keyword">:doc</span><span class="whitespace"> </span><span class="string">"Fundamental library of the Clojure language"</span>)</span><span class="whitespace">
</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span><span class="whitespace"> </span><span class="string">"core_proxy"</span>)</span><span class="whitespace">
</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span><span class="whitespace"> </span><span class="string">"core_print"</span>)</span><span class="whitespace">
</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span><span class="whitespace"> </span><span class="string">"genclass"</span>)</span><span class="whitespace">
</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span><span class="whitespace"> </span><span class="string">"core_deftype"</span>)</span><span class="whitespace">
</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span><span class="whitespace"> </span><span class="string">"core/protocols"</span>)</span><span class="whitespace">
</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span><span class="whitespace"> </span><span class="string">"gvec"</span>)</span><span class="whitespace">
</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span><span class="whitespace"> </span><span class="string">"instant"</span>)</span><span class="whitespace">
</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/load" title="Loads Clojure code from resources in classpath. A path is interpreted as
  classpath-relative if it begins with a slash or relative to the root
  directory for the current namespace otherwise.">load</a></span><span class="whitespace"> </span><span class="string">"uuid"</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduce" title="f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.">reduce</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IReduce</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="java-class">.reduce</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.IReduce</span></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">f</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref"><a>clojure.core.protocols/coll-reduce</a></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">f</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IReduceInit</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="java-class">.reduce</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.IReduceInit</span></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref"><a>clojure.core.protocols/coll-reduce</a></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/extend-protocol" title="Useful when you want to provide several implementations of the same
  protocol all at once. Takes a single protocol and the implementation
  of that protocol for one or more types. Expands into calls to
  extend-type:

  (extend-protocol Protocol
    AType
      (foo [x] ...)
      (bar [x y] ...)
    BType
      (foo [x] ...)
      (bar [x y] ...)
    AClass
      (foo [x] ...)
      (bar [x y] ...)
    nil
      (foo [x] ...)
      (bar [x y] ...))

  expands into:

  (do
   (clojure.core/extend-type AType Protocol 
     (foo [x] ...) 
     (bar [x y] ...))
   (clojure.core/extend-type BType Protocol 
     (foo [x] ...) 
     (bar [x y] ...))
   (clojure.core/extend-type AClass Protocol 
     (foo [x] ...) 
     (bar [x y] ...))
   (clojure.core/extend-type nil Protocol 
     (foo [x] ...) 
     (bar [x y] ...)))">extend-protocol</a></span><span class="whitespace"> </span><span class="var-ref"><a href="clojure.core.protocols.html#L174" title="Protocol for concrete associative types that can reduce themselves
   via a function of key and val faster than first/next recursion over map
   entries. Called by clojure.core/reduce-kv, and has same
   semantics (just different arg order).">clojure.core.protocols/IKVReduce</a></span><span class="whitespace">
</span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace">
</span><span class="whitespace"> </span><span>(<span class="symbol">kv-reduce</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">_</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">init</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="symbol">init</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace"> </span><span class="comment">;;slow path default</span><span class="whitespace">
</span><span class="whitespace"> </span><span class="java-class">clojure.lang.IPersistentMap</span><span class="whitespace">
</span><span class="whitespace"> </span><span>(<span class="symbol">kv-reduce</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/amap" title="Maps an expression across an array a, using an index named idx, and
  return value named ret, initialized to a clone of a, then setting 
  each element of ret to the evaluation of expr, returning the new 
  array ret.">amap</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">init</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduce" title="f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.">reduce</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">v</span>]</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">init</span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/amap" title="Maps an expression across an array a, using an index named idx, and
  return value named ret, initialized to a clone of a, then setting 
  each element of ret to the evaluation of expr, returning the new 
  array ret.">amap</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace"> </span><span class="java-class">clojure.lang.IKVReduce</span><span class="whitespace">
</span><span class="whitespace"> </span><span>(<span class="symbol">kv-reduce</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/amap" title="Maps an expression across an array a, using an index named idx, and
  return value named ret, initialized to a clone of a, then setting 
  each element of ret to the evaluation of expr, returning the new 
  array ret.">amap</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">init</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">.kvreduce</span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/amap" title="Maps an expression across an array a, using an index named idx, and
  return value named ret, initialized to a clone of a, then setting 
  each element of ret to the evaluation of expr, returning the new 
  array ret.">amap</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">init</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduce-kv" title="Reduces an associative collection. f should be a function of 3
  arguments. Returns the result of applying f to init, the first key
  and the first value in coll, then applying f to that result and the
  2nd key and value, etc. If coll contains no entries, returns init
  and f is not called. Note that reduce-kv is supported on vectors,
  where the keys will be the ordinals.">reduce-kv</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Reduces an associative collection. f should be a function of 3
  arguments. Returns the result of applying f to init, the first key
  and the first value in coll, then applying f to that result and the
  2nd key and value, etc. If coll contains no entries, returns init
  and f is not called. Note that reduce-kv is supported on vectors,
  where the keys will be the ordinals."</span><span class="whitespace">  </span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.4"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">init</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref"><a>clojure.core.protocols/kv-reduce</a></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">init</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/completing" title="Takes a reducing function f of 2 args and returns a fn suitable for
  transduce by adding an arity-1 signature that calls cf (default -
  identity) on the result argument.">completing</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a reducing function f of 2 args and returns a fn suitable for
  transduce by adding an arity-1 signature that calls cf (default -
  identity) on the result argument."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/completing" title="Takes a reducing function f of 2 args and returns a fn suitable for
  transduce by adding an arity-1 signature that calls cf (default -
  identity) on the result argument.">completing</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identity" title="Returns its argument.">identity</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">cf</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">cf</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transduce" title="reduce with a transformation of f (xf). If init is not
  supplied, (f) will be called to produce it. f should be a reducing
  step function that accepts both 1 and 2 arguments, if it accepts
  only 2 you can add the arity-1 with &apos;completing&apos;. Returns the result
  of applying (the transformed) xf to init and the first item in coll,
  then applying xf to that result and the 2nd item, etc. If coll
  contains no items, returns init and f is not called. Note that
  certain transforms may inject or skip items.">transduce</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"reduce with a transformation of f (xf). If init is not
  supplied, (f) will be called to produce it. f should be a reducing
  step function that accepts both 1 and 2 arguments, if it accepts
  only 2 you can add the arity-1 with 'completing'. Returns the result
  of applying (the transformed) xf to init and the first item in coll,
  then applying xf to that result and the 2nd item, etc. If coll
  contains no items, returns init and f is not called. Note that
  certain transforms may inject or skip items."</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">xform</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transduce" title="reduce with a transformation of f (xf). If init is not
  supplied, (f) will be called to produce it. f should be a reducing
  step function that accepts both 1 and 2 arguments, if it accepts
  only 2 you can add the arity-1 with &apos;completing&apos;. Returns the result
  of applying (the transformed) xf to init and the first item in coll,
  then applying xf to that result and the 2nd item, etc. If coll
  contains no items, returns init and f is not called. Note that
  certain transforms may inject or skip items.">transduce</a></span><span class="whitespace"> </span><span class="symbol">xform</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">f</span>)</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">xform</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">init</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">xform</span><span class="whitespace"> </span><span class="symbol">f</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IReduceInit</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="java-class">.reduce</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.IReduceInit</span></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">init</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref"><a>clojure.core.protocols/coll-reduce</a></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">init</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/into" title="Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined. A transducer may be supplied.">into</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined. A transducer may be supplied."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">to</span><span class="whitespace"> </span><span class="symbol">from</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IEditableCollection</span><span class="whitespace"> </span><span class="symbol">to</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/persistent!" title="Returns a new, persistent version of the transient collection, in
  constant time. The transient collection cannot be used after this
  call, any such use will throw an exception.">persistent!</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduce" title="f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.">reduce</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transient" title="Returns a new, transient version of the collection, in constant time.">transient</a></span><span class="whitespace"> </span><span class="symbol">to</span>)</span><span class="whitespace"> </span><span class="symbol">from</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">to</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduce" title="f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.">reduce</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">to</span><span class="whitespace"> </span><span class="symbol">from</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">to</span><span class="whitespace"> </span><span class="symbol">xform</span><span class="whitespace"> </span><span class="symbol">from</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.IEditableCollection</span><span class="whitespace"> </span><span class="symbol">to</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-meta" title="Returns an object of the same type and value as obj, with
    map m as its metadata.">with-meta</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/persistent!" title="Returns a new, persistent version of the transient collection, in
  constant time. The transient collection cannot be used after this
  call, any such use will throw an exception.">persistent!</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transduce" title="reduce with a transformation of f (xf). If init is not
  supplied, (f) will be called to produce it. f should be a reducing
  step function that accepts both 1 and 2 arguments, if it accepts
  only 2 you can add the arity-1 with &apos;completing&apos;. Returns the result
  of applying (the transformed) xf to init and the first item in coll,
  then applying xf to that result and the 2nd item, etc. If coll
  contains no items, returns init and f is not called. Note that
  certain transforms may inject or skip items.">transduce</a></span><span class="whitespace"> </span><span class="symbol">xform</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transient" title="Returns a new, transient version of the collection, in constant time.">transient</a></span><span class="whitespace"> </span><span class="symbol">to</span>)</span><span class="whitespace"> </span><span class="symbol">from</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">to</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transduce" title="reduce with a transformation of f (xf). If init is not
  supplied, (f) will be called to produce it. f should be a reducing
  step function that accepts both 1 and 2 arguments, if it accepts
  only 2 you can add the arity-1 with &apos;completing&apos;. Returns the result
  of applying (the transformed) xf to init and the first item in coll,
  then applying xf to that result and the 2nd item, etc. If coll
  contains no items, returns init and f is not called. Note that
  certain transforms may inject or skip items.">transduce</a></span><span class="whitespace"> </span><span class="symbol">xform</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">to</span><span class="whitespace"> </span><span class="symbol">from</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/mapv" title="Returns a vector consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.">mapv</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a vector consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.4"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduce" title="f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.">reduce</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">o</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">o</span>)</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transient" title="Returns a new, transient version of the collection, in constant time.">transient</a></span><span class="whitespace"> </span><span>[]</span>)</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/persistent!" title="Returns a new, persistent version of the transient collection, in
  constant time. The transient collection cannot be used after this
  call, any such use will throw an exception.">persistent!</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">c1</span><span class="whitespace"> </span><span class="symbol">c2</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/into" title="Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined. A transducer may be supplied.">into</a></span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">c1</span><span class="whitespace"> </span><span class="symbol">c2</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">c1</span><span class="whitespace"> </span><span class="symbol">c2</span><span class="whitespace"> </span><span class="symbol">c3</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/into" title="Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined. A transducer may be supplied.">into</a></span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">c1</span><span class="whitespace"> </span><span class="symbol">c2</span><span class="whitespace"> </span><span class="symbol">c3</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">c1</span><span class="whitespace"> </span><span class="symbol">c2</span><span class="whitespace"> </span><span class="symbol">c3</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">colls</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/into" title="Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined. A transducer may be supplied.">into</a></span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">c1</span><span class="whitespace"> </span><span class="symbol">c2</span><span class="whitespace"> </span><span class="symbol">c3</span><span class="whitespace"> </span><span class="symbol">colls</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filterv" title="Returns a vector of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.">filterv</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a vector of the items in coll for which
  (pred item) returns true. pred must be free of side-effects."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.4"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduce" title="f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.">reduce</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">o</span>]</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="symbol">pred</span><span class="whitespace"> </span><span class="symbol">o</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">o</span>)</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transient" title="Returns a new, transient version of the collection, in constant time.">transient</a></span><span class="whitespace"> </span><span>[]</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/persistent!" title="Returns a new, persistent version of the transient collection, in
  constant time. The transient collection cannot be used after this
  call, any such use will throw an exception.">persistent!</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/require" title="Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.

  Libs

  A &apos;lib&apos; is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib&apos;s
  name also locates its root directory within classpath using Java&apos;s
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.

  &apos;require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol &apos;x.y.z; it has the root directory
  &lt;classpath&gt;/x/y/, and its root resource is &lt;classpath&gt;/x/y/z.clj. The root
  resource should contain code to create the lib&apos;s namespace (usually by using
  the ns macro) and load any additional lib resources.

  Libspecs

  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.

  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib&apos;s namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.

  Prefix Lists

  It&apos;s common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing the
  prefix, the names that remain must not contain any periods.

  Flags

  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer

  Example:

  The following would load the libraries clojure.zip and clojure.set
  abbreviated as &apos;s&apos;.

  (require &apos;(clojure zip [set :as s]))">require</a></span><span class="whitespace"> </span><span>'<span>[<span class="symbol">clojure.java.io</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">jio</span>]</span></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">normalize-slurp-opts</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">opts</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/string?" title="Return true if x is a String">string?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">opts</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">do</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/println" title="Same as print followed by (newline)">println</a></span><span class="whitespace"> </span><span class="string">"WARNING: (slurp f enc) is deprecated, use (slurp f :encoding enc)."</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>[<span class="keyword">:encoding</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">opts</span>)</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="symbol">opts</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/slurp" title="Opens a reader on f and reads all its contents, returning a string.
  See clojure.java.io/reader for a complete list of supported arguments.">slurp</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Opens a reader on f and reads all its contents, returning a string.
  See clojure.java.io/reader for a complete list of supported arguments."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">opts</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">opts</span><span class="whitespace"> </span><span>(<span class="symbol">normalize-slurp-opts</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span class="symbol">sw</span><span class="whitespace"> </span><span>(<span class="symbol">java.io.StringWriter.</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-open" title="bindings =&gt; [name init ...]

  Evaluates body in a try expression with names bound to the values
  of the inits, and a finally clause that calls (.close name) on each
  name in reverse order.">with-open</a></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">java.io.Reader</span></span><span class="whitespace"> </span><span class="symbol">r</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">reader</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">opts</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="symbol">copy</span><span class="whitespace"> </span><span class="symbol">r</span><span class="whitespace"> </span><span class="symbol">sw</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="java-class">.toString</span><span class="whitespace"> </span><span class="symbol">sw</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/spit" title="Opposite of slurp.  Opens f with writer, writes content, then
  closes f. Options passed to clojure.java.io/writer.">spit</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Opposite of slurp.  Opens f with writer, writes content, then
  closes f. Options passed to clojure.java.io/writer."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">content</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">options</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-open" title="bindings =&gt; [name init ...]

  Evaluates body in a try expression with names bound to the values
  of the inits, and a finally clause that calls (.close name) on each
  name in reverse order.">with-open</a></span><span class="whitespace"> </span><span>[<span>^<span class="java-class">java.io.Writer</span></span><span class="whitespace"> </span><span class="symbol">w</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">writer</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">options</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.write</span><span class="whitespace"> </span><span class="symbol">w</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="symbol">content</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; futures (needs proxy);;;;;;;;;;;;;;;;;;</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/future-call" title="Takes a function of no args and yields a future object that will
  invoke the function in another thread, and will cache the result and
  return it on all subsequent calls to deref/@. If the computation has
  not yet finished, calls to deref/@ will block, unless the variant
  of deref with timeout is used. See also - realized?.">future-call</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a function of no args and yields a future object that will
  invoke the function in another thread, and will cache the result and
  return it on all subsequent calls to deref/@. If the computation has
  not yet finished, calls to deref/@ will block, unless the variant
  of deref with timeout is used. See also - realized?."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">f</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">binding-conveyor-fn</span><span class="whitespace"> </span><span class="symbol">f</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">fut</span><span class="whitespace"> </span><span>(<span class="java-class">.submit</span><span class="whitespace"> </span><span class="java-class">clojure.lang.Agent/<span class="symbol">soloExecutor</span></span><span class="whitespace"> </span><span>^<span class="java-class">Callable</span></span><span class="whitespace"> </span><span class="symbol">f</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/reify" title="reify is a macro with the following structure:

 (reify options* specs*)
  
  Currently there are no options.

  Each spec consists of the protocol or interface name followed by zero
  or more method bodies:

  protocol-or-interface-or-Object
  (methodName [args+] body)*

  Methods should be supplied for all methods of the desired
  protocol(s) and interface(s). You can also define overrides for
  methods of Object. Note that the first parameter must be supplied to
  correspond to the target object (&apos;this&apos; in Java parlance). Thus
  methods for interfaces will take one more argument than do the
  interface declarations.  Note also that recur calls to the method
  head should *not* pass the target object, it will be supplied
  automatically and can not be substituted.

  The return type can be indicated by a type hint on the method name,
  and arg types can be indicated by a type hint on arg names. If you
  leave out all hints, reify will try to match on same name/arity
  method in the protocol(s)/interface(s) - this is preferred. If you
  supply any hints at all, no inference is done, so all hints (or
  default of Object) must be correct, for both arguments and return
  type. If a method is overloaded in a protocol/interface, multiple
  independent method definitions must be supplied.  If overloaded with
  same arity in an interface you must specify complete hints to
  disambiguate - a missing hint implies Object.

  recur works to method heads The method bodies of reify are lexical
  closures, and can refer to the surrounding local scope:
  
  (str (let [f &quot;foo&quot;] 
       (reify Object 
         (toString [this] f))))
  == &quot;foo&quot;

  (seq (let [f &quot;foo&quot;] 
       (reify clojure.lang.Seqable 
         (seq [this] (seq f)))))
  == (\f \o \o))
  
  reify always implements clojure.lang.IObj and transfers meta
  data of the form to the created object.
  
  (meta ^{:k :v} (reify Object (toString [this] &quot;foo&quot;)))
  == {:k :v}">reify</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">     </span><span class="java-class">clojure.lang.IDeref</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/deref" title="Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,
  returns the in-transaction-value of ref, else returns the
  most-recently-committed value of ref. When applied to a var, agent
  or atom, returns its current state. When applied to a delay, forces
  it if not already forced. When applied to a future, will block if
  computation not complete. When applied to a promise, will block
  until a value is delivered.  The variant taking a timeout can be
  used for blocking references (futures and promises), and will return
  timeout-val if the timeout (in milliseconds) is reached before a
  value is available. See also - realized?.">deref</a></span><span class="whitespace"> </span><span>[<span class="symbol">_</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">deref-future</span><span class="whitespace"> </span><span class="symbol">fut</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="java-class">clojure.lang.IBlockingDeref</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/deref" title="Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,
  returns the in-transaction-value of ref, else returns the
  most-recently-committed value of ref. When applied to a var, agent
  or atom, returns its current state. When applied to a delay, forces
  it if not already forced. When applied to a future, will block if
  computation not complete. When applied to a promise, will block
  until a value is delivered.  The variant taking a timeout can be
  used for blocking references (futures and promises), and will return
  timeout-val if the timeout (in milliseconds) is reached before a
  value is available. See also - realized?.">deref</a></span><span class="whitespace">
</span><span class="whitespace">      </span><span>[<span class="symbol">_</span><span class="whitespace"> </span><span class="symbol">timeout-ms</span><span class="whitespace"> </span><span class="symbol">timeout-val</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">deref-future</span><span class="whitespace"> </span><span class="symbol">fut</span><span class="whitespace"> </span><span class="symbol">timeout-ms</span><span class="whitespace"> </span><span class="symbol">timeout-val</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="java-class">clojure.lang.IPending</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">isRealized</span><span class="whitespace"> </span><span>[<span class="symbol">_</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.isDone</span><span class="whitespace"> </span><span class="symbol">fut</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="java-class">java.util.concurrent.Future</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span>[<span class="symbol">_</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.get</span><span class="whitespace"> </span><span class="symbol">fut</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span>[<span class="symbol">_</span><span class="whitespace"> </span><span class="symbol">timeout</span><span class="whitespace"> </span><span class="symbol">unit</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.get</span><span class="whitespace"> </span><span class="symbol">fut</span><span class="whitespace"> </span><span class="symbol">timeout</span><span class="whitespace"> </span><span class="symbol">unit</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">isCancelled</span><span class="whitespace"> </span><span>[<span class="symbol">_</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.isCancelled</span><span class="whitespace"> </span><span class="symbol">fut</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">isDone</span><span class="whitespace"> </span><span>[<span class="symbol">_</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.isDone</span><span class="whitespace"> </span><span class="symbol">fut</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">cancel</span><span class="whitespace"> </span><span>[<span class="symbol">_</span><span class="whitespace"> </span><span class="symbol">interrupt?</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.cancel</span><span class="whitespace"> </span><span class="symbol">fut</span><span class="whitespace"> </span><span class="symbol">interrupt?</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/future" title="Takes a body of expressions and yields a future object that will
  invoke the body in another thread, and will cache the result and
  return it on all subsequent calls to deref/@. If the computation has
  not yet finished, calls to deref/@ will block, unless the variant of
  deref with timeout is used. See also - realized?.">future</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a body of expressions and yields a future object that will
  invoke the body in another thread, and will cache the result and
  return it on all subsequent calls to deref/@. If the computation has
  not yet finished, calls to deref/@ will block, unless the variant of
  deref with timeout is used. See also - realized?."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace"> </span>`<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/future-call" title="Takes a function of no args and yields a future object that will
  invoke the function in another thread, and will cache the result and
  return it on all subsequent calls to deref/@. If the computation has
  not yet finished, calls to deref/@ will block, unless the variant
  of deref with timeout is used. See also - realized?.">future-call</a></span><span class="whitespace"> </span><span>(<span>^<span>{<span class="keyword">:once</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace"> </span><span class="symbol">fn*</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span>~<span class="unknown">@body</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/future-cancel" title="Cancels the future, if possible.">future-cancel</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Cancels the future, if possible."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">java.util.concurrent.Future</span></span><span class="whitespace"> </span><span class="symbol">f</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.cancel</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="unknown">true</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/future-cancelled?" title="Returns true if future f is cancelled">future-cancelled?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if future f is cancelled"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">java.util.concurrent.Future</span></span><span class="whitespace"> </span><span class="symbol">f</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.isCancelled</span><span class="whitespace"> </span><span class="symbol">f</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pmap" title="Like map, except f is applied in parallel. Semi-lazy in that the
  parallel computation stays ahead of the consumption, but doesn&apos;t
  realize the entire result unless required. Only useful for
  computationally intensive functions where the time of f dominates
  the coordination overhead.">pmap</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Like map, except f is applied in parallel. Semi-lazy in that the
  parallel computation stays ahead of the consumption, but doesn't
  realize the entire result unless required. Only useful for
  computationally intensive functions where the time of f dominates
  the coordination overhead."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">n</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span>(<span class="java-class">..</span><span class="whitespace"> </span><span class="java-class">Runtime</span><span class="whitespace"> </span><span class="symbol">getRuntime</span><span class="whitespace"> </span><span class="symbol">availableProcessors</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">rets</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/future" title="Takes a body of expressions and yields a future object that will
  invoke the body in another thread, and will cache the result and
  return it on all subsequent calls to deref/@. If the computation has
  not yet finished, calls to deref/@ will block, unless the variant of
  deref with timeout is used. See also - realized?.">future</a></span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">step</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">step</span><span class="whitespace"> </span><span>[<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">xs</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">vs</span>]</span><span class="whitespace"> </span><span class="symbol">fs</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">fs</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/deref" title="Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,
  returns the in-transaction-value of ref, else returns the
  most-recently-committed value of ref. When applied to a var, agent
  or atom, returns its current state. When applied to a delay, forces
  it if not already forced. When applied to a future, will block if
  computation not complete. When applied to a promise, will block
  until a value is delivered.  The variant taking a timeout can be
  used for blocking references (futures and promises), and will return
  timeout-val if the timeout (in milliseconds) is reached before a
  value is available. See also - realized?.">deref</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">step</span><span class="whitespace"> </span><span class="symbol">xs</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/deref" title="Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,
  returns the in-transaction-value of ref, else returns the
  most-recently-committed value of ref. When applied to a var, agent
  or atom, returns its current state. When applied to a delay, forces
  it if not already forced. When applied to a future, will block if
  computation not complete. When applied to a promise, will block
  until a value is delivered.  The variant taking a timeout can be
  used for blocking references (futures and promises), and will return
  timeout-val if the timeout (in milliseconds) is reached before a
  value is available. See also - realized?.">deref</a></span><span class="whitespace"> </span><span class="symbol">vs</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">step</span><span class="whitespace"> </span><span class="symbol">rets</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop" title="Returns a lazy sequence of all but the first n items in coll.
  Returns a stateful transducer when no collection is provided.">drop</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">rets</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">colls</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">step</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">step</span><span class="whitespace"> </span><span>[<span class="symbol">cs</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ss</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">cs</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identity" title="Returns its argument.">identity</a></span><span class="whitespace"> </span><span class="symbol">ss</span>)</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ss</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">step</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">ss</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pmap" title="Like map, except f is applied in parallel. Semi-lazy in that the
  parallel computation stays ahead of the consumption, but doesn&apos;t
  realize the entire result unless required. Only useful for
  computationally intensive functions where the time of f dominates
  the coordination overhead.">pmap</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">step</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span class="symbol">colls</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pcalls" title="Executes the no-arg fns in parallel, returning a lazy sequence of
  their values">pcalls</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Executes the no-arg fns in parallel, returning a lazy sequence of
  their values"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">fns</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pmap" title="Like map, except f is applied in parallel. Semi-lazy in that the
  parallel computation stays ahead of the consumption, but doesn&apos;t
  realize the entire result unless required. Only useful for
  computationally intensive functions where the time of f dominates
  the coordination overhead.">pmap</a></span><span class="whitespace"> </span><span>#(<span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">fns</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/pvalues" title="Returns a lazy sequence of the values of the exprs, which are
  evaluated in parallel">pvalues</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of the values of the exprs, which are
  evaluated in parallel"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">exprs</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pcalls" title="Executes the no-arg fns in parallel, returning a lazy sequence of
  their values">pcalls</a></span><span class="whitespace"> </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span>`<span class="macro">fn</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">exprs</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; clojure version number ;;;;;;;;;;;;;;;;;;;;;;</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">properties</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-open" title="bindings =&gt; [name init ...]

  Evaluates body in a try expression with names bound to the values
  of the inits, and a finally clause that calls (.close name) on each
  name in reverse order.">with-open</a></span><span class="whitespace"> </span><span>[<span class="symbol">version-stream</span><span class="whitespace"> </span><span>(<span class="java-class">.getResourceAsStream</span><span class="whitespace">
</span><span class="whitespace">                                             </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">baseLoader</span></span>)</span><span class="whitespace">
</span><span class="whitespace">                                             </span><span class="string">"clojure/version.properties"</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/doto" title="Evaluates x then calls all of the methods and functions with the
  value of x supplied at the front of the given arguments.  The forms
  are evaluated in order.  Returns x.

  (doto (new java.util.HashMap) (.put &quot;a&quot; 1) (.put &quot;b&quot; 2))">doto</a></span><span class="whitespace"> </span><span>(<span class="symbol">new</span><span class="whitespace"> </span><span class="java-class">java.util.Properties</span>)</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="java-class">.load</span><span class="whitespace"> </span><span class="symbol">version-stream</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="symbol">version-string</span><span class="whitespace"> </span><span>(<span class="java-class">.getProperty</span><span class="whitespace"> </span><span class="symbol">properties</span><span class="whitespace"> </span><span class="string">"version"</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>[<span class="symbol">_</span><span class="whitespace"> </span><span class="symbol">major</span><span class="whitespace"> </span><span class="symbol">minor</span><span class="whitespace"> </span><span class="symbol">incremental</span><span class="whitespace"> </span><span class="symbol">qualifier</span><span class="whitespace"> </span><span class="symbol">snapshot</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/re-matches" title="Returns the match, if any, of string to pattern, using
  java.util.regex.Matcher.matches().  Uses re-groups to return the
  groups.">re-matches</a></span><span class="whitespace">
</span><span class="whitespace">       </span><span>#<span class="strign">"(\d+)\.(\d+)\.(\d+)(?:-([a-zA-Z0-9_]+))?(?:-(SNAPSHOT))?"</span></span><span class="whitespace">
</span><span class="whitespace">       </span><span class="symbol">version-string</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/clojure-version" title="Returns clojure version as a printable string.">clojure-version</a></span><span class="whitespace"> </span><span>{<span class="keyword">:major</span><span class="whitespace">       </span><span>(<span class="java-class">Integer/<span class="symbol">valueOf</span></span><span class="whitespace"> </span><span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">major</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span class="keyword">:minor</span><span class="whitespace">       </span><span>(<span class="java-class">Integer/<span class="symbol">valueOf</span></span><span class="whitespace"> </span><span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">minor</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span class="keyword">:incremental</span><span class="whitespace"> </span><span>(<span class="java-class">Integer/<span class="symbol">valueOf</span></span><span class="whitespace"> </span><span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">incremental</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span class="keyword">:qualifier</span><span class="whitespace">   </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">qualifier</span><span class="whitespace"> </span><span class="string">"SNAPSHOT"</span>)</span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace"> </span><span class="symbol">qualifier</span>)</span>}</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span class="keyword">:dynamic</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*clojure-version*" title="The version info for Clojure core, as a map containing :major :minor 
  :incremental and :qualifier keys. Feature releases may increment 
  :minor and/or :major, bugfix releases will increment :incremental. 
  Possible values of :qualifier include &quot;GA&quot;, &quot;SNAPSHOT&quot;, &quot;RC-x&quot; &quot;BETA-x&quot;">*clojure-version*</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">.contains</span><span class="whitespace"> </span><span class="symbol">version-string</span><span class="whitespace"> </span><span class="string">"SNAPSHOT"</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">assoc</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/clojure-version" title="Returns clojure version as a printable string.">clojure-version</a></span><span class="whitespace"> </span><span class="keyword">:interim</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/clojure-version" title="Returns clojure version as a printable string.">clojure-version</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">add-doc-and-meta</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*clojure-version*" title="The version info for Clojure core, as a map containing :major :minor 
  :incremental and :qualifier keys. Feature releases may increment 
  :minor and/or :major, bugfix releases will increment :incremental. 
  Possible values of :qualifier include &quot;GA&quot;, &quot;SNAPSHOT&quot;, &quot;RC-x&quot; &quot;BETA-x&quot;">*clojure-version*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"The version info for Clojure core, as a map containing :major :minor 
  :incremental and :qualifier keys. Feature releases may increment 
  :minor and/or :major, bugfix releases will increment :incremental. 
  Possible values of :qualifier include \"GA\", \"SNAPSHOT\", \"RC-x\" \"BETA-x\""</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/clojure-version" title="Returns clojure version as a printable string.">clojure-version</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns clojure version as a printable string."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.0"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span>(<span class="keyword">:major</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*clojure-version*" title="The version info for Clojure core, as a map containing :major :minor 
  :incremental and :qualifier keys. Feature releases may increment 
  :minor and/or :major, bugfix releases will increment :incremental. 
  Possible values of :qualifier include &quot;GA&quot;, &quot;SNAPSHOT&quot;, &quot;RC-x&quot; &quot;BETA-x&quot;">*clojure-version*</a></span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span class="string">"."</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="keyword">:minor</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*clojure-version*" title="The version info for Clojure core, as a map containing :major :minor 
  :incremental and :qualifier keys. Feature releases may increment 
  :minor and/or :major, bugfix releases will increment :incremental. 
  Possible values of :qualifier include &quot;GA&quot;, &quot;SNAPSHOT&quot;, &quot;RC-x&quot; &quot;BETA-x&quot;">*clojure-version*</a></span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="keyword">:incremental</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*clojure-version*" title="The version info for Clojure core, as a map containing :major :minor 
  :incremental and :qualifier keys. Feature releases may increment 
  :minor and/or :major, bugfix releases will increment :incremental. 
  Possible values of :qualifier include &quot;GA&quot;, &quot;SNAPSHOT&quot;, &quot;RC-x&quot; &quot;BETA-x&quot;">*clojure-version*</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"."</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">q</span><span class="whitespace"> </span><span>(<span class="keyword">:qualifier</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*clojure-version*" title="The version info for Clojure core, as a map containing :major :minor 
  :incremental and :qualifier keys. Feature releases may increment 
  :minor and/or :major, bugfix releases will increment :incremental. 
  Possible values of :qualifier include &quot;GA&quot;, &quot;SNAPSHOT&quot;, &quot;RC-x&quot; &quot;BETA-x&quot;">*clojure-version*</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">q</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"-"</span><span class="whitespace"> </span><span class="symbol">q</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="keyword">:interim</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*clojure-version*" title="The version info for Clojure core, as a map containing :major :minor 
  :incremental and :qualifier keys. Feature releases may increment 
  :minor and/or :major, bugfix releases will increment :incremental. 
  Possible values of :qualifier include &quot;GA&quot;, &quot;SNAPSHOT&quot;, &quot;RC-x&quot; &quot;BETA-x&quot;">*clojure-version*</a></span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="string">"-SNAPSHOT"</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/promise" title="Returns a promise object that can be read with deref/@, and set,
  once only, with deliver. Calls to deref/@ prior to delivery will
  block, unless the variant of deref with timeout is used. All
  subsequent derefs will return the same delivered value without
  blocking. See also - realized?.">promise</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a promise object that can be read with deref/@, and set,
  once only, with deliver. Calls to deref/@ prior to delivery will
  block, unless the variant of deref with timeout is used. All
  subsequent derefs will return the same delivered value without
  blocking. See also - realized?."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">d</span><span class="whitespace"> </span><span>(<span class="symbol">java.util.concurrent.CountDownLatch.</span><span class="whitespace"> </span><span class="unknown">1</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/atom" title="Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.">atom</a></span><span class="whitespace"> </span><span class="symbol">d</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/reify" title="reify is a macro with the following structure:

 (reify options* specs*)
  
  Currently there are no options.

  Each spec consists of the protocol or interface name followed by zero
  or more method bodies:

  protocol-or-interface-or-Object
  (methodName [args+] body)*

  Methods should be supplied for all methods of the desired
  protocol(s) and interface(s). You can also define overrides for
  methods of Object. Note that the first parameter must be supplied to
  correspond to the target object (&apos;this&apos; in Java parlance). Thus
  methods for interfaces will take one more argument than do the
  interface declarations.  Note also that recur calls to the method
  head should *not* pass the target object, it will be supplied
  automatically and can not be substituted.

  The return type can be indicated by a type hint on the method name,
  and arg types can be indicated by a type hint on arg names. If you
  leave out all hints, reify will try to match on same name/arity
  method in the protocol(s)/interface(s) - this is preferred. If you
  supply any hints at all, no inference is done, so all hints (or
  default of Object) must be correct, for both arguments and return
  type. If a method is overloaded in a protocol/interface, multiple
  independent method definitions must be supplied.  If overloaded with
  same arity in an interface you must specify complete hints to
  disambiguate - a missing hint implies Object.

  recur works to method heads The method bodies of reify are lexical
  closures, and can refer to the surrounding local scope:
  
  (str (let [f &quot;foo&quot;] 
       (reify Object 
         (toString [this] f))))
  == &quot;foo&quot;

  (seq (let [f &quot;foo&quot;] 
       (reify clojure.lang.Seqable 
         (seq [this] (seq f)))))
  == (\f \o \o))
  
  reify always implements clojure.lang.IObj and transfers meta
  data of the form to the created object.
  
  (meta ^{:k :v} (reify Object (toString [this] &quot;foo&quot;)))
  == {:k :v}">reify</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">     </span><span class="java-class">clojure.lang.IDeref</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/deref" title="Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,
  returns the in-transaction-value of ref, else returns the
  most-recently-committed value of ref. When applied to a var, agent
  or atom, returns its current state. When applied to a delay, forces
  it if not already forced. When applied to a future, will block if
  computation not complete. When applied to a promise, will block
  until a value is delivered.  The variant taking a timeout can be
  used for blocking references (futures and promises), and will return
  timeout-val if the timeout (in milliseconds) is reached before a
  value is available. See also - realized?.">deref</a></span><span class="whitespace"> </span><span>[<span class="symbol">_</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.await</span><span class="whitespace"> </span><span class="symbol">d</span>)</span><span class="whitespace"> </span><span class="unknown">@v</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="java-class">clojure.lang.IBlockingDeref</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/deref" title="Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,
  returns the in-transaction-value of ref, else returns the
  most-recently-committed value of ref. When applied to a var, agent
  or atom, returns its current state. When applied to a delay, forces
  it if not already forced. When applied to a future, will block if
  computation not complete. When applied to a promise, will block
  until a value is delivered.  The variant taking a timeout can be
  used for blocking references (futures and promises), and will return
  timeout-val if the timeout (in milliseconds) is reached before a
  value is available. See also - realized?.">deref</a></span><span class="whitespace">
</span><span class="whitespace">        </span><span>[<span class="symbol">_</span><span class="whitespace"> </span><span class="symbol">timeout-ms</span><span class="whitespace"> </span><span class="symbol">timeout-val</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">.await</span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span class="symbol">timeout-ms</span><span class="whitespace"> </span><span class="java-class">java.util.concurrent.TimeUnit/<span class="symbol">MILLISECONDS</span></span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="unknown">@v</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">timeout-val</span>)</span>)</span><span class="whitespace">  </span><span class="whitespace">
</span><span class="whitespace">     </span><span class="java-class">clojure.lang.IPending</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">isRealized</span><span class="whitespace"> </span><span>[<span class="symbol">this</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/zero?" title="Returns true if num is zero, else false">zero?</a></span><span class="whitespace"> </span><span>(<span class="java-class">.getCount</span><span class="whitespace"> </span><span class="symbol">d</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="java-class">clojure.lang.IFn</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">invoke</span><span class="whitespace">
</span><span class="whitespace">      </span><span>[<span class="symbol">this</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pos?" title="Returns true if num is greater than zero, else false">pos?</a></span><span class="whitespace"> </span><span>(<span class="java-class">.getCount</span><span class="whitespace"> </span><span class="symbol">d</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/compare-and-set!" title="Atomically sets the value of atom to newval if and only if the
  current value of the atom is identical to oldval. Returns true if
  set happened, else false">compare-and-set!</a></span><span class="whitespace"> </span><span class="symbol">v</span><span class="whitespace"> </span><span class="symbol">d</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="java-class">.countDown</span><span class="whitespace"> </span><span class="symbol">d</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">this</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/deliver" title="Delivers the supplied value to the promise, releasing any pending
  derefs. A subsequent call to deliver on a promise will have no effect.">deliver</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Delivers the supplied value to the promise, releasing any pending
  derefs. A subsequent call to deliver on a promise will have no effect."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.1"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/promise" title="Returns a promise object that can be read with deref/@, and set,
  once only, with deliver. Calls to deref/@ prior to delivery will
  block, unless the variant of deref with timeout is used. All
  subsequent derefs will return the same delivered value without
  blocking. See also - realized?.">promise</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/promise" title="Returns a promise object that can be read with deref/@, and set,
  once only, with deliver. Calls to deref/@ prior to delivery will
  block, unless the variant of deref with timeout is used. All
  subsequent derefs will return the same delivered value without
  blocking. See also - realized?.">promise</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/flatten" title="Takes any nested combination of sequential things (lists, vectors,
  etc.) and returns their contents as a single, flat sequence.
  (flatten nil) returns an empty sequence.">flatten</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes any nested combination of sequential things (lists, vectors,
  etc.) and returns their contents as a single, flat sequence.
  (flatten nil) returns an empty sequence."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filter" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">filter</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/complement" title="Takes a fn f and returns a fn that takes the same arguments as f,
  has the same effects, if any, and returns the opposite truth value.">complement</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sequential?" title="Returns true if coll implements Sequential">sequential?</a></span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/tree-seq" title="Returns a lazy sequence of the nodes in a tree, via a depth-first walk.
   branch? must be a fn of one arg that returns true if passed a node
   that can have children (but may not).  children must be a fn of one
   arg that returns a sequence of the children. Will only be called on
   nodes for which branch? returns true. Root is the root node of the
  tree.">tree-seq</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sequential?" title="Returns true if coll implements Sequential">sequential?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/group-by" title="Returns a map of the elements of coll keyed by the result of
  f on each element. The value at each key will be a vector of the
  corresponding elements, in the order they appeared in coll.">group-by</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a map of the elements of coll keyed by the result of
  f on each element. The value at each key will be a vector of the
  corresponding elements, in the order they appeared in coll."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">  </span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/persistent!" title="Returns a new, persistent version of the transient collection, in
  constant time. The transient collection cannot be used after this
  call, any such use will throw an exception.">persistent!</a></span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduce" title="f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.">reduce</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc!" title="When applied to a transient map, adds mapping of key(s) to
  val(s). When applied to a transient vector, sets the val at index.
  Note - index must be &lt;= (count vector). Returns coll.">assoc!</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">ret</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span>[]</span>)</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transient" title="Returns a new, transient version of the collection, in constant time.">transient</a></span><span class="whitespace"> </span><span>{}</span>)</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition-by" title="Applies f to each value in coll, splitting it each time f returns a
   new value.  Returns a lazy seq of partitions.  Returns a stateful
   transducer when no collection is provided.">partition-by</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Applies f to each value in coll, splitting it each time f returns a
   new value.  Returns a lazy seq of partitions.  Returns a stateful
   transducer when no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="symbol">java.util.ArrayList.</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">pv</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/volatile!" title="Creates and returns a Volatile with an initial value of val.">volatile!</a></span><span class="whitespace"> </span><span class="keyword">::none</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">result</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">.isEmpty</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace">
</span><span class="whitespace">                          </span><span class="symbol">result</span><span class="whitespace">
</span><span class="whitespace">                          </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vec" title="Creates a new vector containing the contents of coll. Java arrays
  will be aliased and should not be modified.">vec</a></span><span class="whitespace"> </span><span>(<span class="java-class">.toArray</span><span class="whitespace"> </span><span class="symbol">a</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                            </span><span class="comment">;;clear first!</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="java-class">.clear</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unreduced" title="If x is reduced?, returns (deref x), else returns x">unreduced</a></span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">pval</span><span class="whitespace"> </span><span class="unknown">@pv</span><span class="whitespace">
</span><span class="whitespace">                 </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">input</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vreset!" title="Sets the value of volatile to newval without regard for the
   current value. Returns newval.">vreset!</a></span><span class="whitespace"> </span><span class="symbol">pv</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/identical?" title="Tests if 2 arguments are the same object">identical?</a></span><span class="whitespace"> </span><span class="symbol">pval</span><span class="whitespace"> </span><span class="keyword">::none</span>)</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">pval</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="macro">do</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="java-class">.add</span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">input</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span class="symbol">result</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vec" title="Creates a new vector containing the contents of coll. Java arrays
  will be aliased and should not be modified.">vec</a></span><span class="whitespace"> </span><span>(<span class="java-class">.toArray</span><span class="whitespace"> </span><span class="symbol">a</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="java-class">.clear</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduced?" title="Returns true if x is the result of a call to reduced">reduced?</a></span><span class="whitespace"> </span><span class="symbol">ret</span>)</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="java-class">.add</span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">input</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">ret</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">fst</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">fv</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">fst</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">run</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">fst</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-while" title="Returns a lazy sequence of successive items from coll while
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">take-while</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">fv</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">run</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition-by" title="Applies f to each value in coll, splitting it each time f returns a
   new value.  Returns a lazy seq of partitions.  Returns a stateful
   transducer when no collection is provided.">partition-by</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/drop" title="Returns a lazy sequence of all but the first n items in coll.
  Returns a stateful transducer when no collection is provided.">drop</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">run</span>)</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/frequencies" title="Returns a map from distinct items in coll to the number of times
  they appear.">frequencies</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a map from distinct items in coll to the number of times
  they appear."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/persistent!" title="Returns a new, persistent version of the transient collection, in
  constant time. The transient collection cannot be used after this
  call, any such use will throw an exception.">persistent!</a></span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduce" title="f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.">reduce</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">counts</span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc!" title="When applied to a transient map, adds mapping of key(s) to
  val(s). When applied to a transient vector, sets the val at index.
  Note - index must be &lt;= (count vector). Returns coll.">assoc!</a></span><span class="whitespace"> </span><span class="symbol">counts</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/get" title="Returns the value mapped to key, not-found or nil if key not present.">get</a></span><span class="whitespace"> </span><span class="symbol">counts</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="unknown">0</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transient" title="Returns a new, transient version of the collection, in constant time.">transient</a></span><span class="whitespace"> </span><span>{}</span>)</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reductions" title="Returns a lazy seq of the intermediate values of the reduction (as
  per reduce) of coll by f, starting with init.">reductions</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy seq of the intermediate values of the reduction (as
  per reduce) of coll by f, starting with init."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reductions" title="Returns a lazy seq of the intermediate values of the reduction (as
  per reduce) of coll by f, starting with init.">reductions</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span>(<span class="symbol">f</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">init</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduced?" title="Returns true if x is the result of a call to reduced">reduced?</a></span><span class="whitespace"> </span><span class="symbol">init</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span><span class="unknown">@init</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">init</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reductions" title="Returns a lazy seq of the intermediate values of the reduction (as
  per reduce) of coll by f, starting with init.">reductions</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">init</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rand-nth" title="Return a random element of the (sequential) collection. Will have
  the same performance characteristics as nth for the given
  collection.">rand-nth</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Return a random element of the (sequential) collection. Will have
  the same performance characteristics as nth for the given
  collection."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nth" title="Returns the value at the index. get returns nil if index out of
  bounds, nth throws an exception unless not-found is supplied.  nth
  also works for strings, Java arrays, regex Matchers and Lists, and,
  in O(n) time, for sequences.">nth</a></span><span class="whitespace"> </span><span class="symbol">coll</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rand-int" title="Returns a random integer between 0 (inclusive) and n (exclusive).">rand-int</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition-all" title="Returns a lazy sequence of lists like partition, but may include
  partitions with fewer than n items at the end.  Returns a stateful
  transducer when no collection is provided.">partition-all</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of lists like partition, but may include
  partitions with fewer than n items at the end.  Returns a stateful
  transducer when no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span>^<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long" title="Coerce to long">long</a></span></span><span class="whitespace"> </span><span class="symbol">n</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">a</span><span class="whitespace"> </span><span>(<span class="symbol">java.util.ArrayList.</span><span class="whitespace"> </span><span class="symbol">n</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">result</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">.isEmpty</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span class="symbol">result</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vec" title="Creates a new vector containing the contents of coll. Java arrays
  will be aliased and should not be modified.">vec</a></span><span class="whitespace"> </span><span>(<span class="java-class">.toArray</span><span class="whitespace"> </span><span class="symbol">a</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                             </span><span class="comment">;;clear first!</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="java-class">.clear</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/unreduced" title="If x is reduced?, returns (deref x), else returns x">unreduced</a></span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="java-class">.add</span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace"> </span><span class="symbol">input</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span>(<span class="java-class">.size</span><span class="whitespace"> </span><span class="symbol">a</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vec" title="Creates a new vector containing the contents of coll. Java arrays
  will be aliased and should not be modified.">vec</a></span><span class="whitespace"> </span><span>(<span class="java-class">.toArray</span><span class="whitespace"> </span><span class="symbol">a</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="java-class">.clear</span><span class="whitespace"> </span><span class="symbol">a</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">result</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition-all" title="Returns a lazy sequence of lists like partition, but may include
  partitions with fewer than n items at the end.  Returns a stateful
  transducer when no collection is provided.">partition-all</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">step</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">seg</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/doall" title="When lazy sequences are produced via functions that have side
  effects, any effects other than those needed to produce the first
  element in the seq do not occur until the seq is consumed. doall can
  be used to force any effects. Walks through the successive nexts of
  the seq, retains the head and returns it, thus causing the entire
  seq to reside in memory at one time.">doall</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take" title="Returns a lazy sequence of the first n items in coll, or all items if
  there are fewer than n.  Returns a stateful transducer when
  no collection is provided.">take</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">seg</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition-all" title="Returns a lazy sequence of lists like partition, but may include
  partitions with fewer than n items at the end.  Returns a stateful
  transducer when no collection is provided.">partition-all</a></span><span class="whitespace"> </span><span class="symbol">n</span><span class="whitespace"> </span><span class="symbol">step</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nthrest" title="Returns the nth rest of coll, coll when n is 0.">nthrest</a></span><span class="whitespace"> </span><span class="symbol">s</span><span class="whitespace"> </span><span class="symbol">step</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/shuffle" title="Return a random permutation of coll">shuffle</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Return a random permutation of coll"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">java.util.Collection</span></span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">al</span><span class="whitespace"> </span><span>(<span class="symbol">java.util.ArrayList.</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">java.util.Collections/<span class="symbol">shuffle</span></span><span class="whitespace"> </span><span class="symbol">al</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">vector</span></span><span class="whitespace"> </span><span>(<span class="java-class">.toArray</span><span class="whitespace"> </span><span class="symbol">al</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map-indexed" title="Returns a lazy sequence consisting of the result of applying f to 0
  and the first item of coll, followed by applying f to 1 and the second
  item in coll, etc, until coll is exhausted. Thus function f should
  accept 2 arguments, index and item. Returns a stateful transducer when
  no collection is provided.">map-indexed</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence consisting of the result of applying f to 0
  and the first item of coll, followed by applying f to 1 and the second
  item in coll, etc, until coll is exhausted. Thus function f should
  accept 2 arguments, index and item. Returns a stateful transducer when
  no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/volatile!" title="Creates and returns a Volatile with an initial value of val.">volatile!</a></span><span class="whitespace"> </span><span class="unknown">-1</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/vswap!" title="Non-atomically swaps the value of the volatile as if:
   (apply f current-value-of-vol args). Returns the value that
   was swapped in.">vswap!</a></span><span class="whitespace"> </span><span class="symbol">i</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span>)</span><span class="whitespace"> </span><span class="symbol">input</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/letfn" title="fnspec ==&gt; (fname [params*] exprs) or (fname ([params*] exprs)+)

  Takes a vector of function specs and a body, and generates a set of
  bindings of functions to their names. All of the names are available
  in all of the definitions of the functions, as well as the body.">letfn</a></span><span class="whitespace"> </span><span>[<span>(<span class="symbol">mapi</span><span class="whitespace"> </span><span>[<span class="symbol">idx</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunked-seq?">chunked-seq?</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">c</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-first">chunk-first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span class="symbol">size</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/int" title="Coerce to int">int</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">c</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span class="symbol">b</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-buffer">chunk-buffer</a></span><span class="whitespace"> </span><span class="symbol">size</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/dotimes" title="bindings =&gt; name n

  Repeatedly executes body (presumably for side-effects) with name
  bound to integers from 0 through n-1.">dotimes</a></span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span class="symbol">size</span>]</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-append">chunk-append</a></span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace"> </span><span class="symbol">idx</span><span class="whitespace"> </span><span class="symbol">i</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">.nth</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-cons">chunk-cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk">chunk</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">mapi</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace"> </span><span class="symbol">idx</span><span class="whitespace"> </span><span class="symbol">size</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-rest">chunk-rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">idx</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">mapi</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">idx</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="symbol">mapi</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keep" title="Returns a lazy sequence of the non-nil results of (f item). Note,
  this means false return values will be included.  f must be free of
  side-effects.  Returns a transducer when no collection is provided.">keep</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of the non-nil results of (f item). Note,
  this means false return values will be included.  f must be free of
  side-effects.  Returns a transducer when no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">input</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">result</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunked-seq?">chunked-seq?</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">c</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-first">chunk-first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">size</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">c</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">b</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-buffer">chunk-buffer</a></span><span class="whitespace"> </span><span class="symbol">size</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/dotimes" title="bindings =&gt; name n

  Repeatedly executes body (presumably for side-effects) with name
  bound to integers from 0 through n-1.">dotimes</a></span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span class="symbol">size</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="java-class">.nth</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-append">chunk-append</a></span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-cons">chunk-cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk">chunk</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keep" title="Returns a lazy sequence of the non-nil results of (f item). Note,
  this means false return values will be included.  f must be free of
  side-effects.  Returns a transducer when no collection is provided.">keep</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-rest">chunk-rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keep" title="Returns a lazy sequence of the non-nil results of (f item). Note,
  this means false return values will be included.  f must be free of
  side-effects.  Returns a transducer when no collection is provided.">keep</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keep" title="Returns a lazy sequence of the non-nil results of (f item). Note,
  this means false return values will be included.  f must be free of
  side-effects.  Returns a transducer when no collection is provided.">keep</a></span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keep-indexed" title="Returns a lazy sequence of the non-nil results of (f index item). Note,
  this means false return values will be included.  f must be free of
  side-effects.  Returns a stateful transducer when no collection is
  provided.">keep-indexed</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence of the non-nil results of (f index item). Note,
  this means false return values will be included.  f must be free of
  side-effects.  Returns a stateful transducer when no collection is
  provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.2"</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:static</span><span class="whitespace"> </span><span class="unknown">true</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">iv</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/volatile!" title="Creates and returns a Volatile with an initial value of val.">volatile!</a></span><span class="whitespace"> </span><span class="unknown">-1</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/vswap!" title="Non-atomically swaps the value of the volatile as if:
   (apply f current-value-of-vol args). Returns the value that
   was swapped in.">vswap!</a></span><span class="whitespace"> </span><span class="symbol">iv</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span class="symbol">v</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">i</span><span class="whitespace"> </span><span class="symbol">input</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">v</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span class="symbol">result</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/letfn" title="fnspec ==&gt; (fname [params*] exprs) or (fname ([params*] exprs)+)

  Takes a vector of function specs and a body, and generates a set of
  bindings of functions to their names. All of the names are available
  in all of the definitions of the functions, as well as the body.">letfn</a></span><span class="whitespace"> </span><span>[<span>(<span class="symbol">keepi</span><span class="whitespace"> </span><span>[<span class="symbol">idx</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/lazy-seq" title="Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?">lazy-seq</a></span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">s</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunked-seq?">chunked-seq?</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">c</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-first">chunk-first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">                          </span><span class="symbol">size</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">c</span>)</span><span class="whitespace">
</span><span class="whitespace">                          </span><span class="symbol">b</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-buffer">chunk-buffer</a></span><span class="whitespace"> </span><span class="symbol">size</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/dotimes" title="bindings =&gt; name n

  Repeatedly executes body (presumably for side-effects) with name
  bound to integers from 0 through n-1.">dotimes</a></span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span class="symbol">size</span>]</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace"> </span><span class="symbol">idx</span><span class="whitespace"> </span><span class="symbol">i</span>)</span><span class="whitespace"> </span><span>(<span class="java-class">.nth</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                          </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-not" title="Evaluates test. If logical false, evaluates body in an implicit do.">when-not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-append">chunk-append</a></span><span class="whitespace"> </span><span class="symbol">b</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-cons">chunk-cons</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk">chunk</a></span><span class="whitespace"> </span><span class="symbol">b</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">keepi</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace"> </span><span class="symbol">idx</span><span class="whitespace"> </span><span class="symbol">size</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chunk-rest">chunk-rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">idx</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="symbol">keepi</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">idx</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cons" title="Returns a new seq where x is the first element and seq is
    the rest.">cons</a></span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span>(<span class="symbol">keepi</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">idx</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="symbol">keepi</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every-pred" title="Takes a set of predicates and returns a function f that returns true if all of its
  composing predicates return a logical true value against all of its arguments, else it returns
  false. Note that f is short-circuiting in that it will stop execution on the first
  argument that triggers a logical false result against the original predicates.">every-pred</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a set of predicates and returns a function f that returns true if all of its
  composing predicates return a logical true value against all of its arguments, else it returns
  false. Note that f is short-circuiting in that it will stop execution on the first
  argument that triggers a logical false result against the original predicates."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">p</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">ep1</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span>(<span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">ep1</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace">
</span><span class="whitespace">                                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">p2</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">ep2</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">ep2</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace">
</span><span class="whitespace">                                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span>#(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">p3</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">ep3</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">ep3</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace">
</span><span class="whitespace">                                     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span>#(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">ps</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ps</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list*" title="Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.">list*</a></span><span class="whitespace"> </span><span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">ps</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">epn</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span>#(<span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="symbol">ps</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span>#(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">ps</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span>#(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">ps</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/boolean" title="Coerce to boolean">boolean</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="symbol">epn</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace">
</span><span class="whitespace">                                       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/every?" title="Returns true if (pred x) is logical true for every x in coll, else
  false.">every?</a></span><span class="whitespace"> </span><span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">args</span>)</span><span class="whitespace"> </span><span class="symbol">ps</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some-fn" title="Takes a set of predicates and returns a function f that returns the first logical true value
  returned by one of its composing predicates against any of its arguments, else it returns
  logical false. Note that f is short-circuiting in that it will stop execution on the first
  argument that triggers a logical true result against the original predicates.">some-fn</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes a set of predicates and returns a function f that returns the first logical true value
  returned by one of its composing predicates against any of its arguments, else it returns
  logical false. Note that f is short-circuiting in that it will stop execution on the first
  argument that triggers a logical true result against the original predicates."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">p</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">sp1</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">sp1</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some" title="Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)">some</a></span><span class="whitespace"> </span><span class="symbol">p</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">p2</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">sp2</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">sp2</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some" title="Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)">some</a></span><span class="whitespace"> </span><span>#(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">p3</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">sp3</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">sp3</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace">
</span><span class="whitespace">                           </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some" title="Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)">some</a></span><span class="whitespace"> </span><span>#(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">%</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">args</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">ps</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ps</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list*" title="Creates a new seq containing the items prepended to the rest, the
  last of which will be treated as a sequence.">list*</a></span><span class="whitespace"> </span><span class="symbol">p1</span><span class="whitespace"> </span><span class="symbol">p2</span><span class="whitespace"> </span><span class="symbol">p3</span><span class="whitespace"> </span><span class="symbol">ps</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span class="symbol">spn</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[]</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some" title="Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)">some</a></span><span class="whitespace"> </span><span>#(<span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span class="symbol">ps</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some" title="Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)">some</a></span><span class="whitespace"> </span><span>#(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">y</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">ps</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some" title="Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)">some</a></span><span class="whitespace"> </span><span>#(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">x</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">y</span>)</span><span class="whitespace"> </span><span>(<span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">z</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">ps</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">args</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/or" title="Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn&apos;t
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.">or</a></span><span class="whitespace"> </span><span>(<span class="symbol">spn</span><span class="whitespace"> </span><span class="symbol">x</span><span class="whitespace"> </span><span class="symbol">y</span><span class="whitespace"> </span><span class="symbol">z</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some" title="Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)">some</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some" title="Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)">some</a></span><span class="whitespace"> </span><span class="symbol">%</span><span class="whitespace"> </span><span class="symbol">args</span>)</span><span class="whitespace"> </span><span class="symbol">ps</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:dynamic</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace"> </span><span class="symbol">assert-valid-fdecl</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">fdecl</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/empty?" title="Returns true if coll has no items - same as (not (seq coll)).
  Please use the idiom (seq x) rather than (not (empty? x))">empty?</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span><span class="whitespace"> </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace">
</span><span class="whitespace">                                </span><span class="string">"Parameter declaration missing"</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">argdecls</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                   </span><span>#(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq?" title="Return true if x implements ISeq">seq?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">fdecl</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Invalid signature \""</span><span class="whitespace">
</span><span class="whitespace">                               </span><span class="symbol">%</span><span class="whitespace">
</span><span class="whitespace">                               </span><span class="string">"\" should be a list"</span>)</span><span class="whitespace">
</span><span class="whitespace">                          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Parameter declaration \""</span><span class="whitespace">
</span><span class="whitespace">                               </span><span class="symbol">%</span><span class="whitespace">
</span><span class="whitespace">                               </span><span class="string">"\" should be a vector"</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">fdecl</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">bad-args</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/seq" title="Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object.">seq</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/remove" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns false. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">remove</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vector?" title="Return true if x implements IPersistentVector">vector?</a></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span class="symbol">argdecls</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">bad-args</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="symbol">IllegalArgumentException.</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Parameter declaration \""</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">bad-args</span>)</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">                                             </span><span class="string">"\" should be a vector"</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-redefs-fn" title="Temporarily redefines Vars during a call to func.  Each val of
  binding-map will replace the root value of its key which must be
  a Var.  After func is called with no args, the root values of all
  the Vars will be set back to their old values.  These temporary
  changes will be visible in all threads.  Useful for mocking out
  functions during testing.">with-redefs-fn</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Temporarily redefines Vars during a call to func.  Each val of
  binding-map will replace the root value of its key which must be
  a Var.  After func is called with no args, the root values of all
  the Vars will be set back to their old values.  These temporary
  changes will be visible in all threads.  Useful for mocking out
  functions during testing."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">binding-map</span><span class="whitespace"> </span><span class="symbol">func</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">root-bind</span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">m</span>]</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/doseq" title="Repeatedly executes body (presumably for side-effects) with
  bindings and filtering as provided by &quot;for&quot;.  Does not retain
  the head of the sequence. Returns nil.">doseq</a></span><span class="whitespace"> </span><span>[<span>[<span class="symbol">a-var</span><span class="whitespace"> </span><span class="symbol">a-val</span>]</span><span class="whitespace"> </span><span class="symbol">m</span>]</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="java-class">.bindRoot</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Var</span></span><span class="whitespace"> </span><span class="symbol">a-var</span><span class="whitespace"> </span><span class="symbol">a-val</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">old-vals</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/zipmap" title="Returns a map with the keys mapped to the corresponding vals.">zipmap</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span><span class="whitespace"> </span><span class="symbol">binding-map</span>)</span><span class="whitespace">
</span><span class="whitespace">                         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="java-class">.getRawRoot</span><span class="whitespace"> </span><span>^<span class="java-class">clojure.lang.Var</span></span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keys" title="Returns a sequence of the map&apos;s keys, in the same order as (seq map).">keys</a></span><span class="whitespace"> </span><span class="symbol">binding-map</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">try</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">root-bind</span><span class="whitespace"> </span><span class="symbol">binding-map</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">func</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">finally</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="symbol">root-bind</span><span class="whitespace"> </span><span class="symbol">old-vals</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-redefs" title="binding =&gt; var-symbol temp-value-expr

  Temporarily redefines Vars while executing the body.  The
  temp-value-exprs will be evaluated and each resulting value will
  replace in parallel the root value of its Var.  After the body is
  executed, the root values of all the Vars will be set back to their
  old values.  These temporary changes will be visible in all threads.
  Useful for mocking out functions during testing.">with-redefs</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"binding => var-symbol temp-value-expr

  Temporarily redefines Vars while executing the body.  The
  temp-value-exprs will be evaluated and each resulting value will
  replace in parallel the root value of its Var.  After the body is
  executed, the root values of all the Vars will be set back to their
  old values.  These temporary changes will be visible in all threads.
  Useful for mocking out functions during testing."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">bindings</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/with-redefs-fn" title="Temporarily redefines Vars during a call to func.  Each val of
  binding-map will replace the root value of its key which must be
  a Var.  After func is called with no args, the root values of all
  the Vars will be set back to their old values.  These temporary
  changes will be visible in all threads.  Useful for mocking out
  functions during testing.">with-redefs-fn</a></span><span class="whitespace"> </span>~<span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/zipmap" title="Returns a map with the keys mapped to the corresponding vals.">zipmap</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>#(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/list" title="Creates a new list containing the items.">list</a></span><span class="whitespace"> </span>`<span class="macro">var</span><span class="whitespace"> </span><span class="symbol">%</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-nth" title="Returns a lazy seq of every nth item in coll.  Returns a stateful
  transducer when no collection is provided.">take-nth</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                            </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/take-nth" title="Returns a lazy seq of every nth item in coll.  Returns a stateful
  transducer when no collection is provided.">take-nth</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">bindings</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[]</span><span class="whitespace"> </span>~<span class="unknown">@body</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/realized?" title="Returns true if a value has been produced for a promise, delay, future or lazy sequence.">realized?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns true if a value has been produced for a promise, delay, future or lazy sequence."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.3"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.IPending</span></span><span class="whitespace"> </span><span class="symbol">x</span>]</span><span class="whitespace"> </span><span>(<span class="java-class">.isRealized</span><span class="whitespace"> </span><span class="symbol">x</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond-&gt;" title="Takes an expression and a set of test/form pairs. Threads expr (via -&gt;)
  through each form for which the corresponding test
  expression is true. Note that, unlike cond branching, cond-&gt; threading does
  not short circuit after the first true test expression.">cond-></a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes an expression and a set of test/form pairs. Threads expr (via ->)
  through each form for which the corresponding test
  expression is true. Note that, unlike cond branching, cond-> threading does
  not short circuit after the first true test expression."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.5"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">expr</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">clauses</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/assert" title="Evaluates expr and throws an exception if it does not evaluate to
  logical true.">assert</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/even?" title="Returns true if n is even, throws an exception if n is not an integer">even?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">clauses</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">g</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">steps</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="symbol">step</span>]</span>]</span><span class="whitespace"> </span>`<span>(<span class="macro">if</span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span>~<span class="symbol">g</span><span class="whitespace"> </span>~<span class="symbol">step</span>)</span><span class="whitespace"> </span>~<span class="symbol">g</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition" title="Returns a lazy sequence of lists of n items each, at offsets step
  apart. If step is not supplied, defaults to n, i.e. the partitions
  do not overlap. If a pad collection is supplied, use its elements as
  necessary to complete last partition upto n items. In case there are
  not enough padding elements, return a partition with less than n items.">partition</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span class="symbol">clauses</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">g</span><span class="whitespace"> </span>~<span class="symbol">expr</span><span class="whitespace">
</span><span class="whitespace">           </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interleave" title="Returns a lazy seq of the first item in each coll, then the second etc.">interleave</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/repeat" title="Returns a lazy (infinite!, or length n if supplied) sequence of xs.">repeat</a></span><span class="whitespace"> </span><span class="symbol">g</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/butlast" title="Return a seq of all but the last item in coll, in linear time">butlast</a></span><span class="whitespace"> </span><span class="symbol">steps</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span>~<span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/empty?" title="Returns true if coll has no items - same as (not (seq coll)).
  Please use the idiom (seq x) rather than (not (empty? x))">empty?</a></span><span class="whitespace"> </span><span class="symbol">steps</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">g</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/last" title="Return the last item in coll, in linear time">last</a></span><span class="whitespace"> </span><span class="symbol">steps</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond-&gt;&gt;" title="Takes an expression and a set of test/form pairs. Threads expr (via -&gt;&gt;)
  through each form for which the corresponding test expression
  is true.  Note that, unlike cond branching, cond-&gt;&gt; threading does not short circuit
  after the first true test expression.">cond->></a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Takes an expression and a set of test/form pairs. Threads expr (via ->>)
  through each form for which the corresponding test expression
  is true.  Note that, unlike cond branching, cond->> threading does not short circuit
  after the first true test expression."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.5"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">expr</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">clauses</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/assert" title="Evaluates expr and throws an exception if it does not evaluate to
  logical true.">assert</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/even?" title="Returns true if n is even, throws an exception if n is not an integer">even?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span class="symbol">clauses</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">g</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">steps</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span class="symbol">step</span>]</span>]</span><span class="whitespace"> </span>`<span>(<span class="macro">if</span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/test" title="test [v] finds fn at key :test in var metadata and calls it,
  presuming failure will throw exception">test</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;&gt;" title="Threads the expr through the forms. Inserts x as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  last item in second form, etc.">->></a></span><span class="whitespace"> </span>~<span class="symbol">g</span><span class="whitespace"> </span>~<span class="symbol">step</span>)</span><span class="whitespace"> </span>~<span class="symbol">g</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/partition" title="Returns a lazy sequence of lists of n items each, at offsets step
  apart. If step is not supplied, defaults to n, i.e. the partitions
  do not overlap. If a pad collection is supplied, use its elements as
  necessary to complete last partition upto n items. In case there are
  not enough padding elements, return a partition with less than n items.">partition</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span class="symbol">clauses</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">g</span><span class="whitespace"> </span>~<span class="symbol">expr</span><span class="whitespace">
</span><span class="whitespace">           </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interleave" title="Returns a lazy seq of the first item in each coll, then the second etc.">interleave</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/repeat" title="Returns a lazy (infinite!, or length n if supplied) sequence of xs.">repeat</a></span><span class="whitespace"> </span><span class="symbol">g</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/butlast" title="Return a seq of all but the last item in coll, in linear time">butlast</a></span><span class="whitespace"> </span><span class="symbol">steps</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span>~<span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/empty?" title="Returns true if coll has no items - same as (not (seq coll)).
  Please use the idiom (seq x) rather than (not (empty? x))">empty?</a></span><span class="whitespace"> </span><span class="symbol">steps</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">g</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/last" title="Return the last item in coll, in linear time">last</a></span><span class="whitespace"> </span><span class="symbol">steps</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/as-&gt;" title="Binds name to expr, evaluates the first form in the lexical context
  of that binding, then binds name to that result, repeating for each
  successive form, returning the result of the last form.">as-></a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Binds name to expr, evaluates the first form in the lexical context
  of that binding, then binds name to that result, repeating for each
  successive form, returning the result of the last form."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.5"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">expr</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">forms</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span>~<span class="symbol">expr</span><span class="whitespace">
</span><span class="whitespace">         </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interleave" title="Returns a lazy seq of the first item in each coll, then the second etc.">interleave</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/repeat" title="Returns a lazy (infinite!, or length n if supplied) sequence of xs.">repeat</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/butlast" title="Return a seq of all but the last item in coll, in linear time">butlast</a></span><span class="whitespace"> </span><span class="symbol">forms</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span>~<span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/empty?" title="Returns true if coll has no items - same as (not (seq coll)).
  Please use the idiom (seq x) rather than (not (empty? x))">empty?</a></span><span class="whitespace"> </span><span class="symbol">forms</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/last" title="Return the last item in coll, in linear time">last</a></span><span class="whitespace"> </span><span class="symbol">forms</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/some-&gt;" title="When expr is not nil, threads it into the first form (via -&gt;),
  and when that result is not nil, through the next etc">some-></a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"When expr is not nil, threads it into the first form (via ->),
  and when that result is not nil, through the next etc"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.5"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">expr</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">forms</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">g</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">steps</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">step</span>]</span><span class="whitespace"> </span>`<span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span>~<span class="symbol">g</span>)</span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span>~<span class="symbol">g</span><span class="whitespace"> </span>~<span class="symbol">step</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">forms</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">g</span><span class="whitespace"> </span>~<span class="symbol">expr</span><span class="whitespace">
</span><span class="whitespace">           </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interleave" title="Returns a lazy seq of the first item in each coll, then the second etc.">interleave</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/repeat" title="Returns a lazy (infinite!, or length n if supplied) sequence of xs.">repeat</a></span><span class="whitespace"> </span><span class="symbol">g</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/butlast" title="Return a seq of all but the last item in coll, in linear time">butlast</a></span><span class="whitespace"> </span><span class="symbol">steps</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span>~<span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/empty?" title="Returns true if coll has no items - same as (not (seq coll)).
  Please use the idiom (seq x) rather than (not (empty? x))">empty?</a></span><span class="whitespace"> </span><span class="symbol">steps</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">g</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/last" title="Return the last item in coll, in linear time">last</a></span><span class="whitespace"> </span><span class="symbol">steps</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/some-&gt;&gt;" title="When expr is not nil, threads it into the first form (via -&gt;&gt;),
  and when that result is not nil, through the next etc">some->></a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"When expr is not nil, threads it into the first form (via ->>),
  and when that result is not nil, through the next etc"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.5"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">expr</span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">forms</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">g</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/gensym" title="Returns a new symbol with a unique name. If a prefix string is
  supplied, the name is prefix# where # is some unique number. If
  prefix is not supplied, the prefix is &apos;G__&apos;.">gensym</a></span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="symbol">steps</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map" title="Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.">map</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">step</span>]</span><span class="whitespace"> </span>`<span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span>~<span class="symbol">g</span>)</span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;&gt;" title="Threads the expr through the forms. Inserts x as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  last item in second form, etc.">->></a></span><span class="whitespace"> </span>~<span class="symbol">g</span><span class="whitespace"> </span>~<span class="symbol">step</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                   </span><span class="symbol">forms</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[~<span class="symbol">g</span><span class="whitespace"> </span>~<span class="symbol">expr</span><span class="whitespace">
</span><span class="whitespace">           </span>~<span class="unparsed">@</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/interleave" title="Returns a lazy seq of the first item in each coll, then the second etc.">interleave</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/repeat" title="Returns a lazy (infinite!, or length n if supplied) sequence of xs.">repeat</a></span><span class="whitespace"> </span><span class="symbol">g</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/butlast" title="Return a seq of all but the last item in coll, in linear time">butlast</a></span><span class="whitespace"> </span><span class="symbol">steps</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span>~<span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/empty?" title="Returns true if coll has no items - same as (not (seq coll)).
  Please use the idiom (seq x) rather than (not (empty? x))">empty?</a></span><span class="whitespace"> </span><span class="symbol">steps</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">g</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/last" title="Return the last item in coll, in linear time">last</a></span><span class="whitespace"> </span><span class="symbol">steps</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span>^<span class="keyword">:private</span></span><span class="whitespace"> </span><span class="symbol">preserving-reduced</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>#(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ret</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">%1</span><span class="whitespace"> </span><span class="symbol">%2</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduced?" title="Returns true if x is the result of a call to reduced">reduced?</a></span><span class="whitespace"> </span><span class="symbol">ret</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduced" title="Wraps x in a way such that a reduce will terminate with the value x">reduced</a></span><span class="whitespace"> </span><span class="symbol">ret</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span class="symbol">ret</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/cat" title="A transducer which concatenates the contents of each input, which must be a
  collection, into the reduction.">cat</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"A transducer which concatenates the contents of each input, which must be a
  collection, into the reduction."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">rrf</span><span class="whitespace"> </span><span>(<span class="symbol">preserving-reduced</span><span class="whitespace"> </span><span class="symbol">rf</span>)</span>]</span><span class="whitespace">  </span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduce" title="f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.">reduce</a></span><span class="whitespace"> </span><span class="symbol">rrf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dedupe" title="Returns a lazy sequence removing consecutive duplicates in coll.
  Returns a transducer when no collection is provided.">dedupe</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a lazy sequence removing consecutive duplicates in coll.
  Returns a transducer when no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">rf</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">pv</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/volatile!" title="Creates and returns a Volatile with an initial value of val.">volatile!</a></span><span class="whitespace"> </span><span class="keyword">::none</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="macro">fn</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">result</span>]</span><span class="whitespace"> </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span>[<span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">prior</span><span class="whitespace"> </span><span class="unknown">@pv</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/vreset!" title="Sets the value of volatile to newval without regard for the
   current value. Returns newval.">vreset!</a></span><span class="whitespace"> </span><span class="symbol">pv</span><span class="whitespace"> </span><span class="symbol">input</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">prior</span><span class="whitespace"> </span><span class="symbol">input</span>)</span><span class="whitespace">
</span><span class="whitespace">                </span><span class="symbol">result</span><span class="whitespace">
</span><span class="whitespace">                </span><span>(<span class="symbol">rf</span><span class="whitespace"> </span><span class="symbol">result</span><span class="whitespace"> </span><span class="symbol">input</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">coll</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/sequence" title="Coerces coll to a (possibly empty) sequence, if it is not already
  one. Will not force a lazy seq. (sequence nil) yields (), When a
  transducer is supplied, returns a lazy sequence of applications of
  the transform to the items in coll(s), i.e. to the set of first
  items of each coll, followed by the set of second
  items in each coll, until any one of the colls is exhausted.  Any
  remaining items in other colls are ignored. The transform should accept
  number-of-colls arguments">sequence</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dedupe" title="Returns a lazy sequence removing consecutive duplicates in coll.
  Returns a transducer when no collection is provided.">dedupe</a></span>)</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/random-sample" title="Returns items from coll with random probability of prob (0.0 -
  1.0).  Returns a transducer when no collection is provided.">random-sample</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns items from coll with random probability of prob (0.0 -
  1.0).  Returns a transducer when no collection is provided."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">prob</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filter" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">filter</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">_</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rand" title="Returns a random floating point number between 0 (inclusive) and
  n (default 1) (exclusive).">rand</a></span>)</span><span class="whitespace"> </span><span class="symbol">prob</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span>[<span class="symbol">prob</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/filter" title="Returns a lazy sequence of the items in coll for which
  (pred item) returns true. pred must be free of side-effects.
  Returns a transducer when no collection is provided.">filter</a></span><span class="whitespace"> </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">_</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rand" title="Returns a random floating point number between 0 (inclusive) and
  n (default 1) (exclusive).">rand</a></span>)</span><span class="whitespace"> </span><span class="symbol">prob</span>)</span>)</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/deftype" title="(deftype name [fields*]  options* specs*)

  Options are expressed as sequential keywords and arguments (in any order).

  Supported options:
  :load-ns - if true, importing the record class will cause the
             namespace in which the record was defined to be loaded.
             Defaults to false.

  Each spec consists of a protocol or interface name followed by zero
  or more method bodies:

  protocol-or-interface-or-Object
  (methodName [args*] body)*

  Dynamically generates compiled bytecode for class with the given
  name, in a package with the same name as the current namespace, the
  given fields, and, optionally, methods for protocols and/or
  interfaces. 

  The class will have the (by default, immutable) fields named by
  fields, which can have type hints. Protocols/interfaces and methods
  are optional. The only methods that can be supplied are those
  declared in the protocols/interfaces.  Note that method bodies are
  not closures, the local environment includes only the named fields,
  and those fields can be accessed directly. Fields can be qualified
  with the metadata :volatile-mutable true or :unsynchronized-mutable
  true, at which point (set! afield aval) will be supported in method
  bodies. Note well that mutable fields are extremely difficult to use
  correctly, and are present only to facilitate the building of higher
  level constructs, such as Clojure&apos;s reference types, in Clojure
  itself. They are for experts only - if the semantics and
  implications of :volatile-mutable or :unsynchronized-mutable are not
  immediately apparent to you, you should not be using them.

  Method definitions take the form:

  (methodname [args*] body)

  The argument and return types can be hinted on the arg and
  methodname symbols. If not supplied, they will be inferred, so type
  hints should be reserved for disambiguation.

  Methods should be supplied for all methods of the desired
  protocol(s) and interface(s). You can also define overrides for
  methods of Object. Note that a parameter must be supplied to
  correspond to the target object (&apos;this&apos; in Java parlance). Thus
  methods for interfaces will take one more argument than do the
  interface declarations. Note also that recur calls to the method
  head should *not* pass the target object, it will be supplied
  automatically and can not be substituted.

  In the method bodies, the (unqualified) name can be used to name the
  class (for calls to new, instance? etc).

  When AOT compiling, generates compiled bytecode for a class with the
  given name (a symbol), prepends the current ns as the package, and
  writes the .class file to the *compile-path* directory.

  One constructor will be defined, taking the designated fields.  Note
  that the field names __meta and __extmap are currently reserved and
  should not be used when defining your own types.

  Given (deftype TypeName ...), a factory function called -&gt;TypeName
  will be defined, taking positional parameters for the fields">deftype</a></span><span class="whitespace"> </span><span class="symbol">Eduction</span><span class="whitespace"> </span><span>[<span class="symbol">xform</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="java-class">Iterable</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="symbol">iterator</span><span class="whitespace"> </span><span>[<span class="symbol">_</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">clojure.lang.TransformerIterator/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">xform</span><span class="whitespace"> </span><span>(<span class="java-class">clojure.lang.RT/<span class="symbol">iter</span></span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="java-class">clojure.lang.IReduceInit</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduce" title="f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.">reduce</a></span><span class="whitespace"> </span><span>[<span class="symbol">_</span><span class="whitespace"> </span><span class="symbol">f</span><span class="whitespace"> </span><span class="symbol">init</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="comment">;; NB (completing f) isolates completion of inner rf from outer rf</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transduce" title="reduce with a transformation of f (xf). If init is not
  supplied, (f) will be called to produce it. f should be a reducing
  step function that accepts both 1 and 2 arguments, if it accepts
  only 2 you can add the arity-1 with &apos;completing&apos;. Returns the result
  of applying (the transformed) xf to init and the first item in coll,
  then applying xf to that result and the 2nd item, etc. If coll
  contains no items, returns init and f is not called. Note that
  certain transforms may inject or skip items.">transduce</a></span><span class="whitespace"> </span><span class="symbol">xform</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/completing" title="Takes a reducing function f of 2 args and returns a fn suitable for
  transduce by adding an arity-1 signature that calls cf (default -
  identity) on the result argument.">completing</a></span><span class="whitespace"> </span><span class="symbol">f</span>)</span><span class="whitespace"> </span><span class="symbol">init</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="java-class">clojure.lang.Sequential</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/eduction" title="Returns a reducible/iterable application of the transducers
  to the items in coll. Transducers are applied in order as if
  combined with comp. Note that these applications will be
  performed every time reduce/iterator is called.">eduction</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Returns a reducible/iterable application of the transducers
  to the items in coll. Transducers are applied in order as if
  combined with comp. Note that these applications will be
  performed every time reduce/iterator is called."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:arglists</span><span class="whitespace"> </span><span>'<span>(<span>[<span class="symbol">xform*</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span>)</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">xforms</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="symbol">Eduction.</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/apply" title="Applies fn f to the argument list formed by prepending intervening arguments to args.">apply</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/comp" title="Takes a set of functions and returns a fn that is the composition
  of those fns.  The returned fn takes a variable number of args,
  applies the rightmost of fns to the args, the next
  fn (right-to-left) to the result, etc.">comp</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/butlast" title="Return a seq of all but the last item in coll, in linear time">butlast</a></span><span class="whitespace"> </span><span class="symbol">xforms</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/last" title="Return the last item in coll, in linear time">last</a></span><span class="whitespace"> </span><span class="symbol">xforms</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmethod" title="Creates and installs a new method of multimethod associated with dispatch-value. ">defmethod</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/print-method">print-method</a></span><span class="whitespace"> </span><span class="symbol">Eduction</span><span class="whitespace"> </span><span>[<span class="symbol">c</span><span class="whitespace">, </span><span>^<span class="symbol">Writer</span></span><span class="whitespace"> </span><span class="symbol">w</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*print-readably*" title="When set to logical false, strings and characters will be printed with
  non-alphanumeric characters converted to the appropriate escape sequences.

  Defaults to true">*print-readably*</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">do</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="symbol">print-sequential</span><span class="whitespace"> </span><span class="string">"("</span><span class="whitespace"> </span><span class="symbol">pr-on</span><span class="whitespace"> </span><span class="string">" "</span><span class="whitespace"> </span><span class="string">")"</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">w</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">print-object</span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace"> </span><span class="symbol">w</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/run!" title="Runs the supplied procedure (via reduce), for purposes of side
  effects, on successive items in the collection. Returns nil">run!</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Runs the supplied procedure (via reduce), for purposes of side
  effects, on successive items in the collection. Returns nil"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">proc</span><span class="whitespace"> </span><span class="symbol">coll</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduce" title="f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.">reduce</a></span><span class="whitespace"> </span><span>#(<span class="symbol">proc</span><span class="whitespace"> </span><span class="symbol">%2</span>)</span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace"> </span><span class="symbol">coll</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/tagged-literal?" title="Return true if the value is the data representation of a tagged literal">tagged-literal?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Return true if the value is the data representation of a tagged literal"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">value</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.TaggedLiteral</span><span class="whitespace"> </span><span class="symbol">value</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/tagged-literal" title="Construct a data representation of a tagged literal from a
  tag symbol and a form.">tagged-literal</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Construct a data representation of a tagged literal from a
  tag symbol and a form."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">clojure.lang.Symbol</span></span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span class="symbol">form</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">clojure.lang.TaggedLiteral/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">tag</span><span class="whitespace"> </span><span class="symbol">form</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reader-conditional?" title="Return true if the value is the data representation of a reader conditional">reader-conditional?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Return true if the value is the data representation of a reader conditional"</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">value</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/instance?" title="Evaluates x and tests if it is an instance of the class
    c. Returns true or false">instance?</a></span><span class="whitespace"> </span><span class="java-class">clojure.lang.ReaderConditional</span><span class="whitespace"> </span><span class="symbol">value</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reader-conditional" title="Construct a data representation of a reader conditional.
  If true, splicing? indicates read-cond-splicing.">reader-conditional</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Construct a data representation of a reader conditional.
  If true, splicing? indicates read-cond-splicing."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.7"</span>}</span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">form</span><span class="whitespace"> </span><span>^<span class="java-class">Boolean</span></span><span class="whitespace"> </span><span class="symbol">splicing?</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="java-class">clojure.lang.ReaderConditional/<span class="symbol">create</span></span><span class="whitespace"> </span><span class="symbol">form</span><span class="whitespace"> </span><span class="symbol">splicing?</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="comment">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; data readers ;;;;;;;;;;;;;;;;;;</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.4"</span>}</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/default-data-readers" title="Default map of data reader functions provided by Clojure. May be
  overridden by binding *data-readers*.">default-data-readers</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Default map of data reader functions provided by Clojure. May be
  overridden by binding *data-readers*."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span>'<span class="symbol">inst</span></span><span class="whitespace"> </span><span>#'<span class="var-ref">clojure.instant/read-instant-date</span></span><span class="whitespace">
</span><span class="whitespace">   </span><span>'<span class="symbol">uuid</span></span><span class="whitespace"> </span><span>#'<span class="var-ref">clojure.uuid/default-uuid-reader</span></span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.4"</span><span class="whitespace"> </span><span class="keyword">:dynamic</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*data-readers*" title="Map from reader tag symbols to data reader Vars.

  When Clojure starts, it searches for files named &apos;data_readers.clj&apos;
  at the root of the classpath. Each such file must contain a literal
  map of symbols, like this:

      {foo/bar my.project.foo/bar
       foo/baz my.project/baz}

  The first symbol in each pair is a tag that will be recognized by
  the Clojure reader. The second symbol in the pair is the
  fully-qualified name of a Var which will be invoked by the reader to
  parse the form following the tag. For example, given the
  data_readers.clj file above, the Clojure reader would parse this
  form:

      #foo/bar [1 2 3]

  by invoking the Var #&apos;my.project.foo/bar on the vector [1 2 3]. The
  data reader function is invoked on the form AFTER it has been read
  as a normal Clojure data structure by the reader.

  Reader tags without namespace qualifiers are reserved for
  Clojure. Default reader tags are defined in
  clojure.core/default-data-readers but may be overridden in
  data_readers.clj or by rebinding this Var.">*data-readers*</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"Map from reader tag symbols to data reader Vars.

  When Clojure starts, it searches for files named 'data_readers.clj'
  at the root of the classpath. Each such file must contain a literal
  map of symbols, like this:

      {foo/bar my.project.foo/bar
       foo/baz my.project/baz}

  The first symbol in each pair is a tag that will be recognized by
  the Clojure reader. The second symbol in the pair is the
  fully-qualified name of a Var which will be invoked by the reader to
  parse the form following the tag. For example, given the
  data_readers.clj file above, the Clojure reader would parse this
  form:

      #foo/bar [1 2 3]

  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The
  data reader function is invoked on the form AFTER it has been read
  as a normal Clojure data structure by the reader.

  Reader tags without namespace qualifiers are reserved for
  Clojure. Default reader tags are defined in
  clojure.core/default-data-readers but may be overridden in
  data_readers.clj or by rebinding this Var."</span><span class="whitespace">
</span><span class="whitespace">  </span><span>{}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span>{<span class="keyword">:added</span><span class="whitespace"> </span><span class="string">"1.5"</span><span class="whitespace"> </span><span class="keyword">:dynamic</span><span class="whitespace"> </span><span class="unknown">true</span>}</span></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*default-data-reader-fn*" title="When no data reader is found for a tag and *default-data-reader-fn*
  is non-nil, it will be called with two arguments,
  the tag and the value.  If *default-data-reader-fn* is nil (the
  default), an exception will be thrown for the unknown tag.">*default-data-reader-fn*</a></span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">  </span><span class="string">"When no data reader is found for a tag and *default-data-reader-fn*
  is non-nil, it will be called with two arguments,
  the tag and the value.  If *default-data-reader-fn* is nil (the
  default), an exception will be thrown for the unknown tag."</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="unparsed">nil</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">data-reader-urls</span><span class="whitespace"> </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">cl</span><span class="whitespace"> </span><span>(<span class="java-class">..</span><span class="whitespace"> </span><span class="java-class">Thread</span><span class="whitespace"> </span><span class="symbol">currentThread</span><span class="whitespace"> </span><span class="symbol">getContextClassLoader</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/concat" title="Returns a lazy seq representing the concatenation of the elements in the supplied colls.">concat</a></span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/enumeration-seq" title="Returns a seq on a java.util.Enumeration">enumeration-seq</a></span><span class="whitespace"> </span><span>(<span class="java-class">.getResources</span><span class="whitespace"> </span><span class="symbol">cl</span><span class="whitespace"> </span><span class="string">"data_readers.clj"</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/enumeration-seq" title="Returns a seq on a java.util.Enumeration">enumeration-seq</a></span><span class="whitespace"> </span><span>(<span class="java-class">.getResources</span><span class="whitespace"> </span><span class="symbol">cl</span><span class="whitespace"> </span><span class="string">"data_readers.cljc"</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">data-reader-var</span><span class="whitespace"> </span><span>[<span class="symbol">sym</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/intern" title="Finds or creates a var named by the symbol name in the namespace
  ns (which can be a symbol or a namespace), setting its root binding
  to val if supplied. The namespace must exist. The var will adopt any
  metadata from the name symbol.  Returns the var.">intern</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/create-ns" title="Create a new namespace named by the symbol if one doesn&apos;t already
  exist, returns it or the already-existing namespace of the same
  name.">create-ns</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol" title="Returns a Symbol with the given namespace and name.">symbol</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/namespace" title="Returns the namespace String of a symbol or keyword, or nil if not present.">namespace</a></span><span class="whitespace"> </span><span class="symbol">sym</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol" title="Returns a Symbol with the given namespace and name.">symbol</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">sym</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">load-data-reader-file</span><span class="whitespace"> </span><span>[<span class="symbol">mappings</span><span class="whitespace"> </span><span>^<span class="java-class">java.net.URL</span></span><span class="whitespace"> </span><span class="symbol">url</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/with-open" title="bindings =&gt; [name init ...]

  Evaluates body in a try expression with names bound to the values
  of the inits, and a finally clause that calls (.close name) on each
  name in reverse order.">with-open</a></span><span class="whitespace"> </span><span>[<span class="symbol">rdr</span><span class="whitespace"> </span><span>(<span class="symbol">clojure.lang.LineNumberingPushbackReader.</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="symbol">java.io.InputStreamReader.</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="java-class">.openStream</span><span class="whitespace"> </span><span class="symbol">url</span>)</span><span class="whitespace"> </span><span class="string">"UTF-8"</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/binding" title="binding =&gt; var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.">binding</a></span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*file*" title="The path of the file being evaluated, as a String.

  When there is no file, e.g. in the REPL, the value is not defined.">*file*</a></span><span class="whitespace"> </span><span>(<span class="java-class">.getFile</span><span class="whitespace"> </span><span class="symbol">url</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">read-opts</span><span class="whitespace"> </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="java-class">.endsWith</span><span class="whitespace"> </span><span>(<span class="java-class">.getPath</span><span class="whitespace"> </span><span class="symbol">url</span>)</span><span class="whitespace"> </span><span class="string">"cljc"</span>)</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>{<span class="keyword">:eof</span><span class="whitespace"> </span><span class="unparsed">nil</span><span class="whitespace"> </span><span class="keyword">:read-cond</span><span class="whitespace"> </span><span class="keyword">:allow</span>}</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>{<span class="keyword">:eof</span><span class="whitespace"> </span><span class="unparsed">nil</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="symbol">new-mappings</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/read" title="Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of *in*.

  Opts is a persistent map with valid keys:
    :read-cond - :allow to process reader conditionals, or
                 :preserve to keep all branches
    :features - persistent set of feature keywords for reader conditionals
    :eof - on eof, return value unless :eofthrow, then throw.
           if not specified, will throw

  Note that read can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read">read</a></span><span class="whitespace"> </span><span class="symbol">read-opts</span><span class="whitespace"> </span><span class="symbol">rdr</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/map?" title="Return true if x implements IPersistentMap">map?</a></span><span class="whitespace"> </span><span class="symbol">new-mappings</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ex-info" title="Create an instance of ExceptionInfo, a RuntimeException subclass
   that carries a map of additional data.">ex-info</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Not a valid data-reader map"</span>)</span><span class="whitespace">
</span><span class="whitespace">                          </span><span>{<span class="keyword">:url</span><span class="whitespace"> </span><span class="symbol">url</span>}</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduce" title="f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.">reduce</a></span><span class="whitespace">
</span><span class="whitespace">         </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span>[<span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">v</span>]</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="symbol">k</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ex-info" title="Create an instance of ExceptionInfo, a RuntimeException subclass
   that carries a map of additional data.">ex-info</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"Invalid form in data-reader file"</span>)</span><span class="whitespace">
</span><span class="whitespace">                             </span><span>{<span class="keyword">:url</span><span class="whitespace"> </span><span class="symbol">url</span><span class="whitespace">
</span><span class="whitespace">                              </span><span class="keyword">:form</span><span class="whitespace"> </span><span class="symbol">k</span>}</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">           </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">v-var</span><span class="whitespace"> </span><span>(<span class="symbol">data-reader-var</span><span class="whitespace"> </span><span class="symbol">v</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/contains?" title="Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. &apos;contains?&apos; operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also &apos;some&apos;.">contains?</a></span><span class="whitespace"> </span><span class="symbol">mappings</span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace">
</span><span class="whitespace">                        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not=" title="Same as (not (= obj1 obj2))">not=</a></span><span class="whitespace"> </span><span>(<span class="symbol">mappings</span><span class="whitespace"> </span><span class="symbol">k</span>)</span><span class="whitespace"> </span><span class="symbol">v-var</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ex-info" title="Create an instance of ExceptionInfo, a RuntimeException subclass
   that carries a map of additional data.">ex-info</a></span><span class="whitespace"> </span><span class="string">"Conflicting data-reader mapping"</span><span class="whitespace">
</span><span class="whitespace">                               </span><span>{<span class="keyword">:url</span><span class="whitespace"> </span><span class="symbol">url</span><span class="whitespace">
</span><span class="whitespace">                                </span><span class="keyword">:conflict</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace">
</span><span class="whitespace">                                </span><span class="keyword">:mappings</span><span class="whitespace"> </span><span class="symbol">m</span>}</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">m</span><span class="whitespace"> </span><span class="symbol">k</span><span class="whitespace"> </span><span class="symbol">v-var</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">mappings</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">new-mappings</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn-" title="same as defn, yielding non-public def">defn-</a></span><span class="whitespace"> </span><span class="symbol">load-data-readers</span><span class="whitespace"> </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/alter-var-root" title="Atomically alters the root binding of var v by applying f to its
  current value plus any args">alter-var-root</a></span><span class="whitespace"> </span><span>#'<span class="var-ref">*data-readers*</span></span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="macro">fn</span><span class="whitespace"> </span><span>[<span class="symbol">mappings</span>]</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/reduce" title="f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.">reduce</a></span><span class="whitespace"> </span><span class="symbol">load-data-reader-file</span><span class="whitespace">
</span><span class="whitespace">                            </span><span class="symbol">mappings</span><span class="whitespace"> </span><span>(<span class="symbol">data-reader-urls</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">try</span><span class="whitespace">
</span><span class="whitespace"> </span><span>(<span class="symbol">load-data-readers</span>)</span><span class="whitespace">
</span><span class="whitespace"> </span><span>(<span class="symbol">catch</span><span class="whitespace"> </span><span class="java-class">Throwable</span><span class="whitespace"> </span><span class="symbol">t</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="java-class">.printStackTrace</span><span class="whitespace"> </span><span class="symbol">t</span>)</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>)</span>)</span><span class="whitespace">
</span></code></pre></div></head>