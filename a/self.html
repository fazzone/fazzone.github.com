<head><link href="/Users/russell/src/autochrome/code.css" rel="stylesheet" /><div class="container"><pre><code class="gutter"><span class="punctuation" id="L1">0001
</span><span class="punctuation" id="L2">0002
</span><span class="punctuation" id="L3">0003
</span><span class="punctuation" id="L4">0004
</span><span class="punctuation" id="L5">0005
</span><span class="punctuation" id="L6">0006
</span><span class="punctuation" id="L7">0007
</span><span class="punctuation" id="L8">0008
</span><span class="punctuation" id="L9">0009
</span><span class="punctuation" id="L10">0010
</span><span class="punctuation" id="L11">0011
</span><span class="punctuation" id="L12">0012
</span><span class="punctuation" id="L13">0013
</span><span class="punctuation" id="L14">0014
</span><span class="punctuation" id="L15">0015
</span><span class="punctuation" id="L16">0016
</span><span class="punctuation" id="L17">0017
</span><span class="punctuation" id="L18">0018
</span><span class="punctuation" id="L19">0019
</span><span class="punctuation" id="L20">0020
</span><span class="punctuation" id="L21">0021
</span><span class="punctuation" id="L22">0022
</span><span class="punctuation" id="L23">0023
</span><span class="punctuation" id="L24">0024
</span><span class="punctuation" id="L25">0025
</span><span class="punctuation" id="L26">0026
</span><span class="punctuation" id="L27">0027
</span><span class="punctuation" id="L28">0028
</span><span class="punctuation" id="L29">0029
</span><span class="punctuation" id="L30">0030
</span><span class="punctuation" id="L31">0031
</span><span class="punctuation" id="L32">0032
</span><span class="punctuation" id="L33">0033
</span><span class="punctuation" id="L34">0034
</span><span class="punctuation" id="L35">0035
</span><span class="punctuation" id="L36">0036
</span><span class="punctuation" id="L37">0037
</span><span class="punctuation" id="L38">0038
</span><span class="punctuation" id="L39">0039
</span><span class="punctuation" id="L40">0040
</span><span class="punctuation" id="L41">0041
</span><span class="punctuation" id="L42">0042
</span><span class="punctuation" id="L43">0043
</span><span class="punctuation" id="L44">0044
</span><span class="punctuation" id="L45">0045
</span><span class="punctuation" id="L46">0046
</span><span class="punctuation" id="L47">0047
</span><span class="punctuation" id="L48">0048
</span><span class="punctuation" id="L49">0049
</span><span class="punctuation" id="L50">0050
</span><span class="punctuation" id="L51">0051
</span><span class="punctuation" id="L52">0052
</span><span class="punctuation" id="L53">0053
</span><span class="punctuation" id="L54">0054
</span><span class="punctuation" id="L55">0055
</span><span class="punctuation" id="L56">0056
</span><span class="punctuation" id="L57">0057
</span><span class="punctuation" id="L58">0058
</span><span class="punctuation" id="L59">0059
</span><span class="punctuation" id="L60">0060
</span><span class="punctuation" id="L61">0061
</span><span class="punctuation" id="L62">0062
</span><span class="punctuation" id="L63">0063
</span><span class="punctuation" id="L64">0064
</span><span class="punctuation" id="L65">0065
</span><span class="punctuation" id="L66">0066
</span><span class="punctuation" id="L67">0067
</span><span class="punctuation" id="L68">0068
</span><span class="punctuation" id="L69">0069
</span><span class="punctuation" id="L70">0070
</span><span class="punctuation" id="L71">0071
</span><span class="punctuation" id="L72">0072
</span><span class="punctuation" id="L73">0073
</span><span class="punctuation" id="L74">0074
</span><span class="punctuation" id="L75">0075
</span><span class="punctuation" id="L76">0076
</span><span class="punctuation" id="L77">0077
</span><span class="punctuation" id="L78">0078
</span><span class="punctuation" id="L79">0079
</span><span class="punctuation" id="L80">0080
</span><span class="punctuation" id="L81">0081
</span><span class="punctuation" id="L82">0082
</span><span class="punctuation" id="L83">0083
</span><span class="punctuation" id="L84">0084
</span><span class="punctuation" id="L85">0085
</span><span class="punctuation" id="L86">0086
</span><span class="punctuation" id="L87">0087
</span><span class="punctuation" id="L88">0088
</span><span class="punctuation" id="L89">0089
</span><span class="punctuation" id="L90">0090
</span><span class="punctuation" id="L91">0091
</span><span class="punctuation" id="L92">0092
</span><span class="punctuation" id="L93">0093
</span><span class="punctuation" id="L94">0094
</span><span class="punctuation" id="L95">0095
</span><span class="punctuation" id="L96">0096
</span><span class="punctuation" id="L97">0097
</span><span class="punctuation" id="L98">0098
</span><span class="punctuation" id="L99">0099
</span><span class="punctuation" id="L100">0100
</span><span class="punctuation" id="L101">0101
</span><span class="punctuation" id="L102">0102
</span><span class="punctuation" id="L103">0103
</span><span class="punctuation" id="L104">0104
</span><span class="punctuation" id="L105">0105
</span><span class="punctuation" id="L106">0106
</span><span class="punctuation" id="L107">0107
</span><span class="punctuation" id="L108">0108
</span><span class="punctuation" id="L109">0109
</span><span class="punctuation" id="L110">0110
</span><span class="punctuation" id="L111">0111
</span><span class="punctuation" id="L112">0112
</span><span class="punctuation" id="L113">0113
</span><span class="punctuation" id="L114">0114
</span><span class="punctuation" id="L115">0115
</span><span class="punctuation" id="L116">0116
</span><span class="punctuation" id="L117">0117
</span><span class="punctuation" id="L118">0118
</span><span class="punctuation" id="L119">0119
</span><span class="punctuation" id="L120">0120
</span><span class="punctuation" id="L121">0121
</span><span class="punctuation" id="L122">0122
</span><span class="punctuation" id="L123">0123
</span><span class="punctuation" id="L124">0124
</span><span class="punctuation" id="L125">0125
</span><span class="punctuation" id="L126">0126
</span><span class="punctuation" id="L127">0127
</span><span class="punctuation" id="L128">0128
</span><span class="punctuation" id="L129">0129
</span><span class="punctuation" id="L130">0130
</span><span class="punctuation" id="L131">0131
</span><span class="punctuation" id="L132">0132
</span><span class="punctuation" id="L133">0133
</span><span class="punctuation" id="L134">0134
</span><span class="punctuation" id="L135">0135
</span><span class="punctuation" id="L136">0136
</span><span class="punctuation" id="L137">0137
</span><span class="punctuation" id="L138">0138
</span><span class="punctuation" id="L139">0139
</span><span class="punctuation" id="L140">0140
</span><span class="punctuation" id="L141">0141
</span><span class="punctuation" id="L142">0142
</span><span class="punctuation" id="L143">0143
</span><span class="punctuation" id="L144">0144
</span><span class="punctuation" id="L145">0145
</span><span class="punctuation" id="L146">0146
</span><span class="punctuation" id="L147">0147
</span><span class="punctuation" id="L148">0148
</span><span class="punctuation" id="L149">0149
</span><span class="punctuation" id="L150">0150
</span><span class="punctuation" id="L151">0151
</span><span class="punctuation" id="L152">0152
</span><span class="punctuation" id="L153">0153
</span><span class="punctuation" id="L154">0154
</span><span class="punctuation" id="L155">0155
</span><span class="punctuation" id="L156">0156
</span><span class="punctuation" id="L157">0157
</span><span class="punctuation" id="L158">0158
</span><span class="punctuation" id="L159">0159
</span><span class="punctuation" id="L160">0160
</span><span class="punctuation" id="L161">0161
</span><span class="punctuation" id="L162">0162
</span><span class="punctuation" id="L163">0163
</span><span class="punctuation" id="L164">0164
</span><span class="punctuation" id="L165">0165
</span><span class="punctuation" id="L166">0166
</span><span class="punctuation" id="L167">0167
</span><span class="punctuation" id="L168">0168
</span><span class="punctuation" id="L169">0169
</span><span class="punctuation" id="L170">0170
</span><span class="punctuation" id="L171">0171
</span><span class="punctuation" id="L172">0172
</span><span class="punctuation" id="L173">0173
</span><span class="punctuation" id="L174">0174
</span><span class="punctuation" id="L175">0175
</span><span class="punctuation" id="L176">0176
</span><span class="punctuation" id="L177">0177
</span><span class="punctuation" id="L178">0178
</span><span class="punctuation" id="L179">0179
</span><span class="punctuation" id="L180">0180
</span><span class="punctuation" id="L181">0181
</span><span class="punctuation" id="L182">0182
</span><span class="punctuation" id="L183">0183
</span><span class="punctuation" id="L184">0184
</span><span class="punctuation" id="L185">0185
</span><span class="punctuation" id="L186">0186
</span><span class="punctuation" id="L187">0187
</span><span class="punctuation" id="L188">0188
</span><span class="punctuation" id="L189">0189
</span><span class="punctuation" id="L190">0190
</span><span class="punctuation" id="L191">0191
</span><span class="punctuation" id="L192">0192
</span><span class="punctuation" id="L193">0193
</span><span class="punctuation" id="L194">0194
</span><span class="punctuation" id="L195">0195
</span><span class="punctuation" id="L196">0196
</span><span class="punctuation" id="L197">0197
</span><span class="punctuation" id="L198">0198
</span><span class="punctuation" id="L199">0199
</span><span class="punctuation" id="L200">0200
</span><span class="punctuation" id="L201">0201
</span><span class="punctuation" id="L202">0202
</span><span class="punctuation" id="L203">0203
</span><span class="punctuation" id="L204">0204
</span><span class="punctuation" id="L205">0205
</span><span class="punctuation" id="L206">0206
</span><span class="punctuation" id="L207">0207
</span><span class="punctuation" id="L208">0208
</span><span class="punctuation" id="L209">0209
</span><span class="punctuation" id="L210">0210
</span><span class="punctuation" id="L211">0211
</span><span class="punctuation" id="L212">0212
</span><span class="punctuation" id="L213">0213
</span><span class="punctuation" id="L214">0214
</span><span class="punctuation" id="L215">0215
</span><span class="punctuation" id="L216">0216
</span><span class="punctuation" id="L217">0217
</span><span class="punctuation" id="L218">0218
</span><span class="punctuation" id="L219">0219
</span><span class="punctuation" id="L220">0220
</span><span class="punctuation" id="L221">0221
</span><span class="punctuation" id="L222">0222
</span><span class="punctuation" id="L223">0223
</span><span class="punctuation" id="L224">0224
</span><span class="punctuation" id="L225">0225
</span><span class="punctuation" id="L226">0226
</span><span class="punctuation" id="L227">0227
</span><span class="punctuation" id="L228">0228
</span><span class="punctuation" id="L229">0229
</span><span class="punctuation" id="L230">0230
</span><span class="punctuation" id="L231">0231
</span><span class="punctuation" id="L232">0232
</span><span class="punctuation" id="L233">0233
</span><span class="punctuation" id="L234">0234
</span><span class="punctuation" id="L235">0235
</span><span class="punctuation" id="L236">0236
</span><span class="punctuation" id="L237">0237
</span><span class="punctuation" id="L238">0238
</span><span class="punctuation" id="L239">0239
</span><span class="punctuation" id="L240">0240
</span><span class="punctuation" id="L241">0241
</span><span class="punctuation" id="L242">0242
</span><span class="punctuation" id="L243">0243
</span><span class="punctuation" id="L244">0244
</span><span class="punctuation" id="L245">0245
</span><span class="punctuation" id="L246">0246
</span><span class="punctuation" id="L247">0247
</span><span class="punctuation" id="L248">0248
</span><span class="punctuation" id="L249">0249
</span><span class="punctuation" id="L250">0250
</span><span class="punctuation" id="L251">0251
</span><span class="punctuation" id="L252">0252
</span><span class="punctuation" id="L253">0253
</span><span class="punctuation" id="L254">0254
</span><span class="punctuation" id="L255">0255
</span><span class="punctuation" id="L256">0256
</span><span class="punctuation" id="L257">0257
</span><span class="punctuation" id="L258">0258
</span><span class="punctuation" id="L259">0259
</span><span class="punctuation" id="L260">0260
</span><span class="punctuation" id="L261">0261
</span><span class="punctuation" id="L262">0262
</span><span class="punctuation" id="L263">0263
</span><span class="punctuation" id="L264">0264
</span><span class="punctuation" id="L265">0265
</span><span class="punctuation" id="L266">0266
</span><span class="punctuation" id="L267">0267
</span><span class="punctuation" id="L268">0268
</span><span class="punctuation" id="L269">0269
</span><span class="punctuation" id="L270">0270
</span><span class="punctuation" id="L271">0271
</span><span class="punctuation" id="L272">0272
</span><span class="punctuation" id="L273">0273
</span><span class="punctuation" id="L274">0274
</span><span class="punctuation" id="L275">0275
</span><span class="punctuation" id="L276">0276
</span><span class="punctuation" id="L277">0277
</span><span class="punctuation" id="L278">0278
</span><span class="punctuation" id="L279">0279
</span><span class="punctuation" id="L280">0280
</span><span class="punctuation" id="L281">0281
</span><span class="punctuation" id="L282">0282
</span><span class="punctuation" id="L283">0283
</span><span class="punctuation" id="L284">0284
</span><span class="punctuation" id="L285">0285
</span><span class="punctuation" id="L286">0286
</span><span class="punctuation" id="L287">0287
</span><span class="punctuation" id="L288">0288
</span><span class="punctuation" id="L289">0289
</span><span class="punctuation" id="L290">0290
</span><span class="punctuation" id="L291">0291
</span><span class="punctuation" id="L292">0292
</span><span class="punctuation" id="L293">0293
</span><span class="punctuation" id="L294">0294
</span><span class="punctuation" id="L295">0295
</span><span class="punctuation" id="L296">0296
</span><span class="punctuation" id="L297">0297
</span><span class="punctuation" id="L298">0298
</span><span class="punctuation" id="L299">0299
</span><span class="punctuation" id="L300">0300
</span><span class="punctuation" id="L301">0301
</span><span class="punctuation" id="L302">0302
</span><span class="punctuation" id="L303">0303
</span><span class="punctuation" id="L304">0304
</span><span class="punctuation" id="L305">0305
</span><span class="punctuation" id="L306">0306
</span><span class="punctuation" id="L307">0307
</span><span class="punctuation" id="L308">0308
</span><span class="punctuation" id="L309">0309
</span><span class="punctuation" id="L310">0310
</span><span class="punctuation" id="L311">0311
</span><span class="punctuation" id="L312">0312
</span><span class="punctuation" id="L313">0313
</span><span class="punctuation" id="L314">0314
</span><span class="punctuation" id="L315">0315
</span><span class="punctuation" id="L316">0316
</span><span class="punctuation" id="L317">0317
</span><span class="punctuation" id="L318">0318
</span><span class="punctuation" id="L319">0319
</span><span class="punctuation" id="L320">0320
</span><span class="punctuation" id="L321">0321
</span><span class="punctuation" id="L322">0322
</span><span class="punctuation" id="L323">0323
</span><span class="punctuation" id="L324">0324
</span><span class="punctuation" id="L325">0325
</span><span class="punctuation" id="L326">0326
</span><span class="punctuation" id="L327">0327
</span><span class="punctuation" id="L328">0328
</span><span class="punctuation" id="L329">0329
</span><span class="punctuation" id="L330">0330
</span><span class="punctuation" id="L331">0331
</span><span class="punctuation" id="L332">0332
</span><span class="punctuation" id="L333">0333
</span><span class="punctuation" id="L334">0334
</span><span class="punctuation" id="L335">0335
</span><span class="punctuation" id="L336">0336
</span><span class="punctuation" id="L337">0337
</span><span class="punctuation" id="L338">0338
</span><span class="punctuation" id="L339">0339
</span><span class="punctuation" id="L340">0340
</span><span class="punctuation" id="L341">0341
</span><span class="punctuation" id="L342">0342
</span><span class="punctuation" id="L343">0343
</span><span class="punctuation" id="L344">0344
</span><span class="punctuation" id="L345">0345
</span><span class="punctuation" id="L346">0346
</span><span class="punctuation" id="L347">0347
</span><span class="punctuation" id="L348">0348
</span><span class="punctuation" id="L349">0349
</span><span class="punctuation" id="L350">0350
</span><span class="punctuation" id="L351">0351
</span><span class="punctuation" id="L352">0352
</span><span class="punctuation" id="L353">0353
</span></code></pre><div style="width:1px;"></div><pre class="source"><code><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span class="symbol">a</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="keyword">:require</span><span class="whitespace"> </span><span>[<span class="symbol">clojure.java.io</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">io</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>[<span class="symbol">cljs.reader</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">cljs-reader</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>[<span class="symbol">clojure.tools.reader</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">tools-reader</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>[<span class="symbol">cider.nrepl.middleware.util.java.parser</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">cider-java</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>[<span class="symbol">clojure.tools.reader.reader-types</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">rt</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>[<span class="symbol">hiccup.core</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">h</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="keyword">:import</span><span class="whitespace"> </span><span>[<span class="symbol">java.nio.file</span><span class="whitespace"> </span><span class="java-class">Files</span>]</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="symbol">set!</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/*warn-on-reflection*" title="When set to true, the compiler will emit warnings when reflection is
  needed to resolve Java method calls or field accesses.

  Defaults to false.">*warn-on-reflection*</a></span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L12">ns->source-string</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">path</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/some-&gt;" title="When expr is not nil, threads it into the first form (via -&gt;),
  and when that result is not nil, through the next etc">some-></a></span><span class="whitespace"> </span><span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/ns" title="Sets *ns* to the namespace named by name (unevaluated), creating it
  if needed.  references can be zero or more of: (:refer-clojure ...)
  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)
  with the syntax of refer-clojure/require/use/import/load/gen-class
  respectively, except the arguments are unevaluated and need not be
  quoted. (:gen-class ...), when supplied, defaults to :name
  corresponding to the ns name, :main true, :impl-ns same as ns, and
  :init-impl-ns true. All options of gen-class are
  supported. The :gen-class directive is ignored when not
  compiling. If :gen-class is not supplied, when compiled only an
  nsname__init.class will be generated. If :refer-clojure is not used, a
  default (refer &apos;clojure.core) is used.  Use of ns is preferred to
  individual calls to in-ns/require/use/import:

  (ns foo.bar
    (:refer-clojure :exclude [ancestors printf])
    (:require (clojure.contrib sql combinatorics))
    (:use (my.lib this that))
    (:import (java.util Date Timer Random)
             (java.sql Connection Statement)))">ns</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-publics" title="Returns a map of the public intern mappings for the namespace.">ns-publics</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="keyword">:file</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span class="symbol">path</span><span class="whitespace"> </span><span class="var-ref"><a href="clojure.java.io.html#L446" title="Returns the URL for a named resource. Use the context class loader
   if no loader is specified.">io/resource</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/slurp" title="Opens a reader on f and reads all its contents, returning a string.
  See clojure.java.io/reader for a complete list of supported arguments.">slurp</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L17">clj-whitespace</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">c</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/case" title="Takes an expression, and a set of clauses.

  Each clause can take the form of either:

  test-constant result-expr

  (test-constant1 ... test-constantN)  result-expr

  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.

  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type.">case</a></span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="comment">;; (\, \space \newline \tab)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="string">,</span><span class="whitespace"> </span><span class="string">s</span><span class="symbol">pace</span><span class="whitespace">  </span><span class="string">t</span><span class="symbol">ab</span>)</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="unknown">false</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L24">clj-special</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">c</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/case" title="Takes an expression, and a set of clauses.

  Each clause can take the form of either:

  test-constant result-expr

  (test-constant1 ... test-constantN)  result-expr

  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.

  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type.">case</a></span><span class="whitespace"> </span><span class="symbol">c</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="string">(</span><span class="whitespace"> </span><span class="string">)</span><span class="whitespace"> </span><span class="string">{</span><span class="whitespace"> </span><span class="string">}</span><span class="whitespace"> </span><span class="string">[</span><span class="whitespace"> </span><span class="string">]</span><span class="whitespace"> </span><span class="string">,</span><span class="whitespace"> </span><span class="string">s</span><span class="symbol">pace</span><span class="whitespace"> </span><span class="string">n</span><span class="symbol">ewline</span><span class="whitespace"> </span><span class="string">t</span><span class="symbol">ab</span>)</span><span class="whitespace"> </span><span class="unknown">true</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="unknown">false</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L30">whitespace-string</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">pos</span>]</span>}</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">idx</span><span class="whitespace"> </span><span class="symbol">pos</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span><span class="symbol">idx</span><span class="whitespace"> </span><span>(<span class="java-class">.length</span><span class="whitespace"> </span><span class="symbol">buf</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L17">clj-whitespace</a></span><span class="whitespace"> </span><span>(<span class="java-class">.charAt</span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">idx</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">idx</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="java-class">.substring</span><span class="whitespace"> </span><span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">pos</span><span class="whitespace"> </span><span class="symbol">idx</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L37">symbol-string</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">pos</span>]</span>}</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">idx</span><span class="whitespace"> </span><span class="symbol">pos</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span><span class="symbol">idx</span><span class="whitespace"> </span><span>(<span class="java-class">.length</span><span class="whitespace"> </span><span class="symbol">buf</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L24">clj-special</a></span><span class="whitespace"> </span><span>(<span class="java-class">.charAt</span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">idx</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">idx</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="java-class">.substring</span><span class="whitespace"> </span><span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">pos</span><span class="whitespace"> </span><span class="symbol">idx</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defrecord" title="(defrecord name [fields*]  options* specs*)

  Options are expressed as sequential keywords and arguments (in any order).

  Supported options:
  :load-ns - if true, importing the record class will cause the
             namespace in which the record was defined to be loaded.
             Defaults to false.

  Each spec consists of a protocol or interface name followed by zero
  or more method bodies:

  protocol-or-interface-or-Object
  (methodName [args*] body)*

  Dynamically generates compiled bytecode for class with the given
  name, in a package with the same name as the current namespace, the
  given fields, and, optionally, methods for protocols and/or
  interfaces.

  The class will have the (immutable) fields named by
  fields, which can have type hints. Protocols/interfaces and methods
  are optional. The only methods that can be supplied are those
  declared in the protocols/interfaces.  Note that method bodies are
  not closures, the local environment includes only the named fields,
  and those fields can be accessed directly.

  Method definitions take the form:

  (methodname [args*] body)

  The argument and return types can be hinted on the arg and
  methodname symbols. If not supplied, they will be inferred, so type
  hints should be reserved for disambiguation.

  Methods should be supplied for all methods of the desired
  protocol(s) and interface(s). You can also define overrides for
  methods of Object. Note that a parameter must be supplied to
  correspond to the target object (&apos;this&apos; in Java parlance). Thus
  methods for interfaces will take one more argument than do the
  interface declarations. Note also that recur calls to the method
  head should *not* pass the target object, it will be supplied
  automatically and can not be substituted.

  In the method bodies, the (unqualified) name can be used to name the
  class (for calls to new, instance? etc).

  The class will have implementations of several (clojure.lang)
  interfaces generated automatically: IObj (metadata support) and
  IPersistentMap, and all of their superinterfaces.

  In addition, defrecord will define type-and-value-based =,
  and will defined Java .hashCode and .equals consistent with the
  contract for java.util.Map.

  When AOT compiling, generates compiled bytecode for a class with the
  given name (a symbol), prepends the current ns as the package, and
  writes the .class file to the *compile-path* directory.

  Two constructors will be defined, one taking the designated fields
  followed by a metadata map (nil for none) and an extension field
  map (nil for none), and one taking only the fields (using nil for
  meta and extension fields). Note that the field names __meta
  and __extmap are currently reserved and should not be used when
  defining your own records.

  Given (defrecord TypeName ...), two factory functions will be
  defined: -&gt;TypeName, taking positional parameters for the fields,
  and map-&gt;TypeName, taking a map of keywords to field values.">defrecord</a></span><span class="whitespace"> </span><span class="java-class">Substring</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/chars" title="Casts to chars[]">chars</a></span><span class="whitespace"> </span><span class="symbol">offset</span><span class="whitespace"> </span><span class="symbol">length</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L46">substring</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Substring</span></span><span class="whitespace"> </span><span class="symbol">parent</span><span class="whitespace"> </span><span>^<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long" title="Coerce to long">long</a></span></span><span class="whitespace"> </span><span class="symbol">off</span><span class="whitespace"> </span><span>^<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/long" title="Coerce to long">long</a></span></span><span class="whitespace"> </span><span class="symbol">len</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref"><a href="a.html#L44" title="Positional factory function for class a.Substring.">->Substring</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="keyword">:chars</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace"> </span><span class="symbol">off</span><span class="whitespace"> </span><span>(<span class="keyword">:offset</span><span class="whitespace"> </span><span class="symbol">parent</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="symbol">len</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L53">lex</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">orig-ctx</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">pos</span><span class="whitespace"> </span><span class="symbol">line</span>]</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">ctx</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span class="symbol">orig-ctx</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="keyword">:line</span><span class="whitespace"> </span><span class="unknown">1</span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transient" title="Returns a new, transient version of the collection, in constant time.">transient</a></span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">tokens</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/transient" title="Returns a new, transient version of the collection, in constant time.">transient</a></span><span class="whitespace"> </span><span>[]</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="metadata">#_</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span><span class="symbol">pos</span><span class="whitespace"> </span><span>(<span class="java-class">.length</span><span class="whitespace"> </span><span class="symbol">buf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/println" title="Same as print followed by (newline)">println</a></span><span class="whitespace"> </span><span class="string">"char = "</span><span class="whitespace"> </span><span>(<span class="java-class">.charAt</span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">pos</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&gt;=" title="Returns non-nil if nums are in monotonically non-increasing order,
  otherwise false.">>=</a></span><span class="whitespace"> </span><span class="symbol">pos</span><span class="whitespace"> </span><span>(<span class="java-class">.length</span><span class="whitespace"> </span><span class="symbol">buf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/persistent!" title="Returns a new, persistent version of the transient collection, in
  constant time. The transient collection cannot be used after this
  call, any such use will throw an exception.">persistent!</a></span><span class="whitespace"> </span><span class="symbol">tokens</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/case" title="Takes an expression, and a set of clauses.

  Each clause can take the form of either:

  test-constant result-expr

  (test-constant1 ... test-constantN)  result-expr

  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.

  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type.">case</a></span><span class="whitespace"> </span><span>(<span class="java-class">.charAt</span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">pos</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="string">n</span><span class="symbol">ewline</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc!" title="When applied to a transient map, adds mapping of key(s) to
  val(s). When applied to a transient vector, sets the val at index.
  Note - index must be &lt;= (count vector). Returns coll.">assoc!</a></span><span class="whitespace"> </span><span class="symbol">ctx</span><span class="whitespace"> </span><span class="keyword">:line</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">line</span>)</span><span class="whitespace"> </span><span class="keyword">:pos</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">pos</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace"> </span><span class="symbol">tokens</span><span class="whitespace"> </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:ws</span><span class="whitespace"> </span><span class="keyword">:text</span><span class="whitespace"> </span><span class="string">"\n"</span><span class="whitespace"> </span><span class="keyword">:line</span><span class="whitespace"> </span><span class="symbol">line</span>}</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="string">,</span><span class="whitespace"> </span><span class="string">s</span><span class="symbol">pace</span><span class="whitespace"> </span><span class="string">t</span><span class="symbol">ab</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">whitespace</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L30">whitespace-string</a></span><span class="whitespace"> </span><span class="symbol">ctx</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc!" title="When applied to a transient map, adds mapping of key(s) to
  val(s). When applied to a transient vector, sets the val at index.
  Note - index must be &lt;= (count vector). Returns coll.">assoc!</a></span><span class="whitespace"> </span><span class="symbol">ctx</span><span class="whitespace"> </span><span class="keyword">:pos</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace"> </span><span class="symbol">pos</span><span class="whitespace"> </span><span>(<span class="java-class">.length</span><span class="whitespace"> </span><span class="symbol">whitespace</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace"> </span><span class="symbol">tokens</span><span class="whitespace"> </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:ws</span><span class="whitespace"> </span><span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">whitespace</span>}</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="string">(</span><span class="whitespace"> </span><span class="string">)</span><span class="whitespace"> </span><span class="string">{</span><span class="whitespace"> </span><span class="string">}</span><span class="whitespace"> </span><span class="string">[</span><span class="whitespace"> </span><span class="string">]</span><span class="whitespace"> </span><span class="string">`</span><span class="whitespace"> </span><span class="string">~</span><span class="whitespace"> </span><span class="string">#</span><span class="whitespace"> </span><span class="string">^</span><span class="whitespace"> </span><span class="string">'</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc!" title="When applied to a transient map, adds mapping of key(s) to
  val(s). When applied to a transient vector, sets the val at index.
  Note - index must be &lt;= (count vector). Returns coll.">assoc!</a></span><span class="whitespace"> </span><span class="symbol">ctx</span><span class="whitespace"> </span><span class="keyword">:pos</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">pos</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">               </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace"> </span><span class="symbol">tokens</span><span class="whitespace"> </span><span>(<span class="java-class">.charAt</span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">pos</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="string">"</span><span class="whitespace"> </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">string-end</span><span class="whitespace"> </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">pos</span>)</span><span class="whitespace">
</span><span class="whitespace">                                   </span><span class="symbol">escaped</span><span class="whitespace"> </span><span class="unknown">false</span>]</span><span class="whitespace">
</span><span class="whitespace">                              </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="java-class">.length</span><span class="whitespace"> </span><span class="symbol">buf</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span class="symbol">i</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not" title="Returns true if x is logical false, false otherwise.">not</a></span><span class="whitespace"> </span><span class="symbol">escaped</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="string">"</span><span class="whitespace"> </span><span>(<span class="java-class">.charAt</span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">i</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="string">\</span><span class="whitespace"> </span><span>(<span class="java-class">.charAt</span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">i</span>)</span><span class="whitespace"> </span><span class="unknown">true</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">                                </span><span class="keyword">:else</span><span class="whitespace">
</span><span class="whitespace">                                </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">i</span>)</span><span class="whitespace"> </span><span class="unknown">false</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc!" title="When applied to a transient map, adds mapping of key(s) to
  val(s). When applied to a transient vector, sets the val at index.
  Note - index must be &lt;= (count vector). Returns coll.">assoc!</a></span><span class="whitespace"> </span><span class="symbol">ctx</span><span class="whitespace"> </span><span class="keyword">:pos</span><span class="whitespace"> </span><span class="symbol">string-end</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace"> </span><span class="symbol">tokens</span><span class="whitespace"> </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:string</span><span class="whitespace"> </span><span class="keyword">:text</span><span class="whitespace"> </span><span>(<span class="java-class">.substring</span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">pos</span><span class="whitespace"> </span><span class="symbol">string-end</span>)</span>}</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="string">;</span><span class="whitespace"> </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">comment-end</span><span class="whitespace"> </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">i</span><span class="whitespace"> </span><span class="symbol">pos</span>]</span><span class="whitespace">
</span><span class="whitespace">                               </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/&lt;" title="Returns non-nil if nums are in monotonically increasing order,
  otherwise false."><</a></span><span class="whitespace"> </span><span class="symbol">i</span><span class="whitespace"> </span><span>(<span class="java-class">.length</span><span class="whitespace"> </span><span class="symbol">buf</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/not=" title="Same as (not (= obj1 obj2))">not=</a></span><span class="whitespace"> </span><span class="string">n</span><span class="symbol">ewline</span><span class="whitespace"> </span><span>(<span class="java-class">.charAt</span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                 </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">i</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                                 </span><span class="symbol">i</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">             </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc!" title="When applied to a transient map, adds mapping of key(s) to
  val(s). When applied to a transient vector, sets the val at index.
  Note - index must be &lt;= (count vector). Returns coll.">assoc!</a></span><span class="whitespace"> </span><span class="symbol">ctx</span><span class="whitespace"> </span><span class="keyword">:pos</span><span class="whitespace"> </span><span class="symbol">comment-end</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace"> </span><span class="symbol">tokens</span><span class="whitespace"> </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:comment</span><span class="whitespace"> </span><span class="keyword">:text</span><span class="whitespace"> </span><span>(<span class="java-class">.substring</span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span class="symbol">pos</span><span class="whitespace"> </span><span class="symbol">comment-end</span>)</span>}</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="whitespace">
</span><span class="whitespace">        </span><span class="string">\</span><span class="whitespace"> </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc!" title="When applied to a transient map, adds mapping of key(s) to
  val(s). When applied to a transient vector, sets the val at index.
  Note - index must be &lt;= (count vector). Returns coll.">assoc!</a></span><span class="whitespace"> </span><span class="symbol">ctx</span><span class="whitespace"> </span><span class="keyword">:pos</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace"> </span><span class="unknown">2</span><span class="whitespace"> </span><span class="symbol">pos</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                  </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace"> </span><span class="symbol">tokens</span><span class="whitespace"> </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:char-literal</span><span class="whitespace"> </span><span class="keyword">:text</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span>(<span class="java-class">.charAt</span><span class="whitespace"> </span><span class="symbol">buf</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span class="symbol">pos</span>)</span>)</span>)</span>}</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">sym</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L37">symbol-string</a></span><span class="whitespace"> </span><span class="symbol">ctx</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc!" title="When applied to a transient map, adds mapping of key(s) to
  val(s). When applied to a transient vector, sets the val at index.
  Note - index must be &lt;= (count vector). Returns coll.">assoc!</a></span><span class="whitespace"> </span><span class="symbol">ctx</span><span class="whitespace"> </span><span class="keyword">:pos</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/+" title="Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +&apos;">+</a></span><span class="whitespace"> </span><span class="symbol">pos</span><span class="whitespace"> </span><span>(<span class="java-class">.length</span><span class="whitespace"> </span><span class="symbol">sym</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj!" title="Adds x to the transient collection, and return coll. The &apos;addition&apos;
  may happen at different &apos;places&apos; depending on the concrete type.">conj!</a></span><span class="whitespace"> </span><span class="symbol">tokens</span><span class="whitespace"> </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:symbol</span><span class="whitespace"> </span><span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">sym</span>}</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="metadata">#_</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/type" title="Returns the :type metadata of x, or its Class if none">type</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/resolve" title="same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &amp;env symbol)">resolve</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/read-string" title="Reads one object from the string s. Optionally include reader
  options, as specified in read.

  Note that read-string can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read-string">read-string</a></span><span class="whitespace"> </span><span class="string">"java.lang.String"</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L109">resolve?</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">s</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">try</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/resolve" title="same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &amp;env symbol)">resolve</a></span><span class="whitespace"> </span><span class="symbol">s</span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="symbol">catch</span><span class="whitespace"> </span><span class="java-class">Exception</span><span class="whitespace"> </span><span class="symbol">e</span><span class="whitespace"> </span><span class="unparsed">nil</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L114">parse-symbol</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span class="symbol">text</span>]</span><span class="whitespace"> </span><span class="keyword">:as</span><span class="whitespace"> </span><span class="symbol">sym</span>}</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">try</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">rd</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/read-string" title="Reads one object from the string s. Optionally include reader
  options, as specified in read.

  Note that read-string can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read-string">read-string</a></span><span class="whitespace"> </span><span class="symbol">text</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace"> </span><span class="symbol">rd</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">sym</span><span class="whitespace"> </span><span class="keyword">:val</span><span class="whitespace"> </span><span class="symbol">rd</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="symbol">sym</span><span class="whitespace"> </span><span class="keyword">:val</span><span class="whitespace"> </span><span class="symbol">rd</span><span class="whitespace"> </span><span class="keyword">:resolved</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L109">resolve?</a></span><span class="whitespace"> </span><span class="symbol">rd</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="symbol">catch</span><span class="whitespace"> </span><span class="java-class">Exception</span><span class="whitespace"> </span><span class="symbol">e</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="symbol">sym</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L124">javadoc-url</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>^<span class="java-class">Class</span></span><span class="whitespace"> </span><span class="symbol">cls</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span class="comment">;; https://docs.oracle.com/javase/8/docs/api/java/lang/String.html</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">clsname</span><span class="whitespace"> </span><span>(<span class="java-class">.getName</span><span class="whitespace"> </span><span class="symbol">cls</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"https://docs.oracle.com/javase/8/docs/api/"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="java-class">.replace</span><span class="whitespace"> </span><span class="symbol">clsname</span><span class="whitespace"> </span><span class="string">.</span><span class="whitespace"> </span><span class="string">/</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="string">".html"</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span class="keyword">:const</span></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L132">clojure-core-ns</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/find-ns" title="Returns the namespace named by the symbol or nil if it doesn&apos;t exist.">find-ns</a></span><span class="whitespace"> </span><span>'<span class="symbol">clojure.core</span></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L134">add-link</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">text</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">props</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L132">clojure-core-ns</a></span><span class="whitespace"> </span><span>(<span class="keyword">:ns</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>{<span class="keyword">:href</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/format" title="Formats a string using java.lang.String.format, see java.util.Formatter for format
  string syntax">format</a></span><span class="whitespace"> </span><span class="string">"https://clojuredocs.org/clojure.core/%s"</span><span class="whitespace"> </span><span>(<span class="keyword">:name</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span>)</span>)</span>}</span><span class="whitespace">
</span><span class="whitespace">                 </span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="keyword">:file</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>{<span class="keyword">:href</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ns-name" title="Returns the name of the namespace, a symbol.">ns-name</a></span><span class="whitespace"> </span><span>(<span class="keyword">:ns</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span>)</span>)</span><span class="whitespace"> </span><span class="string">".html#L"</span><span class="whitespace"> </span><span>(<span class="keyword">:line</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span>)</span>)</span>}</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>[<span class="keyword">:a</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond-&gt;" title="Takes an expression and a set of test/form pairs. Threads expr (via -&gt;)
  through each form for which the corresponding test
  expression is true. Note that, unlike cond branching, cond-&gt; threading does
  not short circuit after the first true test expression.">cond-></a></span><span class="whitespace"> </span><span class="symbol">props</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="keyword">:doc</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span>)</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/assoc" title="assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).">assoc</a></span><span class="whitespace"> </span><span class="keyword">:title</span><span class="whitespace"> </span><span>(<span class="keyword">:doc</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="symbol">text</span>]</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L149">special-form?</a></span><span class="whitespace"> </span><span>#{<span class="string">"def"</span><span class="whitespace"> </span><span class="string">"let"</span><span class="whitespace"> </span><span class="string">"if"</span><span class="whitespace"> </span><span class="string">"do"</span><span class="whitespace"> </span><span class="string">"fn"</span><span class="whitespace"> </span><span class="string">"loop"</span><span class="whitespace"> </span><span class="string">"recur"</span><span class="whitespace"> </span><span class="string">"try"</span><span class="whitespace"> </span><span class="string">"throw"</span><span class="whitespace"> </span><span class="string">"quote"</span><span class="whitespace"> </span><span class="string">"var"</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class?" title="Returns true if x is an instance of Class">class?</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/resolve" title="same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &amp;env symbol)">resolve</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol" title="Returns a Symbol with the given namespace and name.">symbol</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/namespace" title="Returns the namespace String of a symbol or keyword, or nil if not present.">namespace</a></span><span class="whitespace"> </span><span>'<span class="java-class">clojure.lang.Util/<span class="symbol">equiv</span></span></span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L153">render-symbol</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="symbol">resolved</span><span class="whitespace"> </span><span>^<span class="java-class">String</span></span><span class="whitespace"> </span><span class="symbol">text</span>]</span>}</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:unparsed</span>}</span><span class="whitespace"> </span><span class="symbol">text</span>]</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="java-class">.startsWith</span><span class="whitespace"> </span><span class="symbol">text</span><span class="whitespace"> </span><span class="string">"."</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:java-class</span>}</span><span class="whitespace"> </span><span class="symbol">text</span>]</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref"><a href="a.html#L149">special-form?</a></span><span class="whitespace"> </span><span class="symbol">text</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:macro</span>}</span><span class="whitespace"> </span><span class="symbol">text</span>]</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/keyword?" title="Return true if x is a Keyword">keyword?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:keyword</span>}</span><span class="whitespace"> </span><span class="symbol">text</span>]</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class?" title="Returns true if x is an instance of Class">class?</a></span><span class="whitespace"> </span><span class="symbol">resolved</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:java-class</span>}</span><span class="whitespace"> </span><span class="symbol">text</span>]</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">resolved</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">m</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/meta" title="Returns the metadata of obj, returns nil if there is no metadata.">meta</a></span><span class="whitespace"> </span><span class="symbol">resolved</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">core?</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L132">clojure-core-ns</a></span><span class="whitespace"> </span><span>(<span class="keyword">:ns</span><span class="whitespace"> </span><span class="symbol">m</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">text</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L134">add-link</a></span><span class="whitespace"> </span><span class="symbol">text</span><span class="whitespace"> </span><span class="symbol">m</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">classes</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond-&gt;" title="Takes an expression and a set of test/form pairs. Threads expr (via -&gt;)
  through each form for which the corresponding test
  expression is true. Note that, unlike cond branching, cond-&gt; threading does
  not short circuit after the first true test expression.">cond-></a></span><span class="whitespace"> </span><span>[<span class="keyword">:var-ref</span>]</span><span class="whitespace">
</span><span class="whitespace">                    </span><span>(<span class="keyword">:macro</span><span class="whitespace"> </span><span class="symbol">m</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="keyword">:macro</span>)</span><span class="whitespace">
</span><span class="whitespace">                    </span><span class="symbol">core?</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="keyword">:clojure-core</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="clojure.string.html#L180" title="Returns a string of all elements in coll, as returned by (seq coll),
   separated by an optional separator.">clojure.string/join</a></span><span class="whitespace"> </span><span class="string">" "</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/mapv" title="Returns a vector consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.">mapv</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">classes</span>)</span>)</span>}</span><span class="whitespace"> </span><span class="symbol">text</span>]</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol?" title="Return true if x is a Symbol">symbol?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">rns</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/some-&gt;" title="When expr is not nil, threads it into the first form (via -&gt;),
  and when that result is not nil, through the next etc">some-></a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/namespace" title="Returns the namespace String of a symbol or keyword, or nil if not present.">namespace</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol" title="Returns a Symbol with the given namespace and name.">symbol</a></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/some-&gt;" title="When expr is not nil, threads it into the first form (via -&gt;),
  and when that result is not nil, through the next etc">some-></a></span><span class="whitespace"> </span><span class="symbol">rns</span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L109">resolve?</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/class?" title="Returns true if x is an instance of Class">class?</a></span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:java-class</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">rns</span>)</span><span class="whitespace"> </span><span class="string">"/"</span><span class="whitespace"> </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:symbol</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>]</span>]</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="keyword">:else</span><span class="whitespace">
</span><span class="whitespace">        </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:symbol</span>}</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>]</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:else</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">cls</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/and" title="Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&apos;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.">and</a></span><span class="whitespace"> </span><span>(<span class="java-class">.endsWith</span><span class="whitespace"> </span><span class="symbol">text</span><span class="whitespace"> </span><span class="string">"."</span>)</span><span class="whitespace">
</span><span class="whitespace">                      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/some-&gt;" title="When expr is not nil, threads it into the first form (via -&gt;),
  and when that result is not nil, through the next etc">some-></a></span><span class="whitespace"> </span><span class="symbol">text</span><span class="whitespace"> </span><span>(<span class="java-class">.substring</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/dec" title="Returns a number one less than num. Does not auto-promote
  longs, will throw on overflow. See also: dec&apos;">dec</a></span><span class="whitespace"> </span><span>(<span class="java-class">.length</span><span class="whitespace"> </span><span class="symbol">text</span>)</span>)</span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/symbol" title="Returns a Symbol with the given namespace and name.">symbol</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/resolve" title="same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &amp;env symbol)">resolve</a></span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="comment">;; TODO: fix this for java class names (instead of just java constructor calls)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:java-class</span>}</span><span class="whitespace"> </span><span>[<span class="keyword">:a</span><span class="whitespace"> </span><span>{<span class="keyword">:href</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L124">javadoc-url</a></span><span class="whitespace"> </span><span class="symbol">cls</span>)</span>}</span><span class="whitespace"> </span><span class="symbol">text</span>]</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:unknown</span>}</span><span class="whitespace"> </span><span class="symbol">text</span>]</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L197">render-lex</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">t</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/cond" title="Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn&apos;t evaluate any of the
  other tests or exprs. (cond) returns nil.">cond</a></span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/nil?" title="Returns true if x is nil, false otherwise.">nil?</a></span><span class="whitespace"> </span><span class="symbol">t</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/char?" title="Return true if x is a Character">char?</a></span><span class="whitespace"> </span><span class="symbol">t</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:punctuation</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="symbol">t</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:else</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/case" title="Takes an expression, and a set of clauses.

  Each clause can take the form of either:

  test-constant result-expr

  (test-constant1 ... test-constantN)  result-expr

  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.

  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type.">case</a></span><span class="whitespace"> </span><span>(<span class="keyword">:type</span><span class="whitespace"> </span><span class="symbol">t</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="keyword">:ws</span><span class="whitespace"> </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:whitespace</span>}</span><span class="whitespace"> </span><span>(<span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="keyword">:symbol</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L153">render-symbol</a></span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L114">parse-symbol</a></span><span class="whitespace"> </span><span class="symbol">t</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="keyword">:string</span><span class="whitespace"> </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:string</span>}</span><span class="whitespace"> </span><span>(<span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="keyword">:comment</span><span class="whitespace"> </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:comment</span>}</span><span class="whitespace"> </span><span>(<span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>]</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/declare" title="defs the supplied var names with no bindings, useful for making forward declarations.">declare</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L264">parse-list</a></span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L215">open->closed</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="string">(</span><span class="whitespace"> </span><span class="string">)</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="string">[</span><span class="whitespace"> </span><span class="string">]</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="string">{</span><span class="whitespace"> </span><span class="string">}</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="string">"#{"</span><span class="whitespace"> </span><span class="string">}</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L221">closed->open</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>{<span class="string">)</span><span class="whitespace"> </span><span class="string">(</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="string">]</span><span class="whitespace"> </span><span class="string">[</span><span class="whitespace">
</span><span class="whitespace">   </span><span class="string">}</span><span class="whitespace"> </span><span class="string">{</span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L226">parse-one</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">ts</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when-let" title="bindings =&gt; binding-form test

  When test is true, evaluates body with binding-form bound to the value of test">when-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">t</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">closing-delimiter</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L215">open->closed</a></span><span class="whitespace"> </span><span class="symbol">t</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref"><a href="a.html#L264">parse-list</a></span><span class="whitespace"> </span><span class="symbol">closing-delimiter</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/case" title="Takes an expression, and a set of clauses.

  Each clause can take the form of either:

  test-constant result-expr

  (test-constant1 ... test-constantN)  result-expr

  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.

  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type.">case</a></span><span class="whitespace"> </span><span class="symbol">t</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="string">#</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">ts</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="symbol">nt</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="comment">;; dispatch</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/case" title="Takes an expression, and a set of clauses.

  Each clause can take the form of either:

  test-constant result-expr

  (test-constant1 ... test-constantN)  result-expr

  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.

  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type.">case</a></span><span class="whitespace"> </span><span class="symbol">nt</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="string">_</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L226">parse-one</a></span><span class="whitespace"> </span><span class="symbol">nt</span>)</span><span class="whitespace"> </span><span class="keyword">:rest</span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L226">parse-one</a></span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="string">(</span><span class="whitespace"> </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>]</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L226">parse-one</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                 </span><span>{<span class="keyword">:val</span><span class="whitespace"> </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:lambda</span><span class="whitespace"> </span><span class="keyword">:text</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>}</span><span class="whitespace"> </span><span class="keyword">:rest</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="string">{</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/update-in" title="&apos;Updates&apos; a value in a nested associative structure, where ks is a
  sequence of keys and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  nested structure.  If any levels do not exist, hash-maps will be
  created.">update-in</a></span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L226">parse-one</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span><span class="whitespace"> </span><span>[<span class="keyword">:val</span><span class="whitespace"> </span><span class="keyword">:delim</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/constantly" title="Returns a function that takes any number of arguments and returns x.">constantly</a></span><span class="whitespace"> </span><span class="string">"#{"</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">            </span><span class="string">'</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>]</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L226">parse-one</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>{<span class="keyword">:val</span><span class="whitespace"> </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:var-quote</span><span class="whitespace"> </span><span class="keyword">:text</span><span class="whitespace"> </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/-&gt;" title="Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.">-></a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="keyword">:val</span><span class="whitespace"> </span><span class="keyword">:text</span>)</span>}</span><span class="whitespace"> </span><span class="keyword">:rest</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">            </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:symbol</span><span class="whitespace"> </span><span class="keyword">:text</span><span class="whitespace"> </span><span class="string">"?"</span>}</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>]</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L226">parse-one</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">              </span><span>{<span class="keyword">:val</span><span class="whitespace"> </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:reader-conditional</span><span class="whitespace"> </span><span class="keyword">:text</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>}</span><span class="whitespace"> </span><span class="keyword">:rest</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/case" title="Takes an expression, and a set of clauses.

  Each clause can take the form of either:

  test-constant result-expr

  (test-constant1 ... test-constantN)  result-expr

  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.

  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type.">case</a></span><span class="whitespace"> </span><span>(<span class="keyword">:type</span><span class="whitespace"> </span><span class="symbol">nt</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="keyword">:string</span><span class="whitespace">
</span><span class="whitespace">              </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>]</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L226">parse-one</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                </span><span>{<span class="keyword">:val</span><span class="whitespace"> </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:regex</span><span class="whitespace"> </span><span class="keyword">:text</span><span class="whitespace"> </span><span>(<span class="keyword">:text</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span>}</span><span class="whitespace"> </span><span class="keyword">:rest</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">              </span><span class="keyword">:symbol</span><span class="whitespace">
</span><span class="whitespace">              </span><span>{<span class="keyword">:val</span><span class="whitespace"> </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:data-reader</span><span class="whitespace"> </span><span class="keyword">:text</span><span class="whitespace"> </span><span>(<span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">nt</span>)</span>}</span><span class="whitespace"> </span><span class="keyword">:rest</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>}</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="string">^</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>]</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L226">parse-one</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>{<span class="keyword">:val</span><span class="whitespace"> </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:meta</span><span class="whitespace"> </span><span class="keyword">:val</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>}</span><span class="whitespace"> </span><span class="keyword">:rest</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">        </span><span class="string">'</span><span class="whitespace"> </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>]</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L226">parse-one</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">             </span><span>{<span class="keyword">:val</span><span class="whitespace"> </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:quote</span><span class="whitespace"> </span><span class="keyword">:val</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>}</span><span class="whitespace"> </span><span class="keyword">:rest</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>}</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>{<span class="keyword">:val</span><span class="whitespace"> </span><span class="symbol">t</span><span class="whitespace"> </span><span class="keyword">:rest</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>}</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L264">parse-list</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">closer</span><span class="whitespace"> </span><span class="symbol">ots</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">forms</span><span class="whitespace"> </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">ts</span><span class="whitespace"> </span><span class="symbol">ots</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">t</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/first" title="Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.">first</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/if-let" title="bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else">if-let</a></span><span class="whitespace"> </span><span>[<span class="symbol">sub-closer</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L215">open->closed</a></span><span class="whitespace"> </span><span class="symbol">t</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>]</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L264">parse-list</a></span><span class="whitespace"> </span><span class="symbol">sub-closer</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">forms</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/=" title="Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure&apos;s immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.">=</a></span><span class="whitespace"> </span><span class="symbol">closer</span><span class="whitespace"> </span><span class="symbol">t</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span>{<span class="keyword">:val</span><span class="whitespace"> </span><span>{<span class="keyword">:type</span><span class="whitespace"> </span><span class="keyword">:coll</span><span class="whitespace"> </span><span class="keyword">:delim</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L221">closed->open</a></span><span class="whitespace"> </span><span class="symbol">closer</span>)</span><span class="whitespace"> </span><span class="keyword">:contents</span><span class="whitespace"> </span><span class="symbol">forms</span>}</span><span class="whitespace">
</span><span class="whitespace">           </span><span class="keyword">:rest</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/next" title="Returns a seq of the items after the first. Calls seq on its
  argument.  If there are no more items, returns nil.">next</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>}</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>]</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L226">parse-one</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">            </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">forms</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">do</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="var-ref"><a href="fipp.edn.html#L91">fipp.edn/pprint</a></span><span class="whitespace"> </span><span class="symbol">forms</span>)</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">throw</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/ex-info" title="Create an instance of ExceptionInfo, a RuntimeException subclass
   that carries a map of additional data.">ex-info</a></span><span class="whitespace"> </span><span class="string">"expecting closer"</span><span class="whitespace"> </span><span>{<span class="keyword">:closer</span><span class="whitespace"> </span><span class="symbol">closer</span><span class="whitespace"> </span><span class="keyword">:ts</span><span class="whitespace"> </span><span class="symbol">ts</span><span class="whitespace"> </span>}</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L281">parse-many</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">ts</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="macro">loop</span><span class="whitespace"> </span><span>[<span class="symbol">forms</span><span class="whitespace"> </span><span>[]</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">ts</span><span class="whitespace"> </span><span class="symbol">ts</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">if</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/some?" title="Returns true if x is not nil, false otherwise.">some?</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span>{<span class="keyword">:keys</span><span class="whitespace"> </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>]</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L226">parse-one</a></span><span class="whitespace"> </span><span class="symbol">ts</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">        </span><span>(<span class="macro">recur</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span class="symbol">forms</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/val" title="Returns the value in the map entry.">val</a></span>)</span><span class="whitespace"> </span><span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/rest" title="Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.">rest</a></span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">      </span><span class="symbol">forms</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L291">render-parse</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">t</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/case" title="Takes an expression, and a set of clauses.

  Each clause can take the form of either:

  test-constant result-expr

  (test-constant1 ... test-constantN)  result-expr

  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.

  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type.">case</a></span><span class="whitespace"> </span><span>(<span class="keyword">:type</span><span class="whitespace"> </span><span class="symbol">t</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:ws</span><span class="whitespace">           </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:whitespace</span>}</span><span class="whitespace"> </span><span>(<span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:symbol</span><span class="whitespace">       </span><span>(<span class="var-ref"><a href="a.html#L153">render-symbol</a></span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L114">parse-symbol</a></span><span class="whitespace"> </span><span class="symbol">t</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:string</span><span class="whitespace">       </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:string</span>}</span><span class="whitespace"> </span><span>(<span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:comment</span><span class="whitespace">      </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:comment</span>}</span><span class="whitespace"> </span><span>(<span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:data-reader</span><span class="whitespace">  </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:metadata</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/str" title="With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.">str</a></span><span class="whitespace"> </span><span class="string">"#"</span><span class="whitespace"> </span><span>(<span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:regex</span><span class="whitespace">        </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span class="string">"#"</span><span class="whitespace"> </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:strign</span>}</span><span class="whitespace"> </span><span>(<span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>]</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:char-literal</span><span class="whitespace"> </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:string</span>}</span><span class="whitespace"> </span><span>(<span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:meta</span><span class="whitespace">         </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span class="string">"^"</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L291">render-parse</a></span><span class="whitespace"> </span><span>(<span class="keyword">:val</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>)</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:quote</span><span class="whitespace">        </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span class="string">"'"</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L291">render-parse</a></span><span class="whitespace"> </span><span>(<span class="keyword">:val</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:var-quote</span><span class="whitespace">    </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span class="string">"#'"</span><span class="whitespace"> </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:var-ref</span>}</span><span class="whitespace"> </span><span>(<span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>]</span>]</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:coll</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/into" title="Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined. A transducer may be supplied.">into</a></span><span class="whitespace"> </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>(<span class="keyword">:delim</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/mapv" title="Returns a vector consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.">mapv</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L291">render-parse</a></span><span class="whitespace"> </span><span>(<span class="keyword">:contents</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>)</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L215">open->closed</a></span><span class="whitespace"> </span><span>(<span class="keyword">:delim</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:lambda</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/into" title="Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined. A transducer may be supplied.">into</a></span><span class="whitespace"> </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span class="string">"#("</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/conj" title="conj[oin]. Returns a new collection with the xs
    &apos;added&apos;. (conj nil item) returns (item).  The &apos;addition&apos; may
    happen at different &apos;places&apos; depending on the concrete type.">conj</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/mapv" title="Returns a vector consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.">mapv</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L291">render-parse</a></span><span class="whitespace"> </span><span>(<span class="keyword">:contents</span><span class="whitespace"> </span><span>(<span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>)</span>)</span><span class="whitespace"> </span><span class="string">")"</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="keyword">:reader-conditional</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/into" title="Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined. A transducer may be supplied.">into</a></span><span class="whitespace"> </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span class="string">"#?"</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/mapv" title="Returns a vector consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.">mapv</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L291">render-parse</a></span><span class="whitespace"> </span><span>(<span class="keyword">:contents</span><span class="whitespace"> </span><span>(<span class="keyword">:text</span><span class="whitespace"> </span><span class="symbol">t</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">    </span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/case" title="Takes an expression, and a set of clauses.

  Each clause can take the form of either:

  test-constant result-expr

  (test-constant1 ... test-constantN)  result-expr

  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.

  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type.">case</a></span><span class="whitespace"> </span><span class="symbol">t</span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="string">`</span><span class="whitespace"> </span><span class="string">~</span>)</span><span class="whitespace"> </span><span class="symbol">t</span><span class="whitespace">
</span><span class="whitespace">      </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:unparsed</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/pr-str" title="pr to a string, returning it">pr-str</a></span><span class="whitespace"> </span><span class="symbol">t</span>)</span>]</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="macro">def</span><span class="whitespace"> </span><span>^<span class="keyword">:dynamic</span></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L320">*timings-enabled*</a></span><span class="whitespace"> </span><span class="unknown">false</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defmacro" title="Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called.">defmacro</a></span><span class="whitespace"> </span><span class="var-ref macro"><a href="a.html#L322">timing</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span class="symbol">&</span><span class="whitespace"> </span><span class="symbol">body</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span>`<span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">start#</span><span class="whitespace"> </span><span>(<span class="java-class">System/<span class="symbol">nanoTime</span></span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">result#</span><span class="whitespace"> </span><span>(<span class="macro">do</span><span class="whitespace"> </span>~<span class="unknown">@body</span>)</span><span class="whitespace">
</span><span class="whitespace">         </span><span class="symbol">end#</span><span class="whitespace"> </span><span>(<span class="java-class">System/<span class="symbol">nanoTime</span></span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L320">*timings-enabled*</a></span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/printf" title="Prints formatted output, as per format">printf</a></span><span class="whitespace"> </span><span class="string">"%s: %.02f ms\n"</span><span class="whitespace"> </span>~<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/name" title="Returns the name String of a string, symbol or keyword.">name</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core//" title="If no denominators are supplied, returns 1/numerator,
  else returns numerator divided by all of the denominators.">/</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/double" title="Coerce to double">double</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/-" title="If no ys are supplied, returns the negation of x, else subtracts
  the ys from x and returns the result. Does not auto-promote
  longs, will throw on overflow. See also: -&apos;">-</a></span><span class="whitespace"> </span><span class="symbol">end#</span><span class="whitespace"> </span><span class="symbol">start#</span>)</span>)</span><span class="whitespace"> </span><span class="unknown">1e6</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="symbol">result#</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/defn" title="Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.">defn</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L331">render-code</a></span><span class="whitespace">
</span><span class="whitespace">  </span><span>[<span class="symbol">src</span>]</span><span class="whitespace">
</span><span class="whitespace">  </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/when" title="Evaluates test. If logical true, evaluates body in an implicit do.">when</a></span><span class="whitespace"> </span><span class="symbol">src</span><span class="whitespace">
</span><span class="whitespace">    </span><span>(<span class="macro">let</span><span class="whitespace"> </span><span>[<span class="symbol">lexed</span><span class="whitespace"> </span><span>(<span class="var-ref macro"><a href="a.html#L322">timing</a></span><span class="whitespace"> </span><span class="string">"lex"</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L53">lex</a></span><span class="whitespace"> </span><span>{<span class="keyword">:pos</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span class="keyword">:buf</span><span class="whitespace"> </span><span class="symbol">src</span>}</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">          </span><span class="symbol">forms</span><span class="whitespace"> </span><span>(<span class="var-ref macro"><a href="a.html#L322">timing</a></span><span class="whitespace"> </span><span class="string">"parse"</span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L281">parse-many</a></span><span class="whitespace"> </span><span class="symbol">lexed</span>)</span>)</span>]</span><span class="whitespace"> </span><span class="whitespace">
</span><span class="whitespace">      </span><span>(<span class="var-ref macro"><a href="a.html#L322">timing</a></span><span class="whitespace"> </span><span class="string">"render"</span><span class="whitespace">
</span><span class="whitespace">       </span><span>(<span class="var-ref macro"><a href="hiccup.core.html#L7" title="Render Clojure data structures to a string of HTML.">h/html</a></span><span class="whitespace">
</span><span class="whitespace">         </span><span>[<span class="keyword">:head</span><span class="whitespace"> </span><span>[<span class="keyword">:link</span><span class="whitespace"> </span><span>{<span class="keyword">:rel</span><span class="whitespace"> </span><span class="keyword">:stylesheet</span><span class="whitespace"> </span><span class="keyword">:href</span><span class="whitespace"> </span><span class="string">"code.css"</span>}</span>]</span><span class="whitespace">
</span><span class="whitespace">          </span><span>[<span class="keyword">:div</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:container</span>}</span><span class="whitespace">
</span><span class="whitespace">           </span><span>[<span class="keyword">:pre</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/into" title="Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined. A transducer may be supplied.">into</a></span><span class="whitespace"> </span><span>[<span class="keyword">:code</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="string">"gutter"</span>}</span>]</span><span class="whitespace">
</span><span class="whitespace">                   </span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/for" title="List comprehension. Takes a vector of one or more
   binding-form/collection-expr pairs, each followed by zero or more
   modifiers, and yields a lazy sequence of evaluations of expr.
   Collections are iterated in a nested fashion, rightmost fastest,
   and nested coll-exprs can refer to bindings created in prior
   binding-forms.  Supported modifiers are: :let [binding-form expr ...],
   :while test, :when test.

  (take 100 (for [x (range 100000000) y (range 1000000) :while (&lt; y x)] [x y]))">for</a></span><span class="whitespace"> </span><span>[<span class="symbol">line</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/range" title="Returns a lazy seq of nums from start (inclusive) to end
  (exclusive), by step, where start defaults to 0, step to 1, and end to
  infinity. When step is equal to 0, returns an infinite sequence of
  start. When start is equal to end, returns empty list.">range</a></span><span class="whitespace"> </span><span class="unknown">1</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/inc" title="Returns a number one greater than num. Does not auto-promote
  longs, will throw on overflow. See also: inc&apos;">inc</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/count" title="Returns the number of items in the collection. (count nil) returns
  0.  Also works on strings, arrays, and Java Collections and Maps">count</a></span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="clojure.string.html#L228" title="Splits s on \n or \r\n.">clojure.string/split-lines</a></span><span class="whitespace"> </span><span class="symbol">src</span>)</span>)</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">                     </span><span>[<span class="keyword">:span</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="keyword">:punctuation</span><span class="whitespace"> </span><span class="keyword">:id</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/format" title="Formats a string using java.lang.String.format, see java.util.Formatter for format
  string syntax">format</a></span><span class="whitespace"> </span><span class="string">"L%d"</span><span class="whitespace"> </span><span class="symbol">line</span>)</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/format" title="Formats a string using java.lang.String.format, see java.util.Formatter for format
  string syntax">format</a></span><span class="whitespace"> </span><span class="string">"%04d\n"</span><span class="whitespace"> </span><span class="symbol">line</span>)</span>]</span>)</span>)</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>[<span class="keyword">:div</span><span class="whitespace"> </span><span>{<span class="keyword">:style</span><span class="whitespace"> </span><span class="string">"width:1px;"</span>}</span>]</span><span class="whitespace">
</span><span class="whitespace">           </span><span>[<span class="keyword">:pre</span><span class="whitespace"> </span><span>{<span class="keyword">:class</span><span class="whitespace"> </span><span class="string">"source"</span>}</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/into" title="Returns a new coll consisting of to-coll with all of the items of
  from-coll conjoined. A transducer may be supplied.">into</a></span><span class="whitespace"> </span><span>[<span class="keyword">:code</span>]</span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/mapv" title="Returns a vector consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.">mapv</a></span><span class="whitespace"> </span><span class="var-ref"><a href="a.html#L291">render-parse</a></span><span class="whitespace"> </span><span class="symbol">forms</span>)</span>)</span>]</span>]</span>]</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span>(<span class="var-ref macro clojure-core"><a href="https://clojuredocs.org/clojure.core/binding" title="binding =&gt; var-symbol init-expr

  Creates new bindings for the (already-existing) vars, with the
  supplied initial values, executes the exprs in an implicit do, then
  re-establishes the bindings that existed before.  The new bindings
  are made in parallel (unlike let); all init-exprs are evaluated
  before the vars are bound to their new values.">binding</a></span><span class="whitespace"> </span><span>[<span class="var-ref"><a href="a.html#L320">*timings-enabled*</a></span><span class="whitespace"> </span><span class="unknown">true</span>]</span><span class="whitespace">
</span><span class="whitespace"> </span><span>(<span class="var-ref macro"><a href="a.html#L322">timing</a></span><span class="whitespace"> </span><span class="string">"total"</span><span class="whitespace">
</span><span class="whitespace">   </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/spit" title="Opposite of slurp.  Opens f with writer, writes content, then
  closes f. Options passed to clojure.java.io/writer.">spit</a></span><span class="whitespace">
</span><span class="whitespace">     </span><span class="string">"/Users/russell/src/autochrome/example.html"</span><span class="whitespace">
</span><span class="whitespace">     </span><span>(<span class="var-ref"><a href="a.html#L331">render-code</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/slurp" title="Opens a reader on f and reads all its contents, returning a string.
  See clojure.java.io/reader for a complete list of supported arguments.">slurp</a></span><span class="whitespace"> </span><span class="string">"/Users/russell/src/autochrome/a.clj"</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">     </span><span class="metadata">#_</span><span>(<span class="var-ref"><a href="a.html#L331">render-code</a></span><span class="whitespace"> </span><span>(<span class="var-ref clojure-core"><a href="https://clojuredocs.org/clojure.core/slurp" title="Opens a reader on f and reads all its contents, returning a string.
  See clojure.java.io/reader for a complete list of supported arguments.">slurp</a></span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="clojure.java.io.html#L446" title="Returns the URL for a named resource. Use the context class loader
   if no loader is specified.">io/resource</a></span><span class="whitespace"> </span><span class="string">"clojure/core.clj"</span>)</span>)</span>)</span>)</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span><span class="metadata">#_</span><span>(<span class="var-ref"><a href="a.html#L226">parse-one</a></span><span class="whitespace"> </span><span>(<span class="var-ref"><a href="a.html#L53">lex</a></span><span class="whitespace"> </span><span>{<span class="keyword">:pos</span><span class="whitespace"> </span><span class="unknown">0</span><span class="whitespace"> </span><span class="keyword">:buf</span><span class="whitespace"> </span><span class="string">"'(a b c)"</span>}</span>)</span>)</span><span class="whitespace">
</span><span class="whitespace">
</span></code></pre></div></head>